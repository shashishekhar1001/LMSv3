
/**
 * Raven Placebo Class
 * 
 * Define placebo class incase there was an error loading the library (or it was
 * blocked by an aggressive AdBlocker).
 */
 if (
    'Raven.config'.validMethod() === false
    || 'Raven.context'.validMethod() === false
) {
    window.Raven = {
        config: function(key, options) {
            return {
                install: function() {}
            };
        },
        context: function(callback) {
            callback();
        }
    };
}

/**
 * Raven Setup
 * 
 * Set the key, install it, and wrap app code in callback method to ensure all
 * possible errors are captured.
 * 
 * @see     https://docs.sentry.io/clients/javascript/config/
 */
Raven.config(window.SENTRYDSN, {
    sampleRate: 1.0,

    /**
     * Addresses the issue with line numbers and signatures being off when an
     * error or console log occurs with Sentry activated.
     * 
     * At the moment, I only need this when I'm working locally.
     * 
     * @see     https://forum.sentry.io/t/sentry-raven-js-obfuscates-my-console-line-numbers/2262
     */
    // autoBreadcrumbs: {
    //     'console': false
    // },

    /**
     * ignoreErrors
     * 
     * @access  private
     * @var     Array
     */
    ignoreErrors: [
        /^Cookies are required for Stencil$/,
        /^Modern browser is required for Stencil$/
    ],

    /**
     * shouldSendCallback
     * 
     * Performs a series of checks to determine whether errors should be sent to
     * Sentry. They are as follows:
     * 1) If the Stencil object isn't available, it's likely that the user agent
     * has an issue loading something else, in which case that's not on us
     * 2) If it is available, but the options are an empty object, it likely
     * means that the app hasn't yet been initiated (and is being run via an
     * extension).
     * 3) If the Services object isn't available, app isn't fully ready yet
     * 4) If the Sentry service is turned off, then bail
     * 
     * @access  private
     * @param   Object data
     * @return  Boolean
     */
    shouldSendCallback: function(data) {
        var stencilInitiated = function() {
            if (window.Stencil === undefined) {
                return false;
            }
            return JSON.stringify(Stencil.getOptions()) !== JSON.stringify({});
        };
        if (stencilInitiated() === false) {
            return false;
        }
        if (window.Services === undefined) {
            return false;
        }
        if (Services.check('sentry') === false) {
            return false;
        }
        // data.options = Stencil.getOptions();
        return true;
    }
}).install();
Raven.context(function () {

/**
 * Account
 * 
 * Acts as a proxy for the session AccountAccessor, and makes it easier to bind
 * events to an all-purpose helper.
 * 
 * @note    This proxy is useful especially with login, since the
 *          AccountAccessor for a guest account ceases to exist after a login.
 *          Therefore binding to this singleton gets around issues with that.
 * @fires   upgrade
 * @abstract
 */
window.Account = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'account')
     */
    var __classType = 'account';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Account')
     */
    var __string = 'Account';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * coupon
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        coupon: function() {
            return Stencil.account().coupon();
        },

        /**
         * delinquent
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        delinquent: function() {
            return Stencil.account().delinquent();
        },

        /**
         * draftIsLocked
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        draftIsLocked: function() {
            return Stencil.account().draftIsLocked();
        },

        /**
         * favorites
         * 
         * @access  public
         * @return  Object
         */
        favorites: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                var favorites = Stencil.account().get('favorites'),
                    key = accessor.get('key');
                if (accessor.toString() === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                favorites.push(key);
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var favorites = Stencil.account().get('favorites'),
                    key = accessor.get('key'),
                    index;
                if (accessor.toString() === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = favorites.indexOf(key);
                if (index !== -1) {
                    favorites.splice(index, 1);
                }
            }
        },

        /**
         * free
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        free: function() {
            return Stencil.account().free();
        },

        /**
         * guest
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        guest: function() {
            return Stencil.account().guest();
        },

        /**
         * highlightAllDrawingsOnSnap
         * 
         * @access  public
         * @return  Boolean
         */
        highlightAllDrawingsOnSnap: function() {
            return Config.default('highlightAllDrawingsOnSnap') === true;
        },

        /**
         * highlightCenterGuidesOnSnap
         * 
         * @access  public
         * @return  Boolean
         */
        highlightCenterGuidesOnSnap: function() {
            return Config.default('highlightCenterGuidesOnSnap') === true;
        },

        /**
         * lifetime
         * 
         * @access  public
         * @return  Boolean
         */
        lifetime: function() {
            if (Account.upgraded() === false) {
                return false;
            }
            var upgrade = Account.upgrade();
            if (upgrade.get('interval') === 'lifetime') {
                return true;
            }
            return false;
        },

        /**
         * max
         * 
         * @access  public
         * @return  Object
         */
        max: {

            /**
             * bonus
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            bonus: function() {
                var account = Stencil.account();
                return account.max.bonus.apply(account);
            },

            /**
             * favorites
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            favorites: function() {
                var account = Stencil.account();
                return account.max.favorites.apply(account);
            },

            /**
             * images
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            images: function() {
                var account = Stencil.account();
                return account.max.images.apply(account);
            },

            /**
             * sms
             * 
             * @note    proxy
             * @access  public
             * @return  Boolean
             */
            sms: function() {
                var account = Stencil.account();
                return account.max.sms.apply(account);
            }
        },

        /**
         * on
         * 
         * @access  public
         * @return  void
         */
        // on: function() {
        //     $(Account).on.apply($(Account), $(arguments).toArray());
        // },

        /**
         * onboard
         * 
         * Loads the appropriate modal if the loaded account has not yet seen
         * a specific just in time onboarding screen.
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        onboard: function(key) {
            var account = Stencil.account(),
                jitOnboarding = account.setting('jitOnboarding');
            jitOnboarding = JSON.parse(jitOnboarding);
            if (key === 'backgroundSelected' || key === 'foregroundSelected') {
                if (
                    jitOnboarding.backgroundSelected === undefined
                    && jitOnboarding.foregroundSelected === undefined
                ) {
                    Stencil.set('ignoreMouseDownLayerBlur', true);
                    jitOnboarding[key] = true;
                    account.set({
                        'settings.jitOnboarding': JSON.stringify(jitOnboarding)
                    });
                    account.save(['settings.jitOnboarding']);
                    var modal = Modals.showOnboarding(key);
                    modal.once({
                        'leave': function(event) {
                            Stencil.set('ignoreMouseDownLayerBlur', false);
                        }
                    });
                }
            }
        },

        /**
         * once
         * 
         * @access  public
         * @return  void
         */
        // once: function() {
        //     $(Account).one.apply($(Account), $(arguments).toArray());
        // },

        /**
         * plan
         * 
         * @note    proxy
         * @access  public
         * @param   String plan
         * @return  Boolean
         */
        plan: function(plan) {
            return Stencil.account().plan(plan);
        },

        /**
         * promo
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        promo: function() {
            return Stencil.account().promo();
        },

        /**
         * rates
         * 
         * @access  public
         * @var     Object
         */
        rates: {

            /**
             * raw
             * 
             * Provides object breaking down annual and monthly rates for the
             * available plans.
             * 
             * @access  public
             * @return  Object
             */
            raw: function() {
                var upgrade = Account.upgrade(),
                    plans = Config.get('plans');
                if (upgrade !== undefined) {
                    var plan = upgrade.get('plan');
                    if (plan === 'pro') {
                        return {
                            annually: {
                                pro: upgrade.get('annuallyProRate'),
                                unlimited: plans.unlimited.rates.annually
                            },
                            monthly: {
                                pro: upgrade.get('monthlyProRate'),
                                unlimited: plans.unlimited.rates.monthly
                            }
                        };
                    } else if (plan === 'unlimited') {
                        return {
                            annually: {
                                pro: plans.pro.rates.annually,
                                unlimited: upgrade.get('annuallyUnlimitedRate')
                            },
                            monthly: {
                                pro: plans.pro.rates.monthly,
                                unlimited: upgrade.get('monthlyUnlimitedRate')
                            }
                        };
                    }
                    throw new Error('Invalid plan during raw lookup');
                }
                return {
                    annually: {
                        pro: plans.pro.rates.annually,
                        unlimited: plans.unlimited.rates.annually
                    },
                    monthly: {
                        pro: plans.pro.rates.monthly,
                        unlimited: plans.unlimited.rates.monthly
                    }
                };
            },

            /**
             * relative
             * 
             * Returns the annual rate broken down to relative-monthly pricing.
             * 
             * @access  public
             * @param   String plan
             * @return  Number
             */
            relative: function(plan) {
                var raw = Account.rates.raw(),
                    annually = raw.annually[plan];
                return Math.round(annually / 12);
            }
        },

        /**
         * requireCaptcha
         * 
         * @access  public
         * @return  Boolean
         */
        requireCaptcha: function() {
return false;
            var exemptCountryCodes = [
                    'ar',
                    'ca',
                    'de',
                    'gb',
                    'il',
                    'it',
                    'pl',
                    'us'
                ],
                countryCode = Stencil.account().geo().country.code;
            countryCode = countryCode.toLowerCase();
            if (ArrayUtils.contains(countryCode, exemptCountryCodes) === false) {
                return true;
            }
return true;
            return false;
        },

        /**
         * showWelcomeTour
         * 
         * Goal is to determine whether the welcome tour should automatically be
         * shown. This is determined by first ensuring the account is a
         * guest-account, then checking to see if the user is in the curtain
         * authentication flow, then checking if the signup modal is showing and
         * then finally ensuring the guest account has not yet seen the welcome
         * tour.
         * 
         * Check for the curtain to prevent the WelcomeTour modal from taking
         * over when a guest attempts to signup or login from the public site.
         * 
         * Check for /app/signup is incase a user was sent directly to a url
         * like /app/checkout/pro/coupon/FREETRIAL
         * In that case, we just want to take them through the flow without the
         * WelcomeModal interrupting.
         * 
         * @access  public
         * @return  Boolean
         */
        showWelcomeTour: function() {
            if (Account.guest() === false) {
                return false;
            }
            if (location.href.match(/curtain/) !== null) {
                return false;
            }
            if (location.href.match(/\/app\/signup/) !== null) {
                return false;
            }
            return Stencil.account().setting('hasSeenWelcomeTour').toInt() === 0;
        },

        /**
         * triggerHandler
         * 
         * @access  public
         * @return  void
         */
        // triggerHandler: function() {
        //     var msg = arguments[0];
        //     LogUtils.log.objects.account(msg);
        //     $(Account).triggerHandler.apply($(Account), $(arguments).toArray());
        // },

        /**
         * unbind
         * 
         * @access  public
         * @return  void
         */
        // unbind: function() {
        //     $(Account).unbind.apply($(Account), $(arguments).toArray());
        // },

        /**
         * upgrade
         * 
         * @note    proxy
         * @access  public
         * @return  UpgradeAccessor|undefined
         */
        upgrade: function() {
            return Stencil.account().reference('upgrade');
        },

        /**
         * upgraded
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        upgraded: function() {
            return Stencil.account().upgraded();
        }
    });
})();

/**
 * Alerts
 * 
 * @todo     Move this to the server side
 * @abstract
 */
window.Alerts = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'alerts')
     */
    var __classType = 'alerts';

    /**
     * __settings
     * 
     * @access  private
     * @return  Object
     */
    var __settings = {
        'accountDock.extension.disabled': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Some embarrassing news..',
            message: 'Unfortunately your billing history cannot be accessed ' +
                'through the Stencil extension.<br /><br />Please access it at: ' +
                '<a href="https://getstencil.com/app/settings/payment" target="_blank" class="text">https://getstencil.com/app/settings/payment</a>',
            slim: false
        },
        'account.downgrade': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Contact us to downgrade.',
            // message: 'Looks like you\'re trying to downgrade your plan, ' +
            //     'which will essentially cancel your current plan.<br />' +
            //     'Please <a href="/contact" target="_blank" class="text">contact us</a> for more details.',
            message: 'We\'re currently in the process of improving our plan ' +
                'management options. Please ' +
                '<a href="/contact" target="_blank" class="text">contact us</a> ' +
                'directly to cancel at this time. Apologies for any ' +
                'inconvenience.',
            buttons: [
                {
                    copy: 'Okay, got it'
                }
            ],
            slim: false
        },
        'account.sessionAccount.false': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Please reload Stencil',
            message: 'It looks like you\'ve been logged out. Please reload ' +
                'Stencil to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'account.refilled': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Account refilled',
            message: 'Looks like while you\'ve been using Stencil, we ' +
                'refilled your account\'s monthly limits.<br /><br />So if ' +
                'some numbers jumped around, just so you know, that\'s what ' +
                'happened.',
            slim: true
        },
        'account.unlimited.limit.sms': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'You have reached your SMS limit',
            message: 'Please <a href="/contact" target="_blank" class="text">contact us</a> for details on ' +
                'raising your account limit.',
            slim: true
        },
        'account.upgrade': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Contact us to upgrade.',
            message: 'Looks like you\'re trying to upgrade your plan. ' +
                'Please <a href="/contact" target="_blank" class="text">contact us</a> for more details.',
            buttons: [
                {
                    copy: 'Okay, got it'
                }
            ],
            slim: true
        },
        'adBlocker.found': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'AdBlockers may affect your experience',
            message: 'We detected that you\'re using an AdBlocker. Just a ' +
                'heads-up this may affect your experience on Stencil.<br /><br />We ' +
                'recommend you turn it off for getstencil.com to ensure ' +
                'things run smoothly.<br /><br />' +
                'If you\'re not able to, you may experience some issues.',
            slim: false
        },
        'admin.user.update': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'User record updated',
            message: 'All set! Please click the Reload button below to have ' +
                'changes reflected.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return Stencil.get('temporaryReloadUrl');
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'app.maintenance': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Upgrading Stencil',
            message: 'Unfortunately you caught us while we\'re upgrading ' +
                'Stencil. None of your changes have been lost, and we\'ll be ' +
                'available again in about <strong>maintenanceModeDurationString</strong>.' +
                '<br /><br />Thanks for your understanding.',
            closable: false,
            buttons: [],
            slim: true
        },
        'canvas.text.rclick': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Looking to paste text?',
            message: 'If you\'re on Windows, use [CTRL+V] on ' +
                'your keyboard to paste text.<br />' +
                'If you\'re on a Mac, use [Command+V] on your ' +
                'keyboard to paste text.',
            slim: false
        },
        'connection': {
            icons: {
                primary: 'black icon-only sift sift-cloud-stop'
            },
            headline: 'Internet connection issue',
            message: 'It looks like your connection to the internet may have ' +
                'dropped. Please ensure you\'re properly connected and ' +
                'reload Stencil.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'cookies.cleared': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Please reload Stencil',
            message: 'We had trouble accessing your cookies, which is needed ' +
                'for Stencil to work properly.<br /><br />' +
                'This can happen if you reset them or your computer runs out ' +
                'of memory. Reloading should fix this.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'dependency.failed': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not load some code',
            message: 'Unfortunately, we could not load some required code.' +
                '<br />This could mean your internet connection is down, you ' +
                'have an ad blocker installed that is preventing the code ' +
                'from being loaded, or possibly something is wrong on our ' +
                'side. <br /><br />Please disable any ad blockers you may ' +
                'have turned on, and try again.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'devicePixelRatio.change': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Heads up!',
            message: 'We just detected a change to your display settings and ' +
                'need you to reload Stencil.<br /><br />Don\'t worry: we\'ve ' +
                'saved your image and nothing will be lost.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'extension.conflicting.ezLinkPreview': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'ezLinkPreview Extension Issue',
            message: 'It looks like you have the ezLinkPreview extension ' +
                'installed. Unfortunately it can cause issues with Stencil. ' +
                'We recommend you turn it off.<br /><br />If you\'re not ' +
                'able to, it may cause issues. Contact support if you notice ' +
                'anything strange.',
            slim: false
        },
        'extension.conflicting.ghostery': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Ghostery Extension Issue',
            message: 'It looks like you have the Ghostery extension ' +
                'installed. Unfortunately it can cause issues with Stencil. ' +
                'We recommend you turn it off.<br /><br />If you\'re not ' +
                'able to, it may cause issues. Contact support if you notice ' +
                'anything strange.',
            slim: true
        },
        'extension.install.chrome': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Google Chrome Required',
            message: 'Please use Google Chrome to use the Stencil Chrome ' +
                'Extension.<br /><br />You can download it ' +
                '<a href="https://www.google.com/chrome/" target="_blank" class="text">here</a>.',
            slim: true
        },
        'extension.install.window': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Browser security requirement',
            message: 'To install the Stencil Extension for Chrome, please ' +
                'visit ' +
                '<a href="https://getstencil.com/app/extras" target="_blank" class="text">https://getstencil.com/app/extras</a>',
            slim: true
        },
        'facebook.auth.minimum': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not connect to your Facebook account',
            message: 'In order to connect your Facebook account, Stencil ' +
                'requires you to accept all the permissions when prompted. ' +
                '<br /><br />Please know that we will ' +
                '<strong class="underline">never</strong> post to your ' +
                'profile or page without you clicking a button to do so.',
            slim: false
        },
        'facebook.logout': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Could not find any new <br />profiles or pages',
            message: 'All the profiles &amp; pages linked to the Facebook ' +
                'account you\'re logged in with have ' +
                'already been added to Stencil. <br /><br />To connect a ' +
                'completely new profile, please log out on Facebook and try again.',
            buttons: [
                {
                    copy: 'Logout from Facebook',
                    path: function() {
                        return 'https://facebook.com';
                    },
                    target: '_blank'
                }
            ],
            slim: true
        },
        'frame.ratio.unchanged': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Heads up!',
            message: 'While you may not notice a different in your image ' +
                'above, we\'ve recorded the change in dimensions, and when ' +
                'you save or download this image, it will be your new size.',
            slim: true
        },
        'import.failed': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not import that image',
            message: 'Unfortunately, we could not import the image you ' +
                'right-clicked. Please try uploading it right into Stencil.',
            slim: true
        },
        'import.failed.max.filesize': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Right-clicked image is too large',
            message: 'Unfortunately, the image you attempted to use is ' +
                'larger than the maximum allowed. Please try another.',
            slim: true
        },
        'import.normalize.disabled': {// Not currently being used
            headline: 'Cannot load this image right now',
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            message: 'We\'re fixing some bugs, and cannot load this image ' +
                'right now. Please try again shortly.',
            slim: true
        },
        /**
         * The follow error can be encountered if bit.ly doesn't come back with
         * a proper response. Ran into this locally because the request was
         * timing out (presumably to do with my internet connection).
         */
        'image.shortUrl.error': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not create short url',
            message: 'There was a problem creating a short url for this ' +
                'image. Apologies for that. Please try again at another time.',
            slim: true
        },
        'image.upload.error': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not save your image',
            message: 'Something strange happened and we could not save your ' +
                'image. Please reload Stencil to continue where you left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'image.upload.exception': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Problem while saving',
            message: 'We are having trouble with your browser. Please try ' +
                'another browser until we can fix the issue in this version.',
            closable: false,
            buttons: [],
            slim: true
        },
        'image.uploaded': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Image has been saved',
            message: 'Thanks for your patience. Go ahead and try again.',
            slim: true
        },
        'image.uploaded.already': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'This image has already been saved',
            message: 'It seems like this image was already saved in another ' +
                'tab, browser, or on another computer. Please reload Stencil ' +
                'to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'image.uploaded.deleted': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Account being used in multiple locations',
            message: 'It appears this account is being used on more than one ' +
                'computer, tab or browser. At this time, Stencil accounts ' +
                'cannot be used simultaneously.<br /><br />' +
                'Please log out from your other device and then reload ' +
                'Stencil.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'image.uploading': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Image is still being saved',
            message: 'Please wait a moment and then try again.',
            slim: true
        },
        'password.reset': {// Not currently being used
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Please check your email',
            message: 'We\'ve sent you instructions on how to change your ' +
                'password.',
            slim: true
        },
        'modal.paused': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Just a second..',
            message: 'Please wait until your submission has finished.',
            slim: true
        },
        'resource.filesize.excessive': {// Not currently being used
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not load image',
            message: 'Sorry about the trouble, but we are not able to load ' +
                'that image. Please try a different one.',
            slim: true
        },
        'service.aws': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Saving options temporarily off',
            message: 'Sorry about the trouble.<br /><br />We\'re working on ' +
                'the problem, and will have things up and running as soon as ' +
                'possible. Your image has been saved, so when you come back ' +
                'you will be able to get going quickly.',
            slim: false
        },
        'service.aws.skew.fail': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Connection error',
            message: 'We could not connect to a server needed for Stencil to ' +
                'work properly.<br /><br />' +
                'This can sometimes happen if you are behind a [firewall] or ' +
                'have an [Ad Blocker] installed that blocks access to the ' +
                'Amazon AWS services.<br /><br />' +
                'If that isn\'t the issue, please check your computer\'s ' +
                '[Date &amp; Time Preferences] to make sure your system clock ' +
                '&amp; timezone are properly set.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload Stencil',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'service.fonts.disabled': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Font uploading temporarily off',
            message: 'Sorry about the trouble.<br /><br />We\'re working on ' +
                'the problem, and will have things up and running as soon as ' +
                'possible.',
            slim: true
        },
        'search.bug': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Error with Stencil search results',
            message: 'Unfortunately, an error has occured with your search. ' +
                'Please reload Stencil to continue.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'clients.electron.images.download.single.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Image downloaded!',
            message: 'Your image has been successfully downloaded. Please ' +
                'check your file system for the image.',
            slim: true
        },
        'clients.electron.images.download.multiple.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Images downloaded!',
            message: 'Your images have been successfully downloaded. Please ' +
                'check your file system for the images.',
            slim: true
        },
        'clients.electron.uploads.download.single.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Upload downloaded!',
            message: 'Your upload has been successfully downloaded. Please ' +
                'check your file system for the upload.',
            slim: true
        },
        'clients.electron.uploads.download.multiple.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Uploads downloaded!',
            message: 'Your uploads have been successfully downloaded. Please ' +
                'check your file system for the uploads.',
            slim: true
        },
        'clients.electron.watermarks.download.single.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Watermark / Logo downloaded!',
            message: 'Your watermark / logo has been successfully ' +
                'downloaded. Please check your file system for the logo / ' +
                'watermark.',
            slim: true
        },
        'clients.electron.watermarks.download.multiple.complete': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Watermarks / Logos downloaded!',
            message: 'Your watermarks / logos have been successfully ' +
                'downloaded. Please check your file system for the logos / ' +
                'watermarks.',
            slim: true
        },
        'download.bug': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Problem downloading your image',
            message: 'We\'re really sorry about this, but something went ' +
                'wrong while tryng to download your image. We\'re aware of ' +
                'this issue and we\'re working hard to fix it.<br /><br />' +
                'Please reload Stencil and try to download again.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: false
        },
        'search.expired': {// Not currently being used
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Please reload Stencil',
            message: 'For security purposes, please reload Stencil to ' +
                'continue where you left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },
        'svg.load.fail': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Temporary icon issue',
            message: 'Sorry, but at the moment we\'re having trouble loading '+
                'that icon. Please try another, while we work on a fix.',
            slim: true
        },
        'svg.load.fail.2': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Temporary icon issue',
            message: 'Sorry, but at the moment we\'re having trouble loading '+
                'a specific icon. It may not appear in your image at for the ' +
                'moment.',
            slim: true
        },
        'timeout': {// Not currently being used
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Request timed out',
            message: 'Apologies, but it seems like we\'re getting overloaded ' +
                'with traffic. Please reload Stencil to continue where you ' +
                'left off.',
            closable: false,
            buttons: [
                {
                    copy: 'Reload',
                    path: function() {
                        return location.href;
                    },
                    target: '_parent'
                }
            ],
            slim: true
        },

        /**
         * Font import max
         * 
         */
        'font.import.max': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Max fonts reached',
            message: 'For performance reasons, you cannot have more than ' +
                '50 fonts in your My Fonts section at time. Sorry for the ' +
                'inconvenience.',
            slim: true
        },

        /**
         * Security
         * 
         */
        'security.failedDataIntegrityCheck': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Oh ho!',
            message: 'Something went wrong. Please contact support. You ' +
                'really should not be seeing this message.',
            closable: false,
            buttons: [
                {
                    copy: 'Contact Support',
                    path: function() {
                        return '/contact';
                    },
                    target: '_blank'
                }
            ],
            slim: true
        },

        /**
         * Font uploads
         * 
         */
        'upload.font.failed': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Could not process font',
            message: 'There was an issue processing your font. Please ensure ' +
                'the font is either an `OTF`, `TTF`, `WOFF` or `WOFF2` font file.' +
                '<br /><br />If you are trying to upload a `ZIP` file, please ' +
                'unzip it first, and then try again.<br /><br />Otherwise, ' +
                'please try another font, or '+
                '<a href="https://getstencil.com/contact" class="text" target="_blank">contact support</a>.',
            slim: false
        },
        'upload.font.max.count': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Too many font uploads',
            message: 'Unfortunately you can only upload up to 20 fonts at once.',
            slim: true
        },
        'upload.font.max.filesize': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'One of your font uploads is too large',
            message: 'Unfortunately we can only process font uploads that ' +
                'are less than 2 megabytes.',
            slim: true
        },
        'upload.font.max.filesize.admin': {// Not currently being used
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'One of your font uploads is too large',
            message: 'Unfortunately we can only process font uploads that ' +
                'are less than 2 megabytes.',
            slim: true
        },
        'upload.font.type': {// Only used when a .zip file is detected
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Only `OTF`, `TTF`, `WOFF` and `WOFF2` fonts',
            message: 'Please ensure fonts are either `OTF`, `TTF`, `WOFF` or ' +
                '`WOFF2`.<br /><br />If you are trying to upload a `ZIP` file, ' +
                'please unzip it first, and then upload the unzipped font ' +
                'files.',
            slim: true
        },

        /**
         * Image uploads
         * 
         */
        'upload.image.max.count': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Too many image uploads',
            message: 'Unfortunately you can only upload up to 50 images at ' +
                'once.',
            slim: true
        },
        'upload.image.max.filesize': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'One of your image uploads is too large',
            message: 'Unfortunately we can only process image uploads that ' +
                'are less than 30 megabytes.',
            slim: true
        },
        'upload.image.max.filesize.admin': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'One of your image uploads is too large',
            message: 'Unfortunately we can only process image uploads that ' +
                'are less than 30 megabytes.',
            slim: true
        },
        'upload.image.type': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Only `PNG`, `JPEG` and `GIF` images',
            message: 'Currently, you can only upload `PNG`, `JPEG` or `GIF` ' +
                'images.',
            slim: true
        },

        /**
         * Upload filesize issues
         * 
         */
        'upload.multiple.filesize.zero': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'One of your files cannot be uploaded',
            message: 'Unfortunately we won\'t be able to process your upload. ' +
                'One of your files is empty, and cannot be uploaded. Please ' +
                'try another.',
            slim: true
        },
        'upload.singular.filesize.zero': {
            icons: {
                primary: 'warning icon-only sift sift-warning'
            },
            headline: 'Cannot upload that file',
            message: 'Unfortunately we won\'t be able to process that file. ' +
                'It may not be the right format. Please try another.',
            slim: true
        },

        /**
         * 
         * 
         */
        'users.checkout.blocked': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Cannot upgrade your account',
            message: 'Please contact support for help in upgrading your ' +
                'account.',
            closable: true,
            buttons: [
                {
                    copy: 'Contact Stencil Support',
                    path: function() {
                        return 'https://getstencil.com/contact';
                    }
                }
            ],
            slim: true
        },

        /**
         * User related alerts
         * 
         */
        'users.obfuscate.success': {
            icons: {
                primary: 'success icon-only sift sift-checkmark'
            },
            headline: 'Your account has been deleted',
            message: 'Thanks for using Stencil. Please feel free to contact ' +
                'us if you have any questions in the future.',
            closable: false,
            buttons: [
                {
                    copy: 'Go to Stencil homepage',
                    path: function() {
                        return 'https://getstencil.com/?deleted';
                    }
                }
            ],
            slim: true
        },
        'users.obfuscate.failed.subscription': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Your account could not be deleted',
            message: 'You still have an active subscription with us. Please ' +
                'contact support to have us cancel your subscription before ' +
                'attempting to delete your account.',
            closable: true,
            buttons: [
                {
                    copy: 'Contact Stencil Support',
                    path: function() {
                        return 'https://getstencil.com/contact';
                    }
                }
            ],
            slim: true
        },
        'users.obfuscate.failed.other': {
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Your account could not be deleted',
            message: 'Please contact support for help deleting your account.',
            closable: true,
            buttons: [
                {
                    copy: 'Contact Stencil Support',
                    path: function() {
                        return 'https://getstencil.com/contact';
                    }
                }
            ],
            slim: true
        },

        /**
         * AdBlocker
         * 
         */
        'window.blocked': {// Not currently being used
            icons: {
                primary: 'info icon-only sift sift-exclamation-point'
            },
            headline: 'Window Blocked',
            message: 'We could not complete the action because your browser ' +
                'is blocking popups. Please turn this off to continue.' +
                '<br /><br /><a href="https://bit.ly/1SINEbr" class="text" target="_blank">Learn more &rarr;</a>',
            slim: true
        }
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Alerts')
     */
    var __string = 'Alerts';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * show
         * 
         * @access  public
         * @param   String code
         * @return  AlertModalView
         */
        show: function(code) {
            return Modals.showAlert(code, __settings[code]);
        }
    });
})();
StencilBooter.queue.push(StencilBooter.requires('Class', function() {

    /**
     * Base
     * 
     * @fires   set
     *          set/<x>
     * @extends Class
     */
    window.Base = Class.extend({

        /**
         * _classType
         * 
         * Variable to track what type of class the instance is, which is then
         * used in logging to show a different color for the message.
         * 
         * I chose the variable name <_classType> because <_type> might be too
         * generall, and conflict with other instance-properties. 
         * 
         * @access  protected
         * @var     String (default: 'base')
         */
        _classType: 'base',

        /**
         * _data
         * 
         * Simple storage hash that can be used quite widely, since so many
         * classes extend Base.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _data: {},

        /**
         * _logEvents
         * 
         * Marks whether or not events that are triggered against this object
         * are logged to the console.
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _logEvents: true,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Base')
         */
        _string: 'Base',

        /**
         * _timers
         * 
         * Object to keep track of timers, instance-wide.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _timers: {},

        /**
         * init
         * 
         * @note    The extend.js library is limited in that there is a bug
         *          around array/object references. Specifically, the
         *          constructor always needs to be reset array/object
         *          references. This is to prevent a foundational bug with the
         *          library whereby adding elements to an instance array or
         *          setting properties to an instance object/map causes values
         *          to persist between instances. It's a huge bug, but one that
         *          is relatively easy to work-around: make sure that the any
         *          arrays or objects that are available to a class are reset
         *          upon instance instantiation.
         * @access  public
         * @return  void
         */
        init: function() {
            this._data = {};
            this._timers = {};
        },

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        get: function(key) {
            return this._data[key];
        },

        /**
         * getClassType
         * 
         * @access  public
         * @return  String
         */
        getClassType: function() {
            return this._classType;
        },

        /**
         * log
         * 
         * Logging method, which with the exception of the override parameter,
         * abides by the logic within Stencil.log as to whether or not anything
         * is actually logged to the console. The toString method is used here
         * to pass along the name of the instance.
         * 
         * @access  public
         * @param   undefined|String msg (default: '(no message)')
         * @param   undefined|Boolean override (default: false)
         * @return  void
         */
        log: function(msg, override) {
            msg = DataUtils.getDefaultValue(msg, '(no message)');
            override = DataUtils.getDefaultValue(override, false);
            LogUtils.log.object(this, msg, override);
        },

        /**
         * off
         * 
         * Proxy for jQuery off method.
         * 
         * @access  public
         * @return  void
         */
        off: function() {
            $(this).off.apply($(this), $(arguments).toArray());
        },

        /**
         * on
         * 
         * Proxy for jQuery on method.
         * 
         * @access  public
         * @return  void
         */
        on: function() {
            $(this).on.apply($(this), $(arguments).toArray());
        },

        /**
         * once
         * 
         * Proxy for jQuery one method.
         * 
         * @access  public
         * @return  void
         */
        once: function() {
            $(this).one.apply($(this), $(arguments).toArray());
        },

        /**
         * set
         * 
         * @example Accessor.set('key', 'value')
         *          Accessor.set({key: 'value'})
         * @access  public
         * @param   Object|String key
         * @param   undefined|Number|String value
         * @return  void
         */
        set: function() {

            // Object or key/value arguments
            var args = jQuery.makeArray(arguments),
                data = args[0];
            if (typeof data === 'string') {
                data = {};
                data[args[0]] = args[1];
            }

            // Run set the set for all the properties in the object
            this._data = jQuery.extend(true, {}, this._data, data);

            // Events
            var index, value;
            for (index in data) {
                value = data[index];
                this.triggerHandler('set', [index, value]);
                this.triggerHandler('set/' + (index), [value]);
            }
        },

        /**
         * time
         * 
         * Helper method to track the execution duration of code, using the
         * passed in key to differentiate between different timers.
         * 
         * @access  public
         * @param   mixed key
         * @return  void
         */
        time: function(key) {
            var now = new Date().getTime();
            if (this._timers[key] === undefined) {
                this._timers[key] = now;
            } else {
                var msg = 'Timer [' + (key) + '] ' + (now - this._timers[key]);
                this.log(msg);
                delete this._timers[key];
            }
        },

        /**
         * toString
         * 
         * Native method implementation, which at the moment, is used
         * extensively by logging.
         * 
         * @access  public
         * @return  String
         */
        toString: function() {
            return this._string;
        },

        /**
         * triggerHandler
         * 
         * Proxies a call to jQuery's triggerHandler function. triggerHandler is
         * is used in place of trigger, since trigger can conflict with native
         * events. For example, a call to trigger('click') would initiate native
         * event dispatching, along with events that were bound to the click
         * listener on the object.
         * 
         * It's worth noting that even if the object is set up to have it's
         * events logged, it will depend on other factors. See Stencil.log for
         * more information.
         * 
         * @access  public
         * @return  void
         */
        triggerHandler: function() {
            var log = DataUtils.getDefaultValue(this._logEvents, false);
            if (log === true) {
                var eventType = arguments[0];
                this.log(eventType);
            }
            $(this).triggerHandler.apply($(this), $(arguments).toArray());
        },

        /**
         * unbind
         * 
         * Proxy for jQuery unbind method.
         * 
         * @access  public
         * @return  void
         */
        unbind: function() {
            $(this).unbind.apply($(this), $(arguments).toArray());
        }
    });
}));

/**
 * Categories
 * 
 * @abstract
 */
window.Categories = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'categories')
     */
    var __classType = 'categories';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Categories')
     */
    var __string = 'Categories';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * account
         * 
         * @access  public
         * @var     Object
         */
        account: {

            /**
             * get
             * 
             * @access  public
             * @param   Object properties
             * @return  Array
             */
            all: function(properties) {
                properties = properties || {};
                var categories = Stencil.get('account').collection('categories');
                return categories.filter(function(index, category) {
                    var index;
                    for (index in properties) {
                        if (category.get(index) !== properties[index]) {
                            return false;
                        }
                    }
                    return true;
                });
            },

            /**
             * custom
             * 
             * @access  public
             * @param   String type
             * @return  Array
             */
            custom: function(type) {
                var properties = {
                    custom: 1
                };
                properties[type] = 1
                return Categories.account.all(properties);
            },

            /**
             * favorites
             * 
             * @access  public
             * @param   String type
             * @return  false|CategoryAccessor
             */
            favorites: function(type) {
                var properties = {
                    favorites: 1
                };
                properties[type] = 1
                return Categories.account.one(properties);
            },

            /**
             * list
             * 
             * @access  public
             * @param   String type
             * @return  false|CategoryAccessor
             */
            list: function(type) {
                var properties = {
                    all: 1
                };
                properties[type] = 1
                return Categories.account.one(properties);
            },

            /**
             * one
             * 
             * @access  public
             * @param   Object properties
             * @return  false|CategoryAccessor
             */
            one: function(properties) {
                properties = properties || {};
                var categories = Categories.account.all(properties);
                if (categories.length === 0) {
                    return false;
                }
                return categories.shift();
            }
        },

        /**
         * global
         * 
         * @access  public
         * @var     Object
         */
        global: {

            /**
             * get
             * 
             * @access  public
             * @param   Object properties
             * @return  Array
             */
            all: function(properties) {
                properties = properties || {};
                var categories = Stencil.get('globalCategories');
                return categories.filter(function(index, category) {
                    var index;
                    for (index in properties) {
                        if (category.get(index) !== properties[index]) {
                            return false;
                        }
                    }
                    return true;
                });
            },

            /**
             * featured
             * 
             * @access  public
             * @param   String type
             * @return  false|CategoryAccessor
             */
            featured: function(type) {
                var properties = {
                    featured: 1
                };
                properties[type] = 1;
                return Categories.global.one(properties);
            },

            /**
             * one
             * 
             * @access  public
             * @param   Object properties
             * @return  false|CategoryAccessor
             */
            one: function(properties) {
                properties = properties || {};
                var categories = Categories.global.all(properties);
                if (categories.length === 0) {
                    return false;
                }
                return categories.shift();
            },

            /**
             * type
             * 
             * @access  public
             * @param   String type
             * @param   undefined|Boolean featured
             * @return  Array
             */
            type: function(type, featured) {
                var properties = {};
                properties[type] = 1;
                if (featured !== undefined) {
                    properties.featured = +featured;
                }
                return Categories.global.all(properties);
            }
        },

        /**
         * universal
         * 
         * @access  public
         * @var     Object
         */
        universal: {

            /**
             * get
             * 
             * @access  public
             * @param   Object properties
             * @return  Array
             */
            all: function(properties) {
                var global = Categories.global.all(properties),
                    account = Categories.account.all(properties);
                return jQuery.merge(global, account);
            },

            /**
             * one
             * 
             * @access  public
             * @param   Object properties
             * @return  false|CategoryAccessor
             */
            one: function(properties) {
                var all = Categories.universal.all(properties);
                if (all.length === 0) {
                    return false;
                }
                return all.shift();
            }
        }
    });
})();

/**
 * ChangeHistory
 * 
 * @abstract
 */
window.ChangeHistory = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'changeHistory')
     */
    var __classType = 'changeHistory';

    /**
     * Private variables
     * 
     */

    /**
     * __groupableOperationTypes
     * 
     * This contains the array of types whereby a sequence of them would be
     * grouped together. This is important because some things should not be
     * tracked entirely independently of one another. (eg. nudging).
     * 
     * Note that these _are_ in fact tracked independently if they occur spaced
     * apart by a specific number of milliseconds (defined in config.inc.php).
     * 
     * @access  private
     * @var     Array
     */
    var __groupableOperationTypes = [

        // Typing
        'layer // type: text // text:changed',

        // Nudging
        'layer // type: text // nudged',
        'layer // type: image, vector: true // nudged',
        'layer // type: image, background: false // nudged',
        'layer // type: image, watermark: true // nudged',

        // Color changing
        'layer // type: rectangle, background: true // backgroundColor:changed',
        'layer // type: text // backdrop:colorChanged',
        'layer // type: text // strokeColor:changed',
        'layer // type: text // textColorChanged',
        'layer // type: image, vector: true // fillColor:changed'
    ];

    /**
     * __operationType
     * 
     * @access  private
     * @var     false|String
     */
    var __operationType = false;

    /**
     * __paused
     * 
     * Modified via the public ChangeHistory.pause and ChangeHistory.unpause
     * methods, in order to prevent history changes during certain
     * circumstances.
     * 
     * This includes:
     *  - If the canvas is still being drawn (eg. background image being as or
     *    vector being added)
     * 
     * @access  private
     * @var     Boolean (default: false)
     */
    // var __paused = false;

    /**
     * Private methods
     * 
     */

    /**
     * __getChangeHistoryOperationsMap
     * 
     * @access  private
     * @return  Object
     */
    var __getChangeHistoryOperationsMap = function() {
        return Config.get('changeHistoryOperations');
    };

    /**
     * __getMaxOperations
     * 
     * Returns the maximum number of operations that can be tracked in the
     * undo or redo change history arrays. Each can have this number of
     * changes.
     * 
     * @access  private
     * @return  Number
     */
    var __getMaxOperations = function() {
        return Config.default('changeHistory').maxOperations.toInt();
    };

    /**
     * __getMinDelayUntilNewOperationRegistered
     * 
     * @access  private
     * @return  Number
     */
    var __getMinDelayUntilNewOperationRegistered = function() {
        return Config.default('changeHistory').minDelayUntilNewOperationRegistered.toInt();
    };

    /**
     * __getOperationDescription
     * 
     * @access  private
     * @return  String
     */
    var __getOperationDescription = function() {
        var operationType = __getOperationType(),
            map = __getChangeHistoryOperationsMap(),
            operationDescription = map[operationType];
        if (operationDescription === undefined) {
            StencilBooter.log(operationType);
            StencilBooter.log('Unknown operation type');
            return 'Change';
        }
        return operationDescription;
    };

    /**
     * __getOperationType
     * 
     * @access  private
     * @return  String
     */
    var __getOperationType = function() {
        return __operationType;
    };

    /**
     * __replacableOperation
     * 
     * This checks the __groupableOperationTypes array to determine if the
     * operation passed in (which is presumably the one that could be added
     * next), is within that array, and if it is, if it's witin the minimum
     * range to be considered as a replacement operation.
     * 
     * The best example is that when someone is nudging something, we don't want
     * nudges that happen within 1500ms (or whatever) of eachother to count as
     * a new operation. We just want the most recent one to be the last
     * operation.
     * 
     * This is primarily to prevent operations that would be redundant from
     * entering in the history.
     * 
     * Also note that currently this replacing/grouping is limited to changes
     * that originate from keyup events (as opposed to mouseup events).
     * 
     * @access  private
     * @param   Object operation
     * @param   jQuery event
     * @return  Boolean
     */
    var __replacableOperation = function(operation, event) {
        if (event.type !== 'keyup') {
            return false;
        }
        var operationType = operation.type;
        if (ArrayUtils.contains(operationType, __groupableOperationTypes) === false) {
            return false;
        }
        var account = Stencil.account(),
            undoHistory = ChangeHistory.history.undo(),
            lastUndoChange = undoHistory.pop();
        if (lastUndoChange.type !== operationType) {
            return false;
        }
        var range = __getMinDelayUntilNewOperationRegistered(),
            withinRange = DTUtils.timestampWithin(
                lastUndoChange.timestamp.full * 1000,
                operation.timestamp.full * 1000,
                range
            );
        if (withinRange === false) {
            return false;
        }
        return true;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ChangeHistory')
     */
    var __string = 'ChangeHistory';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * active
         * 
         * Simply returns whether or not change history is enabled.
         * 
         * @access  public
         * @return  Boolean
         */
        active: function() {
            return Config.default('changeHistory').active === true;
        },

        /**
         * clearOperationType
         * 
         * In practice, this method is used to ensure that a specific operation
         * is the one that gets registered as a chance. The best example of this
         * is when a user is dragging a layer around, and then presses the
         * delete key.
         * 
         * In that case, we want the change operation that gets registered to be
         * that the layer was deleted, but traditionally, the move would get
         * registered, since it was the operation that the started first and has
         * yet to be completed (and registered). So when a delete is detected,
         * we override the operation type by first calling this method (which
         * clears the operation type), and then setting the operation type.
         * 
         * @access  public
         * @return  void
         */
        clearOperationType: function() {
            __operationType = false;
        },

        /**
         * history
         * 
         * Helper object to return the object of redo/undo change operations, or
         * individual change history arrays (eg. the undo changes or redo
         * changes).
         * 
         * @access  public
         * @var     Object
         */
        history: {

            /**
             * all
             * 
             * @access  public
             * @return  Object
             */
            all: function() {
                var account = Stencil.account(),
                    all = account.setting('changeHistory');
                if (JSONUtils.valid(all) === false) {
                    return {
                        redo: [],
                        undo: []
                    };
                }
                return JSON.parse(all);
            },

            /**
             * redo
             * 
             * @access  public
             * @return  Array
             */
            redo: function() {
                return ChangeHistory.history.all().redo;
            },

            /**
             * undo
             * 
             * @access  public
             * @return  Array
             */
            undo: function() {
                return ChangeHistory.history.all().undo;
            }
        },

        /**
         * initiate
         * 
         * Helper object to initiate a redo or undo operation.
         * 
         * @access  public
         * @var     Object
         */
        initiate: {

            /**
             * redo
             * 
             * @access  public
             * @param   Number stepsForward
             * @return  void
             */
            redo: function(stepsForward) {
                var account = Stencil.account(),
                    allHistory = ChangeHistory.history.all(),
                    redoHistory = allHistory.redo;
                if (redoHistory.length > 0) {

                    // Update the history arrays (by splicing at the right spot)
                    var undoHistory = allHistory.undo,
                        slicedRedoHistory = redoHistory.splice(0, stepsForward);
                    undoHistory = undoHistory.concat(slicedRedoHistory);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': redoHistory,
                            'undo': undoHistory
                        })
                    });

                    // Prepare for change
                    var futureOperation = undoHistory[undoHistory.length - 1],
                        draft = account.draft();

                    // Change
                    draft.once({

                        /**
                         * (anonymous)
                         * 
                         * The way the below <select> method works is it
                         * first deletes all the layers on the canvas. So
                         * once that's done, I set the configuration details
                         * for the image, so that when the actual select
                         * flow begins, the proper configuration details
                         * will have been set.
                         */
                        'delete/all/finish': function(event) {
                            var sourceImageId = futureOperation.configuration.sourceImageId.toInt(),
                                sourceImage = Stencil.getModel('Image').getImageById(sourceImageId);
                            this.set({
                                'frame': futureOperation.configuration.frame,
                                'width': futureOperation.configuration.width.toInt(),
                                'height': futureOperation.configuration.height.toInt(),
                                'sourceImageId': sourceImageId.toInt(),
                                'settings.json': futureOperation.configuration.settings.json,
                                'settings.watermarks': futureOperation.configuration.settings.watermarks
                            });
                            this._setSourceImage(sourceImage);
                        },
                        'set/previewCanvas/finish': function(event) {
                            var content = App.getStage().getContent();
                            content.refreshChangeHistoryElements();
                        }
                    });
                    var locked = draft.isLocked();
                    draft.select('redo', locked, {
                        operationType: undoHistory[(undoHistory.length - 1)].type
                    });
                    draft.getImageDocument().syncLockedState();

                    // Referesh
                    App.getStage().getContent().getChangeHistoryPopover().refresh();
                }
            },

            /**
             * undo
             * 
             * @access  public
             * @param   Number stepsBack
             * @return  void
             */
            undo: function(stepsBack) {
                var account = Stencil.account(),
                    allHistory = ChangeHistory.history.all(),
                    undoHistory = allHistory.undo;
                if (undoHistory.length > 1) {

                    // Update the history arrays (by splicing at the right spot)
                    var redoHistory = allHistory.redo,
                        removedUndoOperations = undoHistory.splice(0 - stepsBack, stepsBack);
                    // removedUndoOperations.reverse();
                    redoHistory = removedUndoOperations.concat(redoHistory);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': redoHistory,
                            'undo': undoHistory
                        })
                    });

                    // Prepare for change
                    var lastOperation = undoHistory[undoHistory.length - 1],
                        draft = account.draft();

                    // Change
                    draft.once({

                        /**
                         * (anonymous)
                         * 
                         * The way the below <select> method works is it
                         * first deletes all the layers on the canvas. So
                         * once that's done, I set the configuration details
                         * for the image, so that when the actual select
                         * flow begins, the proper configuration details
                         * will have been set.
                         */
                        'delete/all/finish': function(event) {
                            var sourceImageId = lastOperation.configuration.sourceImageId.toInt(),
                                sourceImage = Stencil.getModel('Image').getImageById(sourceImageId);
                            this.set({
                                'frame': lastOperation.configuration.frame,
                                'width': lastOperation.configuration.width.toInt(),
                                'height': lastOperation.configuration.height.toInt(),
                                'sourceImageId': sourceImageId.toInt(),
                                'settings.json': lastOperation.configuration.settings.json,
                                'settings.watermarks': lastOperation.configuration.settings.watermarks
                            });
                            this._setSourceImage(sourceImage);
                        },
                        'set/previewCanvas/finish': function(event) {
                            var content = App.getStage().getContent();
                            content.refreshChangeHistoryElements();
                        }
                    });
                    var locked = draft.isLocked();
                    draft.select('undo', false, {
                        operationType: redoHistory[0].type
                    });
                    draft.getImageDocument().syncLockedState();

                    // Referesh
                    App.getStage().getContent().getChangeHistoryPopover().refresh();
                }
            }
        },

        /**
         * keyboardShortcuts
         * 
         * Helper object used to determine if a keyboard combination shortcut
         * was used to initiate a redo or undo operation.
         * 
         * @note    Safari error'd out when checking event.key. For some
         *          reason, not available there.
         * @note    I check for the range input type, since it should be okay to
         *          trigger a redo/undo if the user is focused on a slider.
         * @access  public
         * @var     Object
         */
        keyboardShortcuts: {

            /**
             * redo
             * 
             * @access  public
             * @param   jQuery event
             * @return  Boolean
             */
            redo: function(event) {
                return (
                        (
                            event.metaKey === true
                            && event.shiftKey === true
                            // && event.key.toLowerCase() === 'z'
                            && event.which.toInt() === 90
                            && (
                                $(event.target).tag() !== 'input'
                                || $(event.target).attr('type') === 'range'
                            )
                        )
                        || (
                            event.ctrlKey === true
                            && event.shiftKey === true
                            // && event.key.toLowerCase() === 'z'
                            && event.which.toInt() === 90
                            && (
                                $(event.target).tag() !== 'input'
                                || $(event.target).attr('type') === 'range'
                            )
                        )
                    )
                    || (
                        (
                            event.metaKey === true
                            && event.shiftKey === false
                            // && event.key.toLowerCase() === 'y'
                            && event.which.toInt() === 89
                            && (
                                $(event.target).tag() !== 'input'
                                || $(event.target).attr('type') === 'range'
                            )
                        )
                        || (
                            event.ctrlKey === true
                            && event.shiftKey === false
                            // && event.key.toLowerCase() === 'y'
                            && event.which.toInt() === 89
                            && (
                                $(event.target).tag() !== 'input'
                                || $(event.target).attr('type') === 'range'
                            )
                        )
                    );
            },

            /**
             * undo
             * 
             * @access  public
             * @param   jQuery event
             * @return  Boolean
             */
            undo: function(event) {
                return (event.metaKey === true
                        && event.shiftKey === false
                        // && event.key.toLowerCase() === 'z'
                        && event.which.toInt() === 90
                        && (
                            $(event.target).tag() !== 'input'
                            || $(event.target).attr('type') === 'range'
                        )
                    )
                    || (
                        event.ctrlKey === true
                        && event.shiftKey === false
                        // && event.key.toLowerCase() === 'z'
                        && event.which.toInt() === 90
                        && (
                            $(event.target).tag() !== 'input'
                            || $(event.target).attr('type') === 'range'
                        )
                    );
            }
        },

        /**
         * persistWatermarksForFeaturedTemplates
         * 
         * Proxy for change history setting, which in this case, is used to
         * determine if a watermark should persist on templates the user does
         * not own (in practice this is only applicable to featured templates).
         * 
         * @access  public
         * @return  Boolean
         */
        persistWatermarksForFeaturedTemplates: function() {
            return Config.default('changeHistory').persistWatermarksForFeaturedTemplates === true;
        },

        /**
         * replaceAccountChangeHistory
         * 
         * This method receives raw data from the auth flow, representing the
         * account that is being logged in, and replaces the change history with
         * what's already stored in the ChangeHistory singleton. This is
         * important because without it, the change history for a session would
         * get lost, since the default setting for change history is just the
         * empty redo and undo arrays.
         * 
         * @access  public
         * @param   Object accountData
         * @return  Object
         */
        replaceAccountChangeHistory: function(accountData) {
            var currentChangeHistory = ChangeHistory.history.all(),
                currentChangeHistoryJson = JSON.stringify(currentChangeHistory);
            accountData.settings.changeHistory = currentChangeHistoryJson;
            return accountData;
        },

        /**
         * replaceConsecutiveMirrors
         * 
         * Oh boy this one is fun. So...
         * When a watermark is deleted from an account, it's possible that there
         * are operations in either the redo or undo stack that solely relate to
         * that watermark. For example, when a watermark is moved, nudged,
         * rotated, resized, or a filter is applied to it.
         * 
         * When a watermark is deleted, however, those operations should no
         * longer be available in the change history, since that watermark can't
         * actually be reverted to. So I deal with this by iterating over all
         * the operations and removed any that are "consecutive mirrors" of
         * one another. This is possible because in a previous step (defined in
         * the syncWatermark method), the watermarks array in the configuration
         * object is actually removed. So there wouldn't be anything different
         * in the configuration objects as a whole.
         * 
         * I'm a bit worried that this could result in removing some valid
         * operations, but I _think_ it's okay..
         * 
         * @note    In most places in this class, I operate against the change
         *          history stacks in alphabetical order (namely, redo and then
         *          undo). I need to operate on them here in the undo -> redo
         *          order to prevent issues with splicing.
         * @access  public
         * @return  void
         */
        replaceConsecutiveMirrors: function() {
            var account = Stencil.account(),
                index,
                operations = {},
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo();
            index = undoHistory.length;
            while (index--) {
                if (index === 0) {
                    continue;
                }
                operations.current = undoHistory[index];
                operations.previous = undoHistory[index - 1];
                if (JSON.stringify(operations.current.configuration) === JSON.stringify(operations.previous.configuration)) {
                    undoHistory.splice(index, 1);
                }
            }
            index = redoHistory.length;
            while (index--) {
                if (index === 0) {
                    operations.previous = undoHistory[undoHistory.length - 1];
                } else {
                    operations.previous = redoHistory[index - 1];
                }
                operations.current = redoHistory[index];
                if (JSON.stringify(operations.current.configuration) === JSON.stringify(operations.previous.configuration)) {
                    redoHistory.splice(index, 1);
                }
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * replaceLastUndoOperation
         * 
         * This exists only, at the moment, to support VectorImage drawings.
         * This is because when a VectorImage is drawn via a user action
         * (opposed to from the app initially loading, and having a VectorImage
         * part of the initial image document / json), we check if the ratio of
         * the drawing is less than 1 (meaning it's taller than it is wide).
         * 
         * If it is, we resize the width so that it's proportional to a maximum
         * height of 25% of the canvas. The problem with doing this, is it
         * happens after the ChangeHistory.track call happens (which makes
         * sense, because a vector can take a little while to load).
         * 
         * So if we don't replace the last undo operation, it would result in
         * another undo operation appearing in the history (since the json of
         * the configuration object would in fact be different).
         * 
         * So: we provide this helper method to replace the last undo operation.
         * See the VectorImage.js drawing to see how this is used.
         * 
         * Update: Saturday, February 18th, 2017
         * This method is used in two other places:
         * 1) the syncBackgroundImageSet method
         * 2) The throttling of groupable operation types
         * 
         * @access  public
         * @param   Object operation
         * @return  void
         */
        replaceLastUndoOperation: function(operation) {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                index = undoHistory.length - 1;
            undoHistory[index] = operation;
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': ChangeHistory.history.redo(),
                    'undo': undoHistory
                })
            });
        },

        /**
         * replaceUserChangeHistory
         * 
         * This does the same as replaceAccountChangeHistory, but simply for the
         * active account, and loops over the accounts being passed down, and
         * when matching the account the user is logging into, replaces the
         * change history for it.
         * 
         * @access  public
         * @param   Object userData
         * @return  Object
         */
        replaceUserChangeHistory: function(userData) {
            var currentChangeHistory = ChangeHistory.history.all(),
                currentChangeHistoryJson = JSON.stringify(currentChangeHistory),
                index;
            userData.active.settings.changeHistory = currentChangeHistoryJson;
            for (index in userData.accounts) {
                if (userData.accounts[index].id.toInt() === userData.active.id.toInt()) {
                    userData.accounts[index].settings.changeHistory = currentChangeHistoryJson;
                }
            }
            return userData;
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        // pause: function() {
        //     __paused = true;
        // },

        /**
         * setOperationType
         * 
         * @access  public
         * @param   String type
         * @return  void
         */
        setOperationType: function(type) {
            if (__operationType === false) {
                __operationType = type;
            }
        },

        /**
         * syncBackgroundImageSet
         * 
         * When a background image is set, after it's been loaded, the
         * background is set to white. I believe the logic at the time of
         * implementation was that it should be white, because if the user
         * removes the background image, they would expect to see a white
         * background and not whatever the background rectangle's color was set
         * to last.
         * 
         * The issue with this is that when the user eventually clicks somewhere
         * else on the page, it will trigger a ChangeHistory.track call, which
         * will incorrectly believe the image JSON is different (since the
         * background color may have changed from a color before the background
         * image was set, to white).
         * 
         * So this method's purpose is to grab the last change operation, and
         * overwrite whatever color is there with white, to ensure a
         * false-positive doesn't occur.
         * 
         * @access  public
         * @return  void
         */
        syncBackgroundImageSet: function() {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                lastUndoOperation = undoHistory[undoHistory.length - 1],
                index,
                layer,
                white = ColorUtils.getWhite('rgba'),
                backgroundColor,
                json = lastUndoOperation.configuration.settings.json,
                jsonObject = JSON.parse(json);
            for (index in jsonObject.layers) {
                layer = jsonObject.layers[index];
                if (layer.type === 'rectangle' && layer.background === true) {
                    backgroundColor = ColorUtils.addSpaces(
                        layer.styles.backgroundColor
                    );
                    if (backgroundColor !== white) {
                        layer.styles.backgroundColor = white;
                        json = JSON.stringify(jsonObject);
                        lastUndoOperation.configuration.settings.json = json;
                        ChangeHistory.replaceLastUndoOperation(
                            lastUndoOperation
                        );
                        break;
                    }
                }
            }
        },

        /**
         * syncDeletedFont
         * 
         * This method is responsible for swapping out any fonts that have been
         * deleted, and replacing them with the defaultFontFamily for the
         * account (which is stored in the AccountAccessor's settings, since we
         * wanted it to be flexible enough for account's to be able to define
         * their own default font).
         * 
         * This is again importantt, since once a font is deleted, it can't be
         * gracefully restored to the app's flow. So we want to ensure
         * operations aren't referencing fonts that can't be properly used
         * through previous or future operations.
         * 
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        syncDeletedFont: function(font) {
            var key = font.get('key'),
                account = Stencil.account(),
                appDefaultFontFamily = account.getDefaultFontFamily(),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json,
                regExp = new RegExp(key, 'g');
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace(regExp, appDefaultFontFamily);
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace(regExp, appDefaultFontFamily);
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncLockedOperations
         * 
         * When a user logs into an upgraded account, or upgrades their account,
         * it's possible that previously they had some change operations that
         * included a locked asset. This helper method is designed to go through
         * all previously and future-oriented change operations and remove any
         * locked-state's for layers.
         * 
         * @access  public
         * @return  void
         */
        syncLockedOperations: function() {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json;
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace('"locked":true', '"locked":false');
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace('"locked":true', '"locked":false');
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncResourceKeyInOperations
         * 
         * This method is responsible for looping over all operations in the
         * change history, and replacing any keys matching previousKey with
         * newKey. This is important because when a 3rd-party resource is
         * initially used, the resource is loaded directly, before a /save
         * call is made. Once that call comes back, it changes the
         * image-property for the JSON of the draft to that new key.
         * 
         * After this happens, if the user initiates a ChangeHistory.track call
         * (via the mouseup or keyup events), the app will think something is
         * different (even though that's not the case).
         * 
         * @access  public
         * @param   String previousKey
         * @param   String newKey
         * @return  void
         */
        syncResourceKeyInOperations: function(previousKey, newKey) {
            var account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo(),
                redoHistory = ChangeHistory.history.redo(),
                index,
                json,
                regExp = new RegExp(previousKey, 'g');
            for (index in undoHistory) {
                json = undoHistory[index].configuration.settings.json;
                json = json.replace(regExp, newKey);
                undoHistory[index].configuration.settings.json = json;
            }
            for (index in redoHistory) {
                json = redoHistory[index].configuration.settings.json;
                json = json.replace(regExp, newKey);
                redoHistory[index].configuration.settings.json = json;
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncSourceImageId
         * 
         * This method is responsible for swapping out the sourceImageId value
         * for operations. The reason this is required is because when a save
         * happens, previous operations (before the save action) have a
         * sourceImageId that corresponds to the draft at that time. But when a
         * save happens, the draft imageId changes, and so the previous
         * operations would be seen to be different, and would result in
         * improper Footer button UI states.
         * 
         * So, this method should only really be called when a save action
         * happens, since at the moment, that's the only time the account's
         * draft image can have it's imageId changed.
         * 
         * @access  public
         * @param   Number previousSourceImageId
         * @param   Number newSourceImageId
         * @return  void
         */
        syncSourceImageId: function(previousSourceImageId, newSourceImageId) {
            var account = Stencil.account(),
                index,
                operation,
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo();
            for (index in redoHistory) {
                operation = redoHistory[index];
                if (operation.configuration.sourceImageId.toInt() === previousSourceImageId.toInt()) {
                    operation.configuration.sourceImageId = newSourceImageId.toInt();
                }
            }
            for (index in undoHistory) {
                operation = undoHistory[index];
                if (operation.configuration.sourceImageId.toInt() === previousSourceImageId.toInt()) {
                    operation.configuration.sourceImageId = newSourceImageId.toInt();
                }
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });
        },

        /**
         * syncWatermark
         * 
         * This method is responsible for removing any watermark layers from
         * change operations that match the passed in uploadKey argument. This
         * needs to exist because it's possible for a user to delete a watermark
         * that exists in the change history stacks. If this isn't taken into
         * consideration, iterating through the change history can cause a bug.
         * 
         * This method does not yet splice out the watermark operations for the
         * deleted watermark. Ideally, it would.
         * 
         * @access  public
         * @param   String uploadKey
         * @return  void
         */
        syncWatermark: function(uploadKey) {
            var account = Stencil.account(),
                index,
                index2,
                operation,
                redoHistory = ChangeHistory.history.redo(),
                undoHistory = ChangeHistory.history.undo(),
                watermark,
                watermarks;
            for (index in redoHistory) {
                operation = redoHistory[index];
                watermarks = JSON.parse(operation.configuration.settings.watermarks);
                for (index2 in watermarks.layers) {
                    watermark = watermarks.layers[index2];
                    if (watermark.image === uploadKey) {
                        watermarks.layers.splice(index2, 1);
                    }
                }
                redoHistory[index].configuration.settings.watermarks = JSON.stringify(watermarks);
            }
            for (index in undoHistory) {
                operation = undoHistory[index];
                watermarks = JSON.parse(operation.configuration.settings.watermarks);
                for (index2 in watermarks.layers) {
                    watermark = watermarks.layers[index2];
                    if (watermark.image === uploadKey) {
                        watermarks.layers.splice(index2, 1);
                    }
                }
                undoHistory[index].configuration.settings.watermarks = JSON.stringify(watermarks);
            }
            account.set({
                'settings.changeHistory': JSON.stringify({
                    'redo': redoHistory,
                    'undo': undoHistory
                })
            });

            // 
            ChangeHistory.replaceConsecutiveMirrors();
        },

        /**
         * track
         * 
         * This is the heavy-lifter. It tracks a change operation in the undo
         * history, and when an und operation happens, ensures the redo array
         * receives the previously undone operation.
         * 
         * @note    The redo and undo property checks are meant to determine
         *          if the source of a trackChangeHistory call is from undoing
         *          or redoing a previous change. We do not want to track those,
         *          since they're not actually changes the user is performing,
         *          but rather changes they're reverting, or reverting back to.
         * @access  public
         * @param   Boolean clearRedoHistory
         * @param   false|jQuery event The event (if any) that triggered the
         *          track call, currently being used for grouping related
         *          operations
         * @return  void
         */
        track: function(clearRedoHistory, event) {
// console.log('track called');
            var draft = Stencil.account().draft(),
                currentConfiguration = draft.getConfiguration(),
                account = Stencil.account(),
                undoHistory = ChangeHistory.history.undo();

            // This should only happen when the app is initially loaded
            if (undoHistory.length === 0) {
                var currentUnixTimestamp = new Date().getTime() / 1000,
                    operation = {
                        configuration: currentConfiguration,
                        description: __getOperationDescription(),
                        timestamp: {
                            full: currentUnixTimestamp,
                            simple: Math.floor(currentUnixTimestamp)
                        },
                        type: __getOperationType()
                    };
                undoHistory.push(operation);
                account.set({
                    'settings.changeHistory': JSON.stringify({
                        'redo': ChangeHistory.history.redo(),
                        'undo': undoHistory
                    })
                });
                __operationType = false;
            } else {
                var lastUndoChange = undoHistory[undoHistory.length - 1],
                    currentConfigurationString = JSON.stringify(currentConfiguration),
                    lastUndoChangeString = JSON.stringify(lastUndoChange.configuration);
                currentConfigurationString = ColorUtils.addSpaces(currentConfigurationString);
                lastUndoChangeString = ColorUtils.addSpaces(lastUndoChangeString);
                if (currentConfigurationString !== lastUndoChangeString) {

                    // Operation
                    var currentUnixTimestamp = new Date().getTime() / 1000,
                        operation = {
                            configuration: currentConfiguration,
                            description: __getOperationDescription(),
                            timestamp: {
                                full: currentUnixTimestamp,
                                simple: Math.floor(currentUnixTimestamp)
                            },
                            type: __getOperationType()
                        };

                    // If the operation should replace the last one
                    if (__replacableOperation(operation, event) === true) {
                        ChangeHistory.replaceLastUndoOperation(operation);
                        undoHistory = ChangeHistory.history.undo();
                    } else {
                        undoHistory.push(operation);
                    }

                    // 
                    var maxOperations = __getMaxOperations();
                    __operationType = false;
                    undoHistory = undoHistory.slice(0 - maxOperations - 1);
                    account.set({
                        'settings.changeHistory': JSON.stringify({
                            'redo': ChangeHistory.history.redo(),
                            'undo': undoHistory
                        })
                    });

                    /**
                     * Clear redo history
                     * 
                     * This logic ensures the redo history is entirely cleared. This
                     * happens when a user actively makes any change to the image,
                     * since any previous changes in the redo history stack are no
                     * longer relevant.
                     * 
                     * It's also being triggered when the app initially loads, since
                     * the redo stack should be empty at that time anyway.
                     */
                    if (clearRedoHistory === true) {
                        account.set({
                            'settings.changeHistory': JSON.stringify({
                                'redo': [],
                                'undo': ChangeHistory.history.undo()
                            })
                        });
                    }
                } else {
                    __operationType = false;
                }
            }

            // Refresh shit
            App.getStage().getContent().refreshChangeHistoryElements();
            App.getStage().getContent().getChangeHistoryPopover().refresh();
        }

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        // unpause: function() {
        //     __paused = false;
        // }
    });
})();

/**
 * Config
 * 
 * @abstract
 */
window.Config = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'config')
     */
    var __classType = 'config';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Config')
     */
    var __string = 'Config';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * default
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        default: function(key) {
            var defaults = Config.get('defaults');
            if (defaults[key] === undefined) {
                throw new Error('Invalid default config lookup: ' + (key));
            }
            return defaults[key];
        },

        /**
         * get
         * 
         * @access  public
         * @param   undefined|String key (optional)
         * @return  mixed
         */
        get: function(key) {
            var config = Stencil.get('config');
            if (key === undefined) {
                return config;
            }
            return config[key];
        },

        /**
         * getRole
         * 
         * @access  public
         * @return  String
         */
        getRole: function() {
            return Config.get('role');
        },

        /**
         * ready
         * 
         * Helper method used to determine whether the app config is available
         * for use. At the time of documentation, this was only being used by
         * the LogUtils class to determine whether messages should be logged to
         * the console. Since that logic checks the app config, we had to check
         * whether the config was available to _be_ checked.
         * 
         * @access  public
         * @return  Boolean
         */
        ready: function() {
            var config = Stencil.get('config'),
                ready = config !== undefined;
            return ready;
        }
    });
})();

/**
 * Frames
 * 
 * @abstract
 */
window.Frames = (function() {

    /**
     * __all
     * 
     * @access  private
     * @var     Array
     */
    var __all;

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'frames')
     */
    var __classType = 'frames';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Frames')
     */
    var __string = 'Frames';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * all
         * 
         * @access  public
         * @return  Array
         */
        all: function() {
            return __all;
        },

        /**
         * store
         * 
         * @access  public
         * @param   Array all
         * @return  void
         */
        store: function(all) {
            __all = all;
        }
    });
})();

/**
 * HelpScout
 * 
 * @abstract
 */
window.HelpScout = (function() {

    /**
     * __active
     * 
     * @access  private
     * @return  Boolean
     */
    var __active = function() {
        return Services.check('helpScout');
    };

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'helpScout')
     */
    var __classType = 'helpScout';

    /**
     * __load
     * 
     * @access  private
     * @param   String id
     * @return  void
     */
    var __load = function(id) {
        !function(e,o,n){
            window.HSCW = o,
            window.HS = n,
            n.beacon = n.beacon || {};
            var t = n.beacon;
            t.userConfig = {},
            t.readyQueue = [],
            t.config = function(e) {
                this.userConfig = e;
            },
            t.ready = function(e) {
                this.readyQueue.push(e);
            },
            o.config = {
                docs: {
                    enabled: !0,
                    baseUrl: '//stencil.helpscoutdocs.com/'
                },
                contact: {
                    enabled: !0,
                    formId: id
                }
            };
            var r = e.getElementsByTagName('script')[0],
                c = e.createElement('script');
                c.type = 'text/javascript',
                c.async = !0,
                c.src = 'https://djtflbt20bdde.cloudfront.net/',
                r.parentNode.insertBefore(c,r);
        }(document, window.HSCW || {}, window.HS || {});
    };

    /**
     * __setupBeacon
     * 
     * @access  private
     * @return  void
     */
    var __setupBeacon = function() {
        if ('HS.beacon.config'.validMethod() === true) {
            HS.beacon.config({
                //modal: true,
                poweredBy: false,
                showName: true,
                icon: 'buoy',
                position: 'left',
                translation: {
                    nameLabel: 'Your full name',
                    contactSuccessDescription: 'Thanks for getting in touch! ' +
                        'We\'ll try to get back to you within 24 business ' +
                        'hours (Monday-Friday 9am-6pm EST).'
                },
                // color: '#25a0e9',
                color: '#35ACE0',
                topArticles: true,
                topics: [
                    { val: 'need-help', label: 'Need help with Stencil' },
                    { val: 'download-bug', label: 'My images aren\'t downloading'},
                    { val: 'bug', label: 'I think I found a bug!'},
                    { val: 'cancel', label: 'I\'d like to cancel my account'},
                    { val: 'saying-hi', label: 'Just saying hi!'},
                    { val: 'other', label: 'Other'}
                ],
                // zIndex: 96,
                zIndex: 101,
                // zIndex: 98,
                attachment: true,
                instructions: 'Fill out this form and we\'ll get right back to you!'
            });
        }
    };

    /**
     * __setupFade
     * 
     * @access  private
     * @return  void
     */
    var __setupFade = function() {
        if ('HS.beacon.ready'.validMethod() === true) {
            HS.beacon.ready(function() {
                setTimeout(function() {
                    $('#hs-beacon').addClass('visible');
                }, 1000);
            });
        }
    };

    /**
     * __setupIdentify
     * 
     * @access  private
     * @return  void
     */
    var __setupIdentify = function() {
        var user = Stencil.get('user');
        if (user !== false) {
            var name = user.get('name'),
                accountEmail = user.get('email'),
                signupDateTimestamp = user.get('created').toInt(),
                signupDateLabel = moment(signupDateTimestamp * 1000).calendar(),
                plan = user.getPlan(),
                partner = user.getPartner(),
                interval = user.getInterval(),
                monthlySavedImages = user.active().get('monthlySavedImages'),
                totalSavedImages = user.active().get('totalSavedImages');
            if ('HS.beacon.ready'.validMethod() === true) {
                HS.beacon.ready(function() {
                    if ('HS.beacon.identify'.validMethod() === true) {
                        HS.beacon.identify({
                            'Name': name,
                            'Account email': accountEmail,
                            'Signup date': signupDateLabel,
                            'Plan': plan,
                            'Submitted from': 'App' + (UserAgent.extension() === true ? ' (extension)' : ''),
                            'Partner': partner,
                            'Interval': interval,
                            'Monthly saved images': monthlySavedImages,
                            'Total saved images': totalSavedImages
                        });
                    }
                });
            }
        }
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'HelpScout')
     */
    var __string = 'HelpScout';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * init
         * 
         * @access  public
         * @param   String id
         * @return  void
         */
        init: function(id) {
            if (__active() === true) {
                __load(id);
                __setupBeacon();
                __setupFade();
                __setupIdentify();
            }
        },

        /**
         * close
         * 
         * @access  public
         * @return  void
         */
        close: function() {

            /**
             * closable
             * 
             * @access  private
             * @return  Boolean
             */
            var closable = function() {
                if (__active() === false) {
                    return false;
                }
                if ('HS.beacon.close'.validMethod() === false) {
                    return false;
                }
                return true;
            };
            if (closable() === true) {
                if ('HS.beacon.close'.validMethod() === true) {
                    HS.beacon.close();
                }
            }
        }
    });
})();

/**
 * ImagePreloadWorker
 * 
 * @see     https://gist.github.com/mseeley/9321422
 * @abstract
 */
window.ImagePreloadWorker = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'imagePreloadWorker')
     */
    var __classType = 'imagePreloadWorker';

    /**
     * __getPreloadWorkerStr
     * 
     * @access  private
     * @return  void
     */
    var __getPreloadWorkerStr = function() {
        var fn = __preloadWorker.toString(),
            body = fn.slice(
                fn.indexOf('{') + 1,
                fn.lastIndexOf('}')
            );
        return 'self.onmessage = ' + (fn) + ';';
    };

    /**
     * __getWorker
     * 
     * @access  private
     * @param   Array urls
     * @return  Worker
     */
    var __getWorker = function(urls) {
        var url = __getWorkerUrl(),
            worker = new Worker(url);

        /**
         * worker.onmessage
         * 
         * @access  private
         * @param   MessageEvent event
         * @return  void
         */
        worker.onmessage = function(event) {
            var remaining = urls.length,
                onload = function() {
                    delete this.onload;
                    remaining--;
                    if (remaining === 0) {
                        console.log('done')
                    }
                };
            urls.forEach(function(url) {
                var el = document.createElement('img');
                el.onload = onload;
                el.src = url;
            });
            URL.revokeObjectURL(url);
        };
        return worker;
    };

    /**
     * __getWorkerUrl
     * 
     * @access  private
     * @return  String
     */
    var __getWorkerUrl = function() {
        var preloadWorkerStr = __getPreloadWorkerStr(),
            URL = window.URL || window.webkitURL,
            url = URL.createObjectURL(
                new Blob(
                    [preloadWorkerStr],
                    {
                        type: 'text/javascript'
                    }
                )
            );
        return url;
    };

    /**
     * __preloadWorker
     * 
     * @access  private
     * @param   MessageEvent event
     * @return  void
     */
    var __preloadWorker = function(event) {
        var urls = event.data,
            remaining = urls.length,
            onload = function(event) {
                remaining--;
                if (remaining === 0) {
                    self.postMessage(true);
                    self.close();
                }
            };
        urls.forEach(function(url) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'blob';
            xhr.onload = xhr.onerror = onload;
            xhr.open('GET', url, true);
            xhr.send();
        });
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'ImagePreloadWorker')
     */
    var __string = 'ImagePreloadWorker';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * preload
         * 
         * @access  public
         * @param   Array urls
         * @return  void
         */
        preload: function(urls) {
            var worker = __getWorker(urls);
            worker.postMessage(urls);
        }
    });
})();

/**
 * Images
 * 
 * @see     https://github.com/thumbor/thumbor/wiki/Configuration
 * @see     https://aws.amazon.com/answers/web-applications/serverless-image-handler/
 * @see     https://docs.aws.amazon.com/solutions/latest/serverless-image-handler/welcome.html
 * @abstract
 */
window.Images = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'images')
     */
    var __classType = 'images';

    /**
     * __getThumborMaxImagePixels
     * 
     * @access  private
     * @return  Number
     */
    var __getThumborMaxImagePixels = function() {
        var thumborMaxImagePixels = Config.default('thumborMaxImagePixels').toInt();
        return thumborMaxImagePixels;
    };

    /**
     * __preloadedImages
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __preloadedImages = {};

    /**
     * __qualityValue
     * 
     * @access  private
     * @var     Number (default: 80)
     */
    var __qualityValue = 80;

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Images')
     */
    var __string = 'Images';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * cloudFront
         * 
         * @access  public
         * @param   String key
         * @return  String
         */
        cloudFront: function(key) {
            var host = Config.get('aws').cloudFront.distributions.s3.app.stencil.host;
            return 'https://' + (host) + '/' + (key);
        },

        /**
         * cloudinary
         * 
         * @note    Width set to 304 (double 152) for retina screens, and since
         *          biggest DOM container for images is 152px wide. Same goes for
         *          212 (106*2).
         * @access  public
         * @param   String key
         * @param   Object options
         * @return  String|false
         */
        cloudinary: function(key, options) {

            /**
             * Overhead that sets the Cloudinary bucket-name, and currently,
             * routes requests through CloudFront before Cloudinary (to save on
             * bandwidth costs).
             */
            var config = Config.get(),
                name = config.cloudinary.name,
                proxy = config.cloudinary.proxies[options.proxy || 'stencil'],
                hosts = {
                    cloudFront: config.aws.cloudFront.distributions.cloudinary.host,
                    cloudinary: 'res.cloudinary.com'
                },
                base = 'https://' + (hosts.cloudFront) + '/' + (name) +
                    '/image/upload/',
                post = (proxy) + '/' + (key);

            // For product legacy testing
            post = post.replace(/sai\.images\.local/, 'sai.images');
            post = post.replace(/sai\.images\.dev/, 'sai.images');

            /**
             * Simply proxies the image through Cloudinary. Currently only being
             * used by vectors (since Cloudinary does not process vectors well),
             * and for legacy image uploads, when clicked, to determine their
             * width/height and save it to the db.
             */
            if (options.type === 'original') {
                return Images.cloudFront(key);
                // return (base) + (post);
            }
            /**
             * 
             */
            if (options.type === 'thumb') {

                /**
                 * I load a thumb half the size as below when the device pixel
                 * ratio is 1, since the retina version naturally isn't needed.
                 * This should speed the app up quite a bit (since less memory
                 * required for storing thumbs), but could result in an increase
                 * in transformations on Cloudinary.
                 */
                if (window.devicePixelRatio === 1) {
                    return Images.cloudinary(key, {
                        proxy: options.proxy || 'stencil',
                        type: 'minimum',
                        ratio: '1.0',
                        width: 152,
                        height: 106
                    });
                }
                return Images.cloudinary(key, {
                    proxy: options.proxy || 'stencil',
                    type: 'minimum',
                    ratio: '1.0',
                    width: 304,
                    height: 212
                });
                // return (base) + 'c_fill,h_212,w_304/' + (post);
                // return (base) + 'w_304/' + (post);
            }
            /**
             * Uses Cloudinary's new conditioning to return an image of minimum
             * width or height depending on the aspect ratio of the original
             * image, compared to the option which is passed in. Used very
             * conveniently to compare against the selected Frame's aspect
             * ratio.
             */
            if (options.type === 'minimum') {
                var conditions = 'if_' +
                    'ar_gt_' + (options.ratio || '1.0') + ',' +
                    'h_' + (options.height) + ',' +
                    'c_scale' +
                    '/if_else,' +
                    'w_' + (options.width) + ',' +
                    'c_scale/';
                // conditions += 'pg_1/';
                return (base) + (conditions) + (post);
            }
            /**
             * Scales the image to a specific width or height, depending on
             * which dimension type is passed in. Both can't be passed in.
             */
            if (options.type === 'scale') {
                if (options.width !== undefined) {
                    return (base) + 'w_' + (options.width) + '/' + (post);
                    // return (base) + 'w_' + (options.width) + '/pg_1/' + (post);
                }
                if (options.height !== undefined) {
                    return (base) + 'h_' + (options.height) + '/' + (post);
                    // return (base) + 'h_' + (options.height) + '/pg_1/' + (post);
                }
                return false;
            }
            return false;
        },

// https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/if_ar_gt_1.0,h_146,c_scale/if_else,w_100,c_scale/s3.local/asst2acf2efd

        // /**
        //  * loadData
        //  * 
        //  * @access  public
        //  * @param   String url
        //  * @param   Function callback
        //  * @return  void
        //  */
        // loadData: function(url, callback) {
        //     fabric.Image.fromURL(
        //         url,
        //         function(object) {
        //             Canvases.Proxy.getCotton().resizeTo(100, 100);
        //             Canvases.Proxy.getCotton().add(object);
        //             var content = Canvases.Proxy.getCotton().toDataURL({
        //                 format: 'jpeg',
        //                 quality: 1,
        //                 multiplier: 1
        //             });
        //             callback(content);
        //         },
        //         {
        //             crossOrigin: 'anonymous'
        //         }
        //     );
        // },

        /**
         * getFrameUrl
         * 
         * This function is currently only used in media-accessor preloading (
         * which at the moment is limited further to UploadAccessor preloading),
         * and in BackgroundBitmapDrawing url preloading. The logic is as
         * follows:
         * 
         * I first check if an accessor is defined. If it is, then I check to
         * see whether a width/height are defined. If that's the case, I can
         * safely determine it's ratio, and compare it with that of the Frame.
         * At that point, I return the appropriate image url for the Frame to
         * prevent multiple image url loading. "Appropriate" in this context
         * refers to the image url that that ensures it can be slid along the
         * appropriate axis, depending on whether it's taller than the Frame, or
         * wider that the Frame (but not both).
         * 
         * When an accessor could not be found (eg. an older upload that is not
         * available memory), or else the width/height aren't defined (eg.
         * legacy uploads, or the image hasn't yet has it's dimensions
         * "synced"), I simply return the best guess: that the image is going to
         * be slideable along it's horizontal / x axis, rather than vertically.
         * If this is not the case, it's not a big deal: it'll be determined
         * elsewhere.
         * 
         * @todo    Look into the case where the accessor is not found, or else
         *          the width/height isn't defined. In that case, might it be
         *          possible to check the thumb that's already loaded in the
         *          browser (if any), to determine the ratio? Might save an
         *          additional HTTP request.
         * @access  public
         * @param   String key
         * @return  String
         */
        // getFrameUrl: function(key) {
        //     var accessor = Stencil.getAccessor(key),
        //         dimensions = Canvases.Preview.getRenderedDimensions();
        //     if (accessor !== false) {
        //         if (
        //             accessor.get('width').toInt() !== 0
        //             && accessor.get('height').toInt() !== 0
        //         ) {
        //             var ratio = accessor.getRatio();
        //             if (ratio > Frame.getRatio()) {
        //                 return Images.cloudinary(key, {
        //                     type: 'scale',
        //                     height: dimensions.height.ceil()
        //                 });
        //             } else if (ratio === Frame.getRatio()) {
        //                 return Images.cloudinary(key, {
        //                     type: 'scale',
        //                     height: dimensions.height.ceil()
        //                 });
        //             }
        //             return Images.cloudinary(key, {
        //                 type: 'scale',
        //                 width: dimensions.width.ceil()
        //             });
        //         }
        //     }
        //     return Images.cloudinary(key, {
        //         type: 'scale',
        //         height: dimensions.height.ceil()
        //     });
        // },

        /**
         * getFrameUrl
         * 
         * Returns an image (referenced by passed in parameter) that perfectly
         * fits the canvas by using Cloudinary's new API feature to dynamically
         * resize image to a minimum width or height depending on the aspect
         * ratio of the original image compared to the aspect ratio of the
         * selected Frame).
         * 
         * If you need to revert, see the following commit:
         * dacd90d55129ea8017bfe76abb58fbb6631ebc31
         * 
         * @access  public
         * @param   String key
         * @param   CanvasView canvas
         * @return  String
         */
        getFrameUrl: function(key, canvas) {
            var ratio = window.devicePixelRatio || 1,
                dimensions = canvas.getRenderedDimensions(),
                width = dimensions.width.ceil(),
                height = dimensions.height.ceil();
            width *= ratio;
            height *= ratio;
            return Images.thumb(key, {
                type: 'minimum',
                ratio: Frame.getRatio().round(1),
                width: width.round(0),
                height: height.round(0)
            });
        },

        /**
         * getPreloaded
         * 
         * @access  public
         * @param   String url
         * @return  Image
         */
        getPreloaded: function(url) {
            var image = __preloadedImages[url];
            return image;
        },

        /**
         * getRandomSadFaceFontClass
         * 
         * @access  public
         * @return  String
         */
        getRandomSadFaceFontClass: function() {
            var classes = [
                'sif-emoji-sad',
                'sif-emoji-sad-2',
                'sif-emoji-sad-3',
                'sif-emoji-sad-4',
                'sif-emoji-sad-5',
                'sif-emoji-sad-6'
            ];
            return classes[
                Math.floor(Math.random() * classes.length)
            ];
        },

        /**
         * preload
         * 
         * @access  public
         * @param   Array urls
         * @param   Function success
         * @param   Function error
         * @param   undefined|Array references
         * @return  void
         */
        preload: function(urls, success, error, references) {
            if (urls.length === 0) {
                success && success(references);
            } else {
                var url = urls.shift();
                references = references || [];
                if (this.preloaded(url) === true) {
                    var img = __preloadedImages[url];
                    references.push(img)
                    Images.preload(urls, success, error, references);
                } else {
                    var img = new Image();
                    references.push(img);
                    img.onload = function() {
                        __preloadedImages[url] = img;
                        Images.preload(urls, success, error, references);
                    };
                    img.onerror = function() {
                        error && error();
                    };
                    img.src = url;
                }
            }
        },

        /**
         * preloaded
         * 
         * @access  public
         * @param   String url
         * @return  Boolean
         */
        preloaded: function(url) {
            var preloaded = __preloadedImages[url] !== undefined;
            return preloaded;
        },

        /**
         * s3
         * 
         * Returns the path to original S3 media file.
         * 
         * @access  public
         * @param   String objectKey
         * @return  String
         */
        s3: function(objectKey) {
            var aws = Config.get('aws'),
                bucket = aws.s3.buckets.app.stencil,
                bucketRegion = bucket.region,
                bucketName = bucket.name,
                url = 'https://s3-' + (bucketRegion) + '.amazonaws.com';
            return (url) + '/' + (bucketName) + '/' + (objectKey);
        },

        /**
         * thumb
         * 
         * @note    thumborSafeMode is a config variable to ensure that requests
         *          are only routed through the Thumbor service when specific
         *          criteria are met (eg. jpeg, not too big, etc).
         * @access  public
         * @param   String key
         * @param   Object options
         * @return  String|false
         */
        thumb: function(key, options) {

            /**
             * Cloudinary
             * 
             */
            var thumbService = Config.default('thumbService');
            if (thumbService === 'cloudinary') {
                return Images.cloudinary(key, options);
            }

            /**
             * Thumbor
             * 
             */
            var thumborSafeMode = Config.default('thumborSafeMode');
            if (thumborSafeMode === false) {
                return Images.thumbor(key, options);
            }

            /**
             * Cloudinary fallback (can't access properties)
             * 
             */
            var obj = Stencil.getAccessor(key);
            if (obj === false) {
                return Images.cloudinary(key, options);
            }

            /**
             * Thumbor Safe Mode
             * 
             */

            // Try and determine resolution
            var resolution = false,
                width = obj.get('width'),
                height = obj.get('height');
            if (
                width !== undefined
                && width.toInt() !== 0
                && height !== undefined
                && height.toInt() !== 0
            ) {
                resolution = width * height;
            }

            // Only use Thumbor if it's a jpeg (png/gifs are a bit bunk atm)
            if (obj.get('mime') === 'image/jpeg') {
                var thumborMaxImagePixels = __getThumborMaxImagePixels();
                if (options.type === 'thumb') {
                    if (resolution === false) {
                        return Images.cloudinary(key, options);
                    }
                    if (resolution < thumborMaxImagePixels) {
                        return Images.thumbor(key, options);
                    }
                    return Images.cloudinary(key, options);
                }
                if (key.match(/^img0/) !== null) {
                    if (options.type !== 'original') {
                        if (resolution === false) {
                            return Images.cloudinary(key, options);
                        }
                        if (resolution < thumborMaxImagePixels) {
                            return Images.thumbor(key, options);
                        }
                        return Images.cloudinary(key, options);
                    }
                }
            }

            /**
             * Cloudinary fallback
             * 
             */
            return Images.cloudinary(key, options);
        },

        /**
         * thumbor
         * 
         * @note    Width set to 304 (double 152) for retina screens, and since
         *          biggest DOM container for images is 152px wide. Same goes for
         *          212 (106*2).
         * @note    Two things changed in Thumbor package:
         *          1) PIL/Image.py modifications for PNG transparency bug when
         *             resizing: https://i.imgur.com/kUKgAU6.png
         *          2) image_handler/lambda_function.py modifications for access
         *             control: https://i.imgur.com/ngT1IdC.png
         * @see     http://plouc.github.io/thumbor-toy/
         * @see     http://thumbor.readthedocs.io/en/latest/usage.html#image-endpoint
         * @see     https://github.com/thumbor/thumbor/wiki/Usage
         * @see     https://github.com/thumbor/thumbor/wiki/Quality
         * @see     https://github.com/python-pillow/Pillow/commit/2ad43c4eeb8cb0124c76cbdd0fe0b131df2c6c70
         * @see     https://github.com/wiredfool/Pillow/commit/e422f92e523f4d0d66611b2f9f54f6606a218d4b (duplicate)
         * @see     https://github.com/thumbor/thumbor/issues/943
         * @see     https://github.com/thumbor/thumbor/issues/943
         * @see     https://d32q3izcmhqbti.cloudfront.net/full-fit-in/972x486/filters:quality(100)/asst3084e0f3
         * @access  public
         * @param   String key
         * @param   Object options
         * @return  String|false
         */
        thumbor: function(key, options) {
            var aws = Config.get('aws'),
                thumborCloudFrontDistributions = aws.cloudFront.distributions.thumbor,
                proxy = (options.proxy === undefined ? 'stencil' : (options.proxy === 'stencil' ? 'stencil' : options.proxy)),
                pieces = [
                    'https://' + thumborCloudFrontDistributions[proxy].host
                ];

            /**
             * Currently, this is only relevant when thumbor is being used for
             * all requests. This is because the only time a proxy is set to
             * this value is when it's a legacy image that hasn't yet been
             * imported. But in that case, the key value passed to Images.thumb
             * is changed. As a result, thumbor wouldn't be called (see
             * Images.thumb for the reason why; specifically, the check against
             * the accessor using the key passed in).
             * 
             * So, the only time this code could be triggered is when Thumbor is
             * being used for all requests, since at that point, the check for
             * an accessor is not performed.
             */
            if (proxy === 'shareAsImage') {
                pieces = [
                    'https://' + (Config.get('aws').legacy.cloudFront.distributions.thumbor.shareAsImage.prod.host)
                ];
            }

            /**
             * Simply proxies the image through Thumbor. Currently being used by
             * vectors, when passing to Buffer, and by legacy image uploads.
             */
            if (options.type === 'original') {
                return Images.cloudFront(key);
                // pieces.push('filters:quality(100)');
                // pieces.push(key);
                // return pieces.join('/');
            }

            /**
             * I load a thumb half the size as below when the device pixel
             * ratio is 1, since the retina version naturally isn't needed.
             * This should speed the app up quite a bit (since less memory
             * required for storing thumbs).
             */
            if (options.type === 'thumb') {
                pieces.push('full-fit-in');
                if (window.devicePixelRatio === 1) {
                    pieces.push('152x106');
                } else {
                    pieces.push('304x212');
                }
                pieces.push('filters:quality(' + (__qualityValue) + ')');
                pieces.push(key);
                return pieces.join('/');
            }

            /**
             * Used very conveniently to compare against the selected Frame's
             * aspect ratio.
             */
            if (options.type === 'minimum') {
                pieces.push('full-fit-in');
                pieces.push((options.width) + 'x' + (options.height));
                pieces.push('filters:quality(' + (__qualityValue) + ')');
                pieces.push(key);
                return pieces.join('/');
            }

            /**
             * Scales the image to a specific width or height, depending on
             * which dimension type is passed in. Both can't be passed in.
             */
            if (options.type === 'scale') {
                if (options.width !== undefined) {
                    pieces.push((options.width) + 'x0');
                    pieces.push('filters:quality(' + (__qualityValue) + ')');
                    pieces.push(key);
                    return pieces.join('/');
                }
                if (options.height !== undefined) {
                    pieces.push('0x' + (options.height));
                    pieces.push('filters:quality(' + (__qualityValue) + ')');
                    pieces.push(key);
                    return pieces.join('/');
                }
            }
            return false;
        }
    });
})();

/**
 * Modals
 * 
 * Handles modal interaction (opening, closing).
 * 
 * @abstract
 */
window.Modals = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'modals')
     */
    var __classType = 'modals';

    /**
     * __openModals
     * 
     * @access  private
     * @var     Array
     */
    var __openModals = [];

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Modals')
     */
    var __string = 'Modals';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * close
         * 
         * Closes all modals that are currently open. Updating of the local
         * __openModals array is done by the Modal close event listener (see Modal.js).
         * 
         * @access  public
         * @return  void
         */
        close: function() {
            $(__openModals).each(
                function(index, modal) {
                    modal.triggerHandler('close');
                }
            );
        },

        /**
         * closeExcept
         * 
         * Initiates a close, but excludes closing certain types of modals (for
         * dependency reasons)
         * 
         * @example Modals.closeExcept(['Share'])
         * @note    Ensure <ModalView> trailing string is not included
         * @access  public
         * @param   Array types
         * @return  void
         */
        closeExcept: function(types) {
            var constructors = [];
            $(types).each(
                function(index, type) {
                    type += 'ModalView';
                    constructors.push(window[type]);
                }
            );
            $(__openModals).each(
                function(index, modal) {
                    if (constructors.indexOf(modal.constructor) === -1) {
                        modal.triggerHandler('close');
                    }
                }
            );
        },

        /**
         * get
         * 
         * @example Modals.get('Share')
         * @note    Ensure <ModalView> trailing string is not included
         * @access  public
         * @param   String type
         * @return  ModalView|false
         */
        get: function(type) {
            type += 'ModalView';
            var modal = false;
            $(__openModals).each(
                function(index, modalView) {
                    if (modalView.constructor === window[type]) {
                        modal = modalView;
                    }
                }
            );
            return modal;
        },

        /**
         * getOpen
         * 
         * Returns a reference to the array containing all the open modals
         * 
         * @access  public
         * @return  Array
         */
        getOpen: function() {
            return __openModals;
        },

        /**
         * show
         * 
         * All-purpose modal booting
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object obj
         * @return  ModalView
         */
        show: function(type, obj) {
            var $modal = DataUtils.render((type) + 'Modal', obj || {});
                modal = new window[(type + 'ModalView')]($modal);
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            if (UserAgent.is.tablet() === false) {
                $modal.focusable().focus();
            }
            return modal;
        },

        /**
         * showCreateCollection
         * 
         * @access  public
         * @param   String type
         * @param   Boolean showAutoFeaturingMessaging
         * @return  CreateCollectionModalView
         */
        showCreateCollection: function(type, showAutoFeaturingMessaging) {
            var $modal = DataUtils.render('CreateCollectionModal', {
                    type: type,
                    showAutoFeaturingMessaging: showAutoFeaturingMessaging
                }),
                modal = new CreateCollectionModalView($modal);
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showCropper
         * 
         * @access  public
         * @param   Layer layer
         * @return  CropperModalView
         */
        showCropper: function(layer) {
            var start = new Date(),
                $modal = DataUtils.render('CropperModal', {
                    layer: layer
                }),
                modal = new CropperModalView($modal, layer),
                msg = Stencil.getMessage('app.crop.preparing');
            App.getBusy().show(msg);
            modal.once({
                'preload': function(event) {
                    (function() {
                        App.getBusy().hide();
                        $modal.removeClass('invisible');
                        modal.positionTooltip();
                    }).minDelay(start, 2000);
                }
            });
            modal.preload();
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showAddCategory
         * 
         * @access  public
         * @return  AddCategoryModalView
         */
        showAddCategory: function() {
            var $modal = DataUtils.render('AddCategoryModal'),
                admin = this.get('Admin'),
                modal = new AddCategoryModalView($modal, admin);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            if (UserAgent.is.tablet() === false) {
                $modal.focusable().focus();
            }
            return modal;
        },

        /**
         * showAddCoupon
         * 
         * @access  public
         * @return  AddCouponModalView
         */
        showAddCoupon: function() {
            var $modal = DataUtils.render('AddCouponModal'),
                admin = this.get('Admin'),
                modal = new AddCouponModalView($modal, admin);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            if (UserAgent.is.tablet() === false) {
                $modal.focusable().focus();
            }
            return modal;
        },

        /**
         * showAddPromoSet
         * 
         * @access  public
         * @return  AddPromoSetModalView
         */
        showAddPromoSet: function() {
            var $modal = DataUtils.render('AddPromoSetModal'),
                admin = this.get('Admin'),
                modal = new AddPromoSetModalView($modal, admin);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            if (UserAgent.is.tablet() === false) {
                $modal.focusable().focus();
            }
            return modal;
        },

        /**
         * showAdmin
         * 
         * @access  public
         * @return  AdminModalView
         */
        showAdmin: function() {
            var $admin = DataUtils.render('AdminModal'),
                modal = new AdminModalView($admin);
            __openModals.push(modal);
            App.find('> div.content').append($admin);
            return modal;
        },

        /**
         * showAlert
         * 
         * @access  public
         * @param   String code
         * @param   Object settings
         * @return  AlertModalView
         */
        showAlert: function(code, settings) {
            var $alert = DataUtils.render('AlertModal', {
                    settings: settings,
                    code: code
                }),
                modal = new AlertModalView($alert, settings);
            __openModals.push(modal);
            App.find('> div.content').append($alert);
            return modal;
        },

        /**
         * showApplyCategories
         * 
         * @access  public
         * @param   String type
         * @param   Accessor accessor
         * @return  ApplyCategoriesModalView
         */
        showApplyCategories: function(type, accessor) {
            var $modal = DataUtils.render('ApplyCategoriesModal', {
                    type: type,
                    accessor: accessor
                }),
                modal = new ApplyCategoriesModalView($modal, accessor);
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showApplyCoupon
         * 
         * @access  public
         * @param   CheckoutModalView checkoutModal
         * @param   String code
         * @return  ApplyCouponModalView
         */
        showApplyCoupon: function(checkoutModal, code) {
            var $applyCoupon = DataUtils.render('ApplyCouponModal', {
                    plan: checkoutModal.getPlan(),
                    code: code || false
                }),
                modal = new ApplyCouponModalView($applyCoupon, checkoutModal);
            __openModals.push(modal);
            App.find('.modal.checkout .outer > .inner > .content').append(
                $applyCoupon
            );
            $applyCoupon.focusable().focus().select();
            // App.find('> div.content').append($couponCode);
            return modal;
        },

        /**
         * showAssetsReimport
         * 
         * @access  public
         * @return  AssetsReimportModalView
         */
        showAssetsReimport: function() {
            var $model = DataUtils.render('AssetsReimportModal'),
                modal = new AssetsReimportModalView($model);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append(
                $model
            );
            if (UserAgent.is.tablet() === false) {
                $model.focusable().focus();
            }
            return modal;
        },

        /**
         * showCacheRefresh
         * 
         * @access  public
         * @return  CacheRefreshModalView
         */
        showCacheRefresh: function() {
            var $cacheRefresh = DataUtils.render('CacheRefreshModal'),
                modal = new CacheRefreshModalView($cacheRefresh);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append(
                $cacheRefresh
            );
            if (UserAgent.is.tablet() === false) {
                $cacheRefresh.focusable().focus();
            }
            return modal;
        },

        /**
         * showCancelAccount
         * 
         * @access  public
         * @param   AccountAccessor account
         * @return  CancelAccountModalView
         */
        showCancelAccount: function(account) {
            var $cancel = DataUtils.render('CancelAccountModal', {
                    account: account
                }),
                modal = new CancelAccountModalView($cancel, account);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($cancel);
            return modal;
        },

        /**
         * showCheckout
         * 
         * @access  public
         * @param   String plan
         * @param   String type
         * @return  CheckoutModalView
         */
        showCheckout: function(plan, type) {
            var $checkout = DataUtils.render('CheckoutModal', {
                    plan: plan,
                    type: type
                }),
                modal = new CheckoutModalView($checkout, plan, type);
            __openModals.push(modal);
            App.find('> div.content').append($checkout);
            if (UserAgent.is.tablet() === false) {
                $checkout.focusable().focus();
            }
            return modal;
        },

        /**
         * showChromeExtensionInstalled
         * 
         * @access  public
         * @return  ChromeExtensionInstalledModalView
         */
        showChromeExtensionInstalled: function() {
            var $installed = DataUtils.render('ChromeExtensionInstalledModal'),
                modal = new ChromeExtensionInstalledModalView($installed);
            __openModals.push(modal);
            App.find('> div.content').append($installed);
            return modal;
        },

        /**
         * showClearCanvasConfirm
         * 
         * @note    href attribute is needed in order to focus
         * @access  public
         * @param   Object data
         * @return  ClearCanvasConfirmModalView
         */
        showClearCanvasConfirm: function(data) {
            var $confirm = DataUtils.render('ClearCanvasConfirmModal', data),
                modal = new ClearCanvasConfirmModalView($confirm);
            __openModals.push(modal);
            App.find('> div.content').append($confirm);
            if (User.admin() === true) {
                var $first = $confirm.find('a.button').first();
                $first.attr('href', '#');
                $first.focus();
            }
            return modal;
        },

        /**
         * showConfirm
         * 
         * @note    href attribute is needed in order to focus
         * @access  public
         * @param   Object data
         * @return  ConfirmModalView
         */
        showConfirm: function(data) {
            var $confirm = DataUtils.render('ConfirmModal', data),
                modal = new ConfirmModalView($confirm);
            __openModals.push(modal);
            App.find('> div.content').append($confirm);
            if (User.admin() === true) {
                var $first = $confirm.find('a.button').first();
                $first.attr('href', '#');
                $first.focus();
            }
            return modal;
        },

        /**
         * showConfirmDelete
         * 
         * @access  public
         * @param   String h1
         * @param   undefined|String h2 (default: 'This cannot be undone')
         * @return  ConfirmModalView
         */
        showConfirmDelete: function(h1, h2) {
            h2 = DataUtils.getDefaultValue(h2, 'This cannot be undone');
            return this.showConfirm({
                h1: h1,
                h2: h2
            });
        },

        /**
         * showConfirmMobile
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  ConfirmMobileModalView
         */
        showConfirmMobile: function(shareModal, image) {
            var $modal = DataUtils.render('ConfirmMobileModal'),
                modal = new ConfirmMobileModalView($modal, shareModal, image);
            __openModals.push(modal);
            App.find('.modal.share .outer > .inner > .content').append(
                $modal
            );
            return modal;
        },

        /**
         * showConnections
         * 
         * @access  public
         * @param   String network
         * @return  ConnectionsModalView
         */
        showConnections: function(network) {
            var $connections = DataUtils.render('ConnectionsModal', {
                    network: network
                }),
                settings = this.get('Settings'),
                modal = new ConnectionsModalView($connections, network);
            __openModals.push(modal);
            App.find('.modal.settings .outer > .inner > .content').append(
                $connections
            );
            modal.refresh();
            return modal;
        },

        /**
         * showCountdown
         * 
         * @access  public
         * @param   Boolean onboard
         * @return  CountdownModalView
         */
        showCountdown: function(onboard) {
            var $relative = App.getStage().find('header .quota.bar:visible'),
                $countdown = DataUtils.render('CountdownModal', {
                    account: Stencil.account(),
                    onboard: onboard
                }),
                modal = new CountdownModalView(
                    $countdown,
                    'up',
                    $relative
                );
            __openModals.push(modal);
            App.find('> div.content').append($countdown);
            modal.position();
            return modal;
        },

        /**
         * showDownload
         * 
         * @access  public
         * @param   String key
         * @param   Boolean forceRemoteDownload
         * @return  DownloadModalView
         */
        showDownload: function(key, forceRemoteDownload) {
            var image = Stencil.getAccessor(key),
                $markup = DataUtils.render('DownloadModal', {
                    image: image
                }),
                modal = new DownloadModalView(
                    $markup,
                    image,
                    forceRemoteDownload
                );
            __openModals.push(modal);
            App.find('> div.content').append($markup);
            modal.show();
            return modal;
        },

        /**
         * showExtras
         * 
         * @access  public
         * @return  ExtrasModalView
         */
        showExtras: function() {
            var $extras = DataUtils.render('ExtrasModal', {
                }),
                modal = new ExtrasModalView($extras);
            __openModals.push(modal);
            App.find('> div.content').append($extras);
            return modal;
        },

        /**
         * showGoogleFonts
         * 
         * @access  public
         * @return  GoogleFontsModalView
         */
        showGoogleFonts: function() {
            var $modal = DataUtils.render('GoogleFontsModal', {
                    total: Config.get('google').fonts.total
                }),
                modal = new GoogleFontsModalView($modal);
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showLegacyImageNormalize
         * 
         * @access  public
         * @param   String key
         * @return  LegacyImageNormalizeModalView
         */
        showLegacyImageNormalize: function(key) {
            var image = Stencil.getAccessor(key),
                $legacyImageNormalize = DataUtils.render(
                    'LegacyImageNormalizeModal', {
                        image: image
                    }
                ),
                modal = new LegacyImageNormalizeModalView(
                    $legacyImageNormalize,
                    image
                );
            __openModals.push(modal);
            App.find('> div.content').append($legacyImageNormalize);
            return modal;
        },

        /**
         * showLogin
         * 
         * @access  public
         * @param   String type
         * @param   false|String redirect
         * @return  LoginModalView
         */
        showLogin: function(type, redirect) {
            var $login = DataUtils.render('LoginModal', {
                    redirect: redirect,
                    type: type
                }),
                modal = new LoginModalView($login, type, redirect);
            __openModals.push(modal);
            App.find('> div.content').append($login);
            if ($login.find('[name="data[email]"]').val() !== '') {
                if (UserAgent.is.tablet() === false) {
                    $login.find('[type="password"]').focus();
                }
            } else {
                if (UserAgent.is.tablet() === false) {
                    $login.find('[name="data[email]"]').focus();
                }
            }
            return modal;
        },

        /**
         * showOnboard
         * 
         * @access  public
         * @return  OnboardModalView
         */
        showOnboard: function() {
            var $relative = App.getStage().find('footer span.focus'),
                $highlight = $relative.find('a'),
                $onboard = DataUtils.render('OnboardModal'),
                modal = new OnboardModalView(
                    $onboard,
                    'down',
                    $relative,
                    $highlight
                );
            __openModals.push(modal);
            App.find('> div.content').append($onboard);
            modal.position();
            return modal;
        },

        /**
         * showOnboarding
         * 
         * @access  public
         * @param   String key
         * @return  OnboardingModalView
         */
        showOnboarding: function(key) {
            var hash = {
                    'backgroundSelected': 'BackgroundSelectedOnboardingModal',
                    'foregroundSelected': 'ForegroundSelectedOnboardingModal'
                },
                $modal = DataUtils.render(hash[key]),
                modal = new OnboardingModalView($modal);
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showPassword
         * 
         * @access  public
         * @param   String type
         * @param   false|String redirect
         * @return  PasswordModalView
         */
        showPassword: function(type, redirect) {
            var $password = DataUtils.render('PasswordModal', {
                    redirect: redirect,
                    type: type
                }),
                modal = new PasswordModalView($password, type, redirect);
            __openModals.push(modal);
            App.find('> div.content').append($password);
            if (UserAgent.is.tablet() === false) {
                $password.focusable().focus();
            }
            return modal;
        },

        /**
         * showPlanSwitch
         * 
         * @access  public
         * @param   String plan
         * @return  PlanSwitchModalView
         */
        showPlanSwitch: function(plan) {
            var $planSwitch = DataUtils.render('PlanSwitchModal', {
                    plan: plan
                }),
                modal = new PlanSwitchModalView($planSwitch);
            __openModals.push(modal);
            App.find('> div.content').append($planSwitch);
            return modal;
        },

        /**
         * showPlanSwitched
         * 
         * @access  public
         * @param   String plan
         * @return  PlanSwitchedModalView
         */
        showPlanSwitched: function(plan) {
            var $planSwitched = DataUtils.render('PlanSwitchedModal', {
                    plan: plan
                }),
                modal = new PlanSwitchedModalView($planSwitched);
            __openModals.push(modal);
            App.find('> div.content').append($planSwitched);
            return modal;
        },

        /**
         * showPlans
         * 
         * @access  public
         * @return  PlansModalView
         */
        showPlans: function(settings) {
            var $plans = DataUtils.render('PlansModal', {
                    type: settings.curtain === true ? 'curtain' : 'default'
                }),
                modal = new PlansModalView($plans);
            __openModals.push(modal);
            App.find('> div.content').append($plans);
            return modal;
        },

        /**
         * showPromo
         * 
         * @access  public
         * @param   String|false partner
         * @param   String type
         * @param   false|String redirect
         * @return  PromoModalView
         */
        showPromo: function(partner, type, redirect) {
            var $promo = DataUtils.render('PromoModal', {
                    partner: partner,
                    redirect: redirect,
                    type: type
                }),
                modal = new PromoModalView($promo, type, redirect);
            __openModals.push(modal);
            App.find('> div.content').append($promo);
            if ($promo.find('[name="data[name]"]').val() !== '') {
                if (UserAgent.is.tablet() === false) {
                    $promo.find('[name="data[code]"]').focus();
                }
            } else {
                if (UserAgent.is.tablet() === false) {
                    $promo.find('[name="data[name]"]').focus();
                }
            }
            return modal;
        },

        /**
         * showRename
         * 
         * @access  public
         * @param   Accessor accessor
         * @param   String columnName
         * @return  RenameModalView
         */
        showRename: function(accessor, columnName) {
            var $modal = DataUtils.render('RenameModal', {
                    accessor: accessor,
                    columnName: columnName
                }),
                modal = new RenameModalView($modal);
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            return modal;
        },

        /**
         * showRightClick
         * 
         * @access  public
         * @return  RightClickModalView
         */
        showRightClick: function() {
            var $relative = App.getStage().find('.canvas-container.preview-canvas-container'),
                // $highlight = App.getStage().find(
                $highlight = App.find(
                    '.canvas-container.preview-canvas-container, ' +
                    '.toolbar.text'
                ),
                $onboard = DataUtils.render('RightClickModal'),
                modal = new RightClickModalView(
                    $onboard,
                    'down',
                    $relative,
                    $highlight
                );
// StencilBooter.log($highlight.length);
            __openModals.push(modal);
            App.find('> div.content').append($onboard);
            modal.position();
            return modal;
        },

        /**
         * showSearchUsers
         * 
         * @access  public
         * @param   AdminUsersView section
         * @return  SearchUsersModalView
         */
        showSearchUsers: function(section) {
            var $modal = DataUtils.render('SearchUsersModal'),
                modal = new SearchUsersModalView($modal, section);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            if (UserAgent.is.tablet() === false) {
                $modal.focusable().focus();
            }
            return modal;
        },

        /**
         * showSent
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  ImageSentModalView
         */
        showSent: function(shareModal, image) {
            var $modal = DataUtils.render('ImageSentModal'),
                modal = new ImageSentModalView($modal, shareModal, image);
            __openModals.push(modal);
            App.find('.modal.share .outer > .inner > .content').append(
                $modal
            );
            return modal;
        },

        /**
         * showSettings
         * 
         * @access  public
         * @return  SettingsModalView
         */
        showSettings: function() {
            var $settings = DataUtils.render('SettingsModal', {
                    refereeSavings: Config.default('refereeSavings'),
                    refererCredit: Config.default('refererCredit')
                }),
                modal = new SettingsModalView($settings);
            __openModals.push(modal);
            App.find('> div.content').append($settings);
            return modal;
        },

        /**
         * showShare
         * 
         * @access  public
         * @param   ImageAccessor image
         * @return  ShareModalView
         */
        showShare: function(image) {
            var $share = DataUtils.render('ShareModal', {
                    image: image
                }),
                modal = new ShareModalView($share, image);
            __openModals.push(modal);
            App.find('> div.content').append($share);
            modal.show();
            return modal;
        },

        /**
         * showShareError
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @param   ConnectionAccessor connection
         * @return  ShareErrorModalView
         */
        showShareError: function(shareModal, image, connection) {
            var $modal = DataUtils.render('ShareErrorModal', {
                    connection: connection
                }),
                modal = new ShareErrorModalView(
                    $modal,
                    shareModal,
                    image,
                    connection
                );
            __openModals.push(modal);
            App.find('.modal.share .outer > .inner > .content').append(
                $modal
            );
            return modal;
        },

        /**
         * showShareSuccess
         * 
         * @access  public
         * @param   ShareModalView shareModal
         * @param   ShareAccessor share
         * @return  ShareSuccessModalView
         */
        showShareSuccess: function(shareModal, share) {
            var $modal = DataUtils.render('ShareSuccessModal', {
                    share: share
                }),
                modal = new ShareSuccessModalView($modal, shareModal, share);
            __openModals.push(modal);
            App.find('.modal.share .outer > .inner > .content').append(
                $modal
            );
            return modal;
        },

        /**
         * showSignup
         * 
         * @access  public
         * @param   String type
         * @param   false|String redirect
         * @return  SignupModalView
         */
        showSignup: function(type, redirect) {
            var data = {
                image: {
                    data: false
                },
                redirect: redirect,
                type: type
            };
            if (type === 'save') {
                var draft = Stencil.account().draft(),
                    configuration = draft.getConfiguration(),
                    hash = StringUtils.getHash(
                        JSON.stringify(configuration)
                    );
                data.image.data = draft.getSrc({
                    hash: hash
                });
            }
            var $signup = DataUtils.render('SignupModal', data),
                modal = new SignupModalView($signup, type, redirect);
            __openModals.push(modal);
            App.find('> div.content').append($signup);
            if (UserAgent.is.tablet() === false) {
                $signup.focusable().focus();
            }
            return modal;
        },

        /**
         * showTemplatePreview
         * 
         * @access  public
         * @param   TemplateAccessor template
         * @return  TemplatePreviewModalView
         */
        showTemplatePreview: function(template) {
            var url = template.getPreviewThumbImageUrl(),
                img = Images.getPreloaded(url),
                $modal = DataUtils.render('TemplatePreviewModal', {
                    img: img,
                    template: template
                }),
                modal = new TemplatePreviewModalView($modal, template);
            __openModals.push(modal);
            App.find('> div.content').append($modal);
            modal.show();
            modal.position();
            return modal;
        },

        /**
         * showTutorials
         * 
         * @access  public
         * @param   String section
         * @return  TutorialsModalView
         */
        showTutorials: function(section) {
            var tutorials = Config.get('tutorials'),
                $tutorials = DataUtils.render('TutorialsModal', {
                    tutorials: tutorials
                }),
                modal = new TutorialsModalView($tutorials, tutorials);
            __openModals.push(modal);
            App.find('> div.content').append($tutorials);
            return modal;
        },

        /**
         * showUpdateUser
         * 
         * @access  public
         * @param   String key
         * @param   AdminUsersView section
         * @return  UpdateUserModalView
         */
        showUpdateUser: function(key, section) {
            var $modal = DataUtils.render('UpdateUserModal', {
                    user: Stencil.getAccessor(key)
                }),
                modal = new UpdateUserModalView($modal, key, section);
            __openModals.push(modal);
            App.find('.modal.admin .outer > .inner > .content').append($modal);
            if (UserAgent.is.tablet() === false) {
                $modal.focusable().focus();
            }
            return modal;
        },

        /**
         * showUpgrade
         * 
         * @access  public
         * @param   String plan
         * @param   String reason
         * @return  UpgradeModalView
         */
        showUpgrade: function(plan, reason) {
            var $upgrade = DataUtils.render('UpgradeModal', {
                    plan: plan,
                    reason: reason
                }),
                modal = new UpgradeModalView($upgrade);
            __openModals.push(modal);
            App.find('> div.content').append($upgrade);
            return modal;
        },

        /**
         * showUpgraded
         * 
         * @access  public
         * @param   String plan
         * @return  UpgradedModalView
         */
        showUpgraded: function(plan) {
            var $upgraded = DataUtils.render('UpgradedModal', {
                    plan: plan
                }),
                modal = new UpgradedModalView($upgraded, plan);
            __openModals.push(modal);
            App.find('> div.content').append($upgraded);
            return modal;
        },

        /**
         * showWelcomeTour
         * 
         * @access  public
         * @return  WelcomeModalView
         */
        showWelcomeTour: function() {
            var $welcome = DataUtils.render('WelcomeTourModal'),
                modal = new WelcomeTourModalView($welcome);
            __openModals.push(modal);
            App.find('> div.content').append($welcome);
            return modal;
        },

        /**
         * showYouTubeVideo
         * 
         * @access  public
         * @param   String youTubeSlug
         * @param   Object options
         * @return  YouTubeVideoModalView
         */
        showYouTubeVideo: function(youTubeSlug, options) {
            var $youTubeVideo = DataUtils.render('YouTubeVideoModal', {
                    youTubeSlug: youTubeSlug,
                    options: options
                }),
                modal = new YouTubeVideoModalView(
                    $youTubeVideo,
                    youTubeSlug,
                    options
                );
            __openModals.push(modal);
            App.find('> div.content').append($youTubeVideo);
            return modal;
        }
    });
})();

/**
 * Normalizer
 * 
 * @abstract
 */
window.Normalizer = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'normalizer')
     */
    var __classType = 'normalizer';

    /**
     * __documents
     * 
     * @var     Object
     * @access  private
     */
    var __documents = {
        legacy: {},
        normalized: {
            layers: []
        }
    };

    /**
     * __order
     * 
     * @var     Number (default: 0)
     * @access  private
     */
    var __order = 0;

    /**
     * __backgroundImageLayer
     * 
     * @access  private
     * @return  void
     */
    var __backgroundImageLayer = function() {
        var layer = {
            background: true,
            filters: [],
            image: false,
            styles: {
                left: 50,
                top: 50
            },
            type: 'image'
        };
        jQuery.each(__documents.legacy.layers, function() {
            if (this.type === 'image') {
                layer.image = this.sourceSrc;
                layer.filters = __getAppliedFilters(this);
            }
        });
        __documents.normalized.layers.push(layer);
    };

    /**
     * __backgroundRectangleLayer
     * 
     * @access  private
     * @return  void
     */
    var __backgroundRectangleLayer = function() {
        var layer = {
            background: true,
            styles: {
                backgroundColor: ColorUtils.convert('#ffffff', 'rgba'),
                height: 100,
                left: 50,
                top: 50,
                width: 100
            },
            type: 'rectangle'
        };
        jQuery.each(__documents.legacy.layers, function() {
            if (this.type === 'rectangle') {
                layer.styles.backgroundColor = ColorUtils.convert(
                    this.styles.fillStyle,
                    'rgba'
                );
            }
        });
        __documents.normalized.layers.push(layer);
    };

    /**
     * __getAppliedFilters
     * 
     * @access  private
     * @param   Object sourceLayer
     * @return  Array
     */
    var __getAppliedFilters = function(sourceLayer) {
        var encoded = JSON.stringify(sourceLayer),
            matching = [],
            possible = {
                'blur': 'blur',
                'darken': 'darken',
                'greyscale': 'bw',
                'sepia': 'sepia',
                'grungy': 'grungy',
                'glowingSun': 'glowingSun',
                'inverse': 'inverse',
                'lomo': 'lomo',
                'vintage': 'vintage',
                'posterize': 'posterize',
                'clarity': 'clarity',
                'sinCity': 'sinCity',
                'orangePeel': 'orangePeel',
                'hazyDays': 'hazyDays',
                'hemingway': 'hemingway',
                'concentrate': 'concentrate',
                'sunrise': 'sunrise',
                'love': 'love'
            },
            check;
        for (var index in possible) {
            check = new RegExp('type\"\:[ ]?\"' + (index), 'i');
            if (encoded.match(check) !== null) {
                matching.push(possible[index]);
            }
        }
        return matching;
    };

    /**
     * __getCanvasHeight
     * 
     * @access  private
     * @return  Number
     */
    var __getCanvasHeight = function() {
        var json = JSON.stringify(__documents.legacy),
            matches = json.match(/\"height\"\:[ ]?([0-9]+)/i);
        if (matches === null) {
            return 385;
        }
        return matches.pop().toInt();
    };

    /**
     * __getCanvasWidth
     * 
     * @access  private
     * @return  Number
     */
    var __getCanvasWidth = function() {
        var json = JSON.stringify(__documents.legacy),
            matches = json.match(/\"width\"\:[ ]?([0-9]+)/i);
        if (matches === null) {
            return 495;
        }
        return matches.pop().toInt();
    };

    /**
     * __getDefaultBackdropPaddingFactor
     * 
     * @access  private
     * @return  Number
     */
    var __getDefaultBackdropPaddingFactor = function() {
        return Config.default('backdropPaddingFactor');
    };

    /**
     * __getDefaultStrokeWidthDividingFactor
     * 
     * @access  private
     * @return  Number
     */
    var __getDefaultStrokeWidthDividingFactor = function() {
        return Config.default('strokeWidthDividingFactor');
    };

    /**
     * __getTranslatedPosition
     * 
     * @access  private
     * @param   Object sourceLayer
     * @return  Object
     */
    var __getTranslatedPosition = function(sourceLayer) {
        var position = {
            repositionLeft: true,
            repositionTop: true,
            left: sourceLayer.styles.x,
            top: sourceLayer.styles.y
        };
        if (position.left === 'center') {
            position.repositionLeft = false;
            position.left = 50;
        }
        if (position.top === 'center') {
            position.repositionTop = false;
            position.top = 50;
        }
        position.left = position.left.round(4);
        position.top = position.top.round(4);
        if (isNaN(position.left) === true) {
            position.repositionLeft = false;
            position.left = 50;
        }
        if (isNaN(position.top) === true) {
            position.repositionTop = false;
            position.top = 50;
        }
        return position;
    };

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Normalizer')
     */
    var __string = 'Normalizer';

    /**
     * __textLayer
     * 
     * @access  private
     * @param   Object sourceLayer
     * @return  void
     */
    var __textLayer = function(sourceLayer) {
        var layer = {
            styles: {
                angle: 0,
                backdropColor: false,
                backdropPaddingFactor: __getDefaultBackdropPaddingFactor(),
                backdropStretch: 'slim',
                bold: false,
                italic: false,
                // lineHeight: 1.2,
                lineHeight: 1.1,
                // lineHeight: 1,
                order: __order,
                strokeColor: false,
                strokeWidthDividingFactor: __getDefaultStrokeWidthDividingFactor(),
                underline: false
            },
            text: sourceLayer.styles.text,
            type: 'text'
        };

        // Positioning
        var position = __getTranslatedPosition(sourceLayer);
        layer.styles.repositionLeft = position.repositionLeft;
        layer.styles.repositionTop = position.repositionTop;
        layer.styles.left = position.left;
        layer.styles.top = position.top;

        // Font size (reverse of relative font sizing in TextDrawing class)
        var fontSize = sourceLayer.styles.fontSize.toFloat();
        layer.styles.fontSize = (fontSize / __getCanvasWidth() * 1000 * 0.95).round(4);

        // 95% width
        layer.styles.width = 95;

        // The rest..
        layer.styles.align = sourceLayer.styles.align;
        layer.styles.fontFamily = sourceLayer.styles.fontFamily;
        layer.styles.textColor = ColorUtils.convert(
            sourceLayer.styles.fillStyle,
            'rgba'
        );
        if (sourceLayer.plane !== undefined) {
            layer.styles.backdropColor = ColorUtils.convert(
                sourceLayer.plane,
                'rgba'
            );
            layer.styles.backdropStretch = 'full';
        }
        if (
            sourceLayer.styles.strokeStyle !== undefined
            && (
                sourceLayer.styles.strokeWidth !== undefined
                && sourceLayer.styles.strokeWidth.toInt() !== 0
            )
        ) {
            layer.styles.strokeColor = ColorUtils.convert(
                sourceLayer.styles.strokeStyle,
                'rgba'
            );
        }
        else {
            // layer.styles.shadow = 'rgba(0,0,0,0.25)';
        }
        if (sourceLayer.styles.fontStyle === 'italic') {
            layer.styles.italic = true;
        }
        if (sourceLayer.styles.fontStyle === 'bold') {
            layer.styles.bold = true;
        }
        __documents.normalized.layers.push(layer);
    };

    /**
     * __textLayers
     * 
     * @access  private
     * @return  void
     */
    var __textLayers = function() {
        jQuery.each(__documents.legacy.layers, function() {
            if (this.type === 'text') {
                __textLayer(this);
                ++__order;
            }
        });
    };

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * image
         * 
         * @access  public
         * @param   String json
         * @return  void
         */
        image: function(json) {
            __documents.legacy = JSON.parse(json);
            __documents.normalized.layers = [];
            __order = 0;
            __backgroundRectangleLayer();
            __backgroundImageLayer();
            __textLayers();
            return JSON.stringify(__documents.normalized);
        }
    });
})();

/**
 * Scripts
 * 
 * @abstract
 */
window.Scripts = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'scripts')
     */
    var __classType = 'scripts';

    /**
     * __load
     * 
     * @note    It's important that the error callback for this call does not
     *          trigger a Stencil.alive / Stencil.error call. This is because I'm
     *          managing Scripts failing to load within AppView.waitFor where I
     *          show a Stencil.alert instead communicating to the user that the
     *          dependency failed to load.
     * @access  private
     * @param   String name
     * @param   undefined|Function callback (default: function() {})
     * @return  void
     */
    var __load = function(name, callback) {
        callback = DataUtils.getDefaultValue(callback, function() {});
        var listener = 'script/' + (name) + '/loaded';
        if (__loaded[name] === true) {
            callback();
        } else {
            Stencil.on(listener, callback);
            if (__loading[name] === undefined) {
                __loading[name] = true;
                var signature = {file: 'Scripts', line: 31};
                Stencil.ajax({
                    excludeDefaultData: true,
                    cache: true,
                    signature: signature,
                    timeout: 15 * 1000,
                    url: __urls[name],
                    type: 'GET',
                    dataType: 'script',
                    error: function(jqXHR, textStatus, errorThrown) {
                        App.log('Script load error', true);
                        App.log(name, true);
                        App.log('jQuery AJAX error', true);
                        App.log(signature, true);
                        App.log(arguments, true);
                        // Leave this commented, and see @note above
                        // Stencil.alive(function() {
                        //     var code = 's35-' + (name),
                        //         reference = 'scripts';
                        //     Stencil.error(code, reference);
                        // });
                    },
                    success: function() {
                        __loaded[name] = true;
                        __loading[name] = false;
                        Stencil.triggerHandler('script/loaded', [name]);
                        Stencil.triggerHandler(listener);
                    }
                });
            }
        }
    };

    /**
     * __loaded
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __loaded = {};

    /**
     * __loading
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __loading = {};

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Scripts')
     */
    var __string = 'Scripts';

    /**
     * __urls
     * 
     * @access  private
     * @var     Object
     */
    var __urls = {
        accountDock: 'https://static.accountdock.com/app.min.js',
        aws: '/app/static/vendors/source/external/aws-sdk-js/v2.2.10/sdk.min.js',
        facebook: 'https://connect.facebook.net/en_US/sdk.js',
        headway: 'https://cdn.headwayapp.co/widget.js',
        reCaptcha: 'https://www.google.com/recaptcha/api.js',
        segment: 'https://cdn.segment.com/analytics.js/v1/key/analytics.min.js',
        stripe: 'https://js.stripe.com/v2/',
        tapfiliate: 'https://static.tapfiliate.com/tapfiliate.js'
        // tapfiliate: 'https://script.tapfiliate.com/tapfiliate.js'
    };

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  String
         */
        get: function(key) {
            return __urls[key];
        },

        /**
         * load
         * 
         * @access  public
         * @param   String name
         * @param   undefined|Function callback
         * @return  void
         */
        load: function(name, callback) {
            __load(name, callback);
        },

        /**
         * loaded
         * 
         * @access  public
         * @param   String name
         * @return  void
         */
        loaded: function(name) {
            return __loaded[name] === true;
        },

        /**
         * set
         * 
         * @access  public
         * @param   String key
         * @param   String url
         * @return  void
         */
        set: function(key, url) {
            __urls[key] = url;
        }
    });
})();

/**
 * Services
 * 
 * @abstract
 */
window.Services = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'services')
     */
    var __classType = 'services';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Services')
     */
    var __string = 'Services';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * check
         * 
         * @access  public
         * @param   String service
         * @return  Boolean
         */
        check: function(service) {
            var services = Config.get('services');
            return services[service] === true;
        }
    });
})();

/**
 * Track
 * 
 * @todo!    Move declarations of which events should be sent to which providers
 *           to the server side. Better to have that all sync'd up, since calls
 *           are also made on the server side.
 * @abstract
 */
window.Track = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'track')
     */
    var __classType = 'track';

    /**
     * __lastIdentifyTraitsHash
     * 
     * @access  private
     * @var     String (default: '')
     */
    var __lastIdentifyTraitsHash = '';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'Track')
     */
    var __string = 'Track';

    /**
     * __tracked
     * 
     * @access  private
     * @var     Object
     */
    var __tracked = {
        events: [],
        pages: []
    };

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * alias
         * 
         * @note    The userAccount data is accessed directly, instead of through
         *          the UserAccountAccessor reference (eg.
         *          .active().userAccount()) since the reference won't have been
         *          created yet. The reason for this, is that creating that
         *          reference happens when the login/signup event is triggered.
         * @access  public
         * @return  void
         */
        alias: function() {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    var user = Stencil.get('user'),
                        id = user.active().get('userAccount').id;
                        // id = user.active().userAccount().get('id');
// StencilBooter.log(id);
                    if ('analytics.alias'.validMethod() === true) {
                        analytics.alias(id);
                    }
                });
            }
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            Config.get('segment').enabled = false;
        },

        /**
         * enabled
         * 
         * Returns whether or not analytics should be tracked based on the role
         * of the environment.
         * 
         * @note    The hardcoded check against the account key below was due to
         *          a bug whereby events were spamming Segment. I believe this
         *          was related to a race-condition bug related to downloading
         *          an asset, specifically with Safari. I haven't confirmed if
         *          it's still ongoing, but it's likely safe to remove this
         *          check.
         * @access  public
         * @return  Boolean
         */
        enabled: function() {
            if (
                User.admin() === true
                || User.editor() === true
                || Stencil.account().get('key') === 'accnd0bcfeb0'
            ) {
                return false;
            }
            return Config.get('segment').enabled === true;
        },

        /**
         * event
         * 
         * @access  public
         * @param   String action
         * @param   undefined|Object properties
         * @return  void
         */
        event: function(action, properties) {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    properties = properties || {};
                    properties.category = 'App';
                    if (false) {
                        properties.category = 'Publisher';
                    }
                    // __tracked.events.push({
                    //     event: action,
                    //     properties: properties
                    // });
                    var integrations = {
                        'All': false,
                        'AdRoll': false,
                        'Facebook Pixel': true,
                        'Google Analytics': true,
                        'Mixpanel': false
                    };
                    if ('analytics.track'.validMethod() === true) {
                        analytics.track(action, properties, integrations);
                    }
                });
            }
        },

        /**
         * page
         * 
         * @note    Greater-than check is performed to prevent initial call,
         *          since Segment automatically makes call upon load anyway.
         * @access  public
         * @return  void
         */
        page: function(path) {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    __tracked.pages.push(path);
                    if (__tracked.pages.length > 1) {
                        if ('analytics.page'.validMethod() === true) {
                            analytics.page({
                                path: path,
                                integrations: {
                                    'All': false,
                                    'AdRoll': false,
                                    'Facebook Pixel': true,
                                    'Google Analytics': true,
                                    'Mixpanel': false
                                }
                            });
                        }
                    }
                });
            }
        },

        /**
         * user
         * 
         * @note    The JSON check below is because when change history was
         *          introduced, it resulted in way too many calls to this method
         *          happening when nothing really changed.
         *          This was because the AccountAccessor changeHistory property
         *          was changed each time the canvas was updated, which would
         *          result in this method being continuously called.
         * @note    The userAccount data is accessed directly, instead of through
         *          the UserAccountAccessor reference (eg.
         *          .active().userAccount()) since the reference won't have been
         *          created yet. The reason for this, is that creating that
         *          reference happens when the login/signup event is triggered.
         * @access  public
         * @return  void
         */
        user: function() {
            if (Track.enabled() === true) {
                Scripts.load('segment', function() {
                    var user = Stencil.get('user'),
                        id = user.active().get('userAccount').id,
                        traits = user.getTraits(),
                        identifyTraitsHash = JSON.stringify(traits);
                        // id = user.active().userAccount().get('id');
                    if (identifyTraitsHash !== __lastIdentifyTraitsHash) {
                        __lastIdentifyTraitsHash = identifyTraitsHash;
                        if ('analytics.identify'.validMethod() === true) {
                            analytics.identify(
                                id,
                                traits,
                                {
                                    integrations: {
                                        'All': false,
                                        'Google Analytics': false,
                                        'Mixpanel': false
                                    }
                                }
                            );
                        }
                    }
                });
            }
        }
    });
})();

/**
 * User
 * 
 * @fires   login
 *          signup
 * @abstract
 */
window.User = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'user')
     */
    var __classType = 'user';

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'User')
     */
    var __string = 'User';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * admin
         * 
         * Returns whether or not the logged in user (if any) is an admin.
         * 
         * @access  public
         * @return  Boolean
         */
        admin: function() {
            var user = Stencil.get('user');
            return User.exists() === true
                && user.setting('admin').toInt() === 1;
        },

        /**
         * blockedFromCheckout
         * 
         * @access  public
         * @return  Boolean
         */
        blockedFromCheckout: function() {
            var host = Stencil.get('user').get('email').split('@').pop(),
                defaults = Config.get('defaults'),
                emailProvidersBlockedFromCheckout = defaults.emailProvidersBlockedFromCheckout;
            if (ArrayUtils.contains(host, emailProvidersBlockedFromCheckout) === false) {
                return false;
            }
            return true;
        },

        /**
         * customer
         * 
         * @note    proxy
         * @access  public
         * @return  Boolean
         */
        // customer: function() {
        //     return Stencil.get('user').customer();
        // },

        /**
         * editor
         * 
         * @access  public
         * @return  Boolean
         */
        editor: function() {
            var user = Stencil.get('user');
            return User.exists() === true
                && user.setting('editor').toInt() === 1;
        },

        /**
         * exists
         * 
         * Returns whether a user exists (aka. not a guest account). Initially
         * only had a false check, but there was an edge-case whereby this
         * method was being called before <Stencil.set> was called. When that
         * happened, the stored valued was <undefined>. I ran into this
         * edge-case when preparing logic for syncing image JSON data in the
         * ImageAccessor.
         * 
         * @access  public
         * @return  Boolean
         */
        exists: function() {
            var user = Stencil.get('user');
            return user !== false && user !== undefined;
        },

        /**
         * login
         * 
         * Performs the neccessary logic to log the user in, including
         * analytics, account reloading and firing events.
         * 
         * @note    Logic is very sensitive to ordering. Be careful :/
         * @access  public
         * @return  void
         */
        login: function() {
            var user = Stencil.get('user');
            Stencil.account().reload();
            Track.user();
            Track.event('Logged in');
            user.on({
                'change': Track.user
            });
            Stencil.account().on({
                'change': Track.user
            });
            User.triggerHandler('login', [user]);
            // Stencil.account().reload();
            Stencil.account().syncFavorites();

            // Get watermarks and turn on the ones that ought to be turned on
            var watermarks = Stencil.account().collection('watermarks'),
                // styles,
                active;
            watermarks.each(
                function(index, watermark) {
                    // styles = JSON.parse(watermark.setting('styles'));
                    active = watermark.setting('active').toInt() === 1;
                    if (active === true) {
                        watermark.addToCanvas(false);
                    }
                }
            );

            // // Delete all layers, excluding watermarks
            // var iD = Canvases.Preview.getImageDocument();
            // jQuery.each(iD.getLayers(false), function(index, layer) {
            //     layer.triggerHandler('delete');
            // });

            // // 
            // var draft = Stencil.account().draft();
            // draft.setToImage(image);
            // var document = draft.json();

            // // Set image document
            // Canvases.Preview.prepareAndDraw(document);
        },

        /**
         * logout
         * 
         * @see     https://segment.com/docs/libraries/analytics.js/
         * @see     http://stackoverflow.com/questions/21137286/what-should-i-do-when-users-log-out
         * @todo    Implement the same flow/logic that you do below for logging
         *          out when the app is open via an external chrome extension for
         *          the Alert and Error modal flows. At the moment, it simply
         *          changes the path of the parent page. Works for users that are
         *          at getstencil.com/app, but for those using the app through
         *          the extension, it's taking them to a new, unintented, page.
         *          Have the app slide down, and back up? Also, do this for the
         *          admin area when cancelling a user:
         *          https://i.imgur.com/lwStqly.png
         *          Will get annoying pretty fast :/
         * @access  public
         * @param   Function callback
         * @return  void
         */
        logout: function(callback) {

            // Messaging
            var msg = Stencil.getMessage('user.logout');
            App.getBusy().show(msg);

            // 
            var path = '/users/logout';
            Stencil.ajax({
                signature: {file: 'User', line: 139},
                url: path,
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        Stencil.kill();

                        // Callback delay
                        callback = callback || function() {
                            // var path = '/app',
                            var path = UserAgent.getLogoutPath(),
                                options = Stencil.getOptions();
                            if (options.source.external === true) {
                                if (options.source.extension === true) {
                                    if (options.source.chrome === true) {
                                        var slide = Config.default('slide');
                                        path = '/app?external&extension&' +
                                            'chrome';
                                        App.hide();
                                        (function() {
                                            Stencil.postMessage(
                                                'message.app.logout'
                                            );
                                            window.location.assign(path);
                                        }).delay(slide);
                                    }
                                }
                            } else {
                                window.location.assign(path);
                            }
                        };

                        // Tracking condition
                        if (Track.enabled() === true) {
                            Scripts.load('segment', function() {
                                if ('analytics.reset'.validMethod() === true) {
                                    analytics.reset();
                                }
                                if ('mixpanel.cookie.clear'.validMethod() === true) {
                                    mixpanel.cookie.clear();
                                }
                                callback.delay(1000);
                            });
                        } else {
                            callback.delay(1000);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'u63-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * on
         * 
         * @access  public
         * @return  void
         */
        // on: function() {
        //     $(User).on.apply($(User), $(arguments).toArray());
        // },

        /**
         * once
         * 
         * @access  public
         * @return  void
         */
        // once: function() {
        //     $(User).one.apply($(User), $(arguments).toArray());
        // },

        /**
         * signup
         * 
         * Performs the neccessary logic to sign a user up within the app,
         * including analytics, property updating and firing events.
         * 
         * @note    Logic is very sensitive to ordering. Be careful :/
         * @note    Delay below is to ensure alias call is made before
         *          user/identify call
         * @access  public
         * @return  void
         */
        signup: function() {
            var user = Stencil.get('user');
            Stencil.account().set({
                'guest': 0
            });
            Track.alias();
            Track.user.delay(5 * 1000);
            Track.event('Signed up');
            user.on({
                'change': Track.user
            });
            Stencil.account().on({
                'change': Track.user
            });
            User.triggerHandler('signup', [user]);
        },

        /**
         * trackShareASaleConversion
         * 
         * @access  public
         * @return  Boolean
         */
        trackShareASaleConversion: function() {
            if (Track.enabled() === false) {
                return false;
            }
            if (Services.check('shareASale') === false) {
                return false;
            }
            if (Stencil.account().get('upgrades').length > 1) {
                return false;
            }
            return true;
        },

        /**
         * trackTapfiliateConversion
         * 
         * Ensures that Tapfiliate conversion operations to not happen if:
         * - Tracking is enabled in general (eg. locally or on dev)
         * - Tapfiliate service is turned off (eg. they're down)
         * - the window.tap property is undefined (likely aggressive AdBlocker)
         * - The user has more than one upgrade record (conversion tracking is
         *   not available if a user upgrades, downgrades, and then upgrades
         *   again)
         * 
         * @access  public
         * @return  Boolean
         */
        trackTapfiliateConversion: function() {
            if (Track.enabled() === false) {
                return false;
            }
            if (Services.check('tapfiliate') === false) {
                return false;
            }
            if (window.tap === undefined) {
                return false;
            }
            if (Stencil.account().get('upgrades').length > 1) {
                return false;
            }
            return true;
        },

        /**
         * triggerHandler
         * 
         * @access  public
         * @return  void
         */
        // triggerHandler: function() {
        //     var msg = arguments[0];
        //     LogUtils.log.objects.user(msg);
        //     $(User).triggerHandler.apply($(User), $(arguments).toArray());
        // },

        /**
         * unbind
         * 
         * @access  public
         * @return  void
         */
        // unbind: function() {
        //     $(User).unbind.apply($(User), $(arguments).toArray());
        // },

        /**
         * upgrade
         * 
         * @note    The properties here aren't prepended with an underscore
         *          since the naming convention here is important for conversion
         *          tracking with Facebook and AdRoll
         * @note    Revenue and value are both tracked, since different ad
         *          networks expect different key names
         * @note    The triggerHandler call needs to happen first to ensure the
         *          UpgradeAccessor is available. See here:
         *          https://i.imgur.com/iBEqG4F.png
         * @note    window.tap !== undefined check is to prevent error with ad
         *          blockers
         * @access  public
         * @param   false|Object stripeResponse
         * @return  void
         */
        upgrade: function(stripeResponse) {
            Account.triggerHandler('upgrade', [Stencil.account()]);
            Track.user();
            if (stripeResponse !== false) {
                var upgrade = Stencil.account().upgrade(),
                    centsPaid = false;

                // Charge went through
                if (stripeResponse.charge !== false) {
                    centsPaid = stripeResponse.charge.amount.toInt();
                }
                // Likely no charge, but will be one when trial converts
                else if (stripeResponse.upcomingInvoice !== false) {
                    centsPaid = stripeResponse.upcomingInvoice.amount_due.toInt();
                }

                // Helper to determine if Tapfiliate tracking should be running
                if (User.trackTapfiliateConversion() === true) {
                    var identifier = upgrade.getTapfiliateCommissionTypeIdentifier(),
                        metaData = {
                            email: Stencil.get('user').get('email'),
                            id: Stencil.get('user').get('id'),
                            key: Stencil.get('user').get('key')
                        };
                    if ('tap'.validMethod() === true) {
                        tap(
                            'conversion',
                            upgrade.get('key'),
                            centsPaid / 100,
                            {
                                meta_data: metaData
                            },
                            identifier,
                            function(conversion) {
                                upgrade.push(
                                    'settings.tapfiliateConversionId',
                                    conversion.id
                                );
                            }
                        );
                    }
                }

                // Helper to determine if ShareASale tracking should be running
                if (User.trackShareASaleConversion() === true) {
                // if (true) {
                    var identifier = upgrade.getShareASaleCommissionTypeIdentifier(),
                        merchantId = Config.get('shareASale').auth.id,
                        transType = 'sale',
                        upgradeKey = upgrade.get('key'),
                        amount = centsPaid / 100,
                        url = 'https://shareasale.com/sale.cfm?' +
                            'amount=' + (amount) + '&' +
                            'tracking=' + (upgradeKey) + '&' +
                            'transtype=' + (transType) + '&' +
                            'merchantID=' + (merchantId),
                        image = new Image();
                    image.src = url;
                }

                // Track event
                Track.event('Upgraded', {
                    currency: 'USD',
                    revenue: centsPaid / 100,
                    value: centsPaid
                });
            }
        }
    });
})();

/**
 * UserAgent
 * 
 * @todo!    Modernize with Modernizr
 *           For detecting italic support in the canvas (used in text drawings):
 *           http://stackoverflow.com/questions/14489363/detect-bold-and-italic-support
 * @abstract
 */
window.UserAgent = (function() {

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'userAgent')
     */
    var __classType = 'userAgent';

    /**
     * __italic
     * 
     * @access  private
     * @var     undefined|Boolean (default: undefined)
     */
    var __italic = undefined;

    /**
     * __string
     * 
     * @access  private
     * @var     String (default: 'UserAgent')
     */
    var __string = 'UserAgent';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * extension
         * 
         * Returns whether or not the app is currently being accessed via a
         * browser extension.
         * 
         * @access  public
         * @return  Boolean
         */
        extension: function() {
            return App.getElement().hasClass('external') === true
                && App.getElement().hasClass('extension') === true;
        },

        /**
         * getLogoutPath
         * 
         * @access  public
         * @return  String
         */
        getLogoutPath: function() {
            var path = '/?bye';
            if (Stencil.getOptions().source.electron === true) {
                path = '/app/login?curtain&electron';
            }
            return path;
        },

        /**
         * getOrientation
         * 
         * @access  public
         * @return  false|String
         */
        getOrientation: function() {
            if (UserAgent.is.ipad() === false) {
                return false;
            }
            var orientation = window.orientation;
            if (orientation === 0 || orientation === 180) {
                return 'portrait';
            }
            return 'landscape';
        },

        /**
         * hasCSP
         * 
         * @access  public
         * @return  Boolean
         */
        hasCSP: function() {
            var blacklist = [
                    'mail.google.com'
                ],
                params = Stencil.get('messageParams'),
                hostname;
            if (params !== undefined) {
                if (params.parent !== undefined) {
                    if (params.parent.location !== undefined) {
                        if (params.parent.location.hostname !== undefined) {
                            hostname = params.parent.location.hostname;
                        }
                    }
                }
            }
            if (ArrayUtils.contains(hostname, blacklist) === false) {
                return false;
            }
            return true;
        },

        /**
         * is
         * 
         * @access  public
         * @return  Object
         */
        is: {

            /**
             * chrome
             * 
             * @access  public
             * @return  Boolean
             */
            chrome: function() {
                return /chrom(e|ium)/.test(navigator.userAgent.toLowerCase());
            },

            /**
             * edge
             * 
             * @access  public
             * @return  Boolean
             */
            edge: function() {
                return / edge/.test(navigator.userAgent.toLowerCase()) === true;
            },

            /**
             * electron
             * 
             * @access  public
             * @return  Boolean
             */
            electron: function() {
                return / electron/.test(navigator.userAgent.toLowerCase()) === true;
            },

            /**
             * firefox
             * 
             * @access  public
             * @return  Boolean
             */
            firefox: function() {
                return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
            },

            /**
             * ie
             * 
             * @see     http://blogs.msdn.com/b/ieinternals/archive/2013/09/21/internet-explorer-11-user-agent-string-ua-string-sniffing-compatibility-with-gecko-webkit.aspx
             * @sample  'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)'
             * @sample  'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; .NET4.0E; .NET4.0C; rv:11.0) like Gecko'
             * @access  public
             * @return  Boolean
             */
            ie: function() {
                var userAgent = navigator.userAgent;
                return userAgent.match(/msie/i) !== null
                    || userAgent.match(/trident\/7/i) !== null;
            },

            /**
             * ipad
             * 
             * @access  public
             * @return  Boolean
             */
            ipad: function() {
                return navigator.userAgent.match(/iPad/i) !== null;
            },

            /**
             * mac
             * 
             * @access  public
             * @return  Boolean
             */
            mac: function() {
                return navigator.appVersion.indexOf('Mac') !== -1;
            },

            /**
             * safari
             * 
             * @see     http://stackoverflow.com/questions/7944460/detect-safari-browser
             * @access  public
             * @return  Boolean
             */
            safari: function() {
                return /^((?!chrome).)*safari/i.test(navigator.userAgent);
            },

            /**
             * tablet
             * 
             * Returns whether the visitor is experiencing the app on a tablet.
             * 
             * @access  public
             * @return  Boolean
             */
            tablet: function() {
                return UserAgent.is.ipad() === true;
            }
        },

        /**
         * supports
         * 
         * @access  public
         * @return  Object
         */
        supports: {

            /**
             * adownload
             * 
             * @access  public
             * @return  Boolean
             */
            adownload: function() {
                return Modernizr.adownload !== false;
            },

            /**
             * canvas
             * 
             * @access  public
             * @return  Object
             */
            canvas: {

                /**
                 * italic
                 * 
                 * Tests whether the browser supports faux-italic text in canvas
                 * when the font itself does not have an italic version (or else
                 * the italic version has not been loaded into memory).
                 * 
                 * I do this by using the native font Impact, which does not
                 * have a bold or italic version, drawing it to a canvas, and
                 * checking whether anything about the canvas bit-data is
                 * different.
                 * 
                 * @see     http://stackoverflow.com/questions/14489363/detect-bold-and-italic-support
                 * @see     http://stackoverflow.com/questions/15128803/cannot-draw-italic-text-in-firefox-canvas
                 * @access  public
                 * @return  Boolean
                 */
                italic: function() {
                    if (__italic === undefined) {
                        var canvas = document.createElement('canvas'),
                            context = canvas.getContext('2d'),
                            raw = {};
                        canvas.width = 1000;
                        canvas.height = 30;
                        context.font = 'normal 16px impact';
                        context.fillText('string', 10, 20);
                        raw.normal = canvas.toDataURL('image/png');
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        context.font = 'italic 16px impact';
                        context.fillText('string', 10, 20);
                        raw.italic = canvas.toDataURL('image/png');
                        __italic = raw.normal !== raw.italic;
                    }
                    return __italic;
                }
            },

            /**
             * chromeWebstore
             * 
             * @access  public
             * @return  Boolean
             */
            chromeWebstore: function() {
                return 'chrome.webstore'.validObject();
            },

            /**
             * cookies
             * 
             * @access  public
             * @return  Boolean
             */
            cookies: function() {
                return Modernizr.cookies !== false;
            },

            /**
             * css
             * 
             * @access  public
             * @return  Object
             */
            css: {

                /**
                 * scrollbars
                 * 
                 * @access  public
                 * @return  Boolean
                 */
                scrollbars: function() {
                    return Modernizr.cssscrollbar === true;
                }
            },

            /**
             * file
             * 
             * @see     https://modernizr.com/download?filereader-dontmin&q=filere
             * @access  public
             * @return  Boolean
             */
            file: function() {
                return !!(window.File && window.FileList && window.FileReader);
            },

            /**
             * localStorage
             * 
             * @access  public
             * @return  Boolean
             */
            localStorage: function() {
                return Modernizr.localstorage !== false;
            },

            /**
             * woff2
             * 
             * @access  public
             * @return  Boolean
             */
            woff2: function() {
                return supportsWoff2 === true;
            }
        },

        /**
         * valid
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            return Modernizr.cors === true
                && Modernizr.imgcrossorigin === true;
        }
    });
})();

/**
 * ArrayUtils
 * 
 * @abstract
 */
window.ArrayUtils = (function() {

    // Public
    return {

        /**
         * clone
         * 
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        clone: function(arr) {
            if (arr.slice === undefined) {
                var clone = Array.prototype.slice.call(arr);
                return clone
            }
            var clone = arr.slice(0);
            return clone;
        },

        /**
         * contains
         * 
         * @access  public
         * @param   mixed value
         * @param   Array arr
         * @return  Boolean
         */
        contains: function(value, arr) {
            return ArrayUtils.inArray(value, arr) === true;
        },

        /**
         * insertSpacesIntoCamelCase
         * 
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        insertSpacesIntoCamelCase: function(arr) {
            arr = ArrayUtils.clone(arr);
            var index;
            for (index in arr) {
                arr[index] = StringUtils.insertSpacesIntoCamelCase(arr[index]);
            }
            return arr;
        },

        /**
         * inArray
         * 
         * @access  public
         * @param   mixed value
         * @param   Array arr
         * @return  Boolean
         */
        inArray: function(value, arr) {
            var index = jQuery.inArray(value, arr);
            return index !== -1;
        },

        /**
         * last
         * 
         * @access  public
         * @param   Array arr
         * @return  false|mixed
         */
        last: function(arr) {
            var length = arr.length
                index = length - 1;
            if (length === 0) {
                return false;
            }
            var last = arr[index];
            return last;
        },

        /**
         * lowercase
         * 
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        lowercase: function(arr) {
            arr = ArrayUtils.clone(arr);
            var index;
            for (index in arr) {
                arr[index] = arr[index].toLowerCase();
            }
            return arr;
        },

        /**
         * merge
         * 
         * @access  public
         * @return  Array
         */
        merge: function() {
            var arrs = [],
                args = arguments,
                index;
            for (index in args) {
                arrs.push(
                    ArrayUtils.clone(args[index])
                );
            }
            return [].concat.apply([], arrs);
        }
    };
})();

/**
 * ColorUtils
 * 
 * This class is designed to help with color manipulation. The big challenge
 * here is that since starting to use this library, it's disappeared from the
 * internet. So while it's functional now, may want to switch to a new library
 * in the future that is properly documented.
 * 
 * @note    The relevant jquery-minicolors commit (for the current version of
 *          2.1.13) is here:
 *          https://github.com/claviska/jquery-minicolors/commit/17c9dd45b64e0e768c7eeef3108f75b5e76189c9
 *          I'm documenting this here because the /releases page for the repo
 *          doesn't have that version, and I believe at the time (3.5 years
 *          ago), I simply grabbed the source of the library directly from
 *          master (wohoops).
 * @see     https://i.imgur.com/jDDgdL2r.jpg
 * @see     http://cache.preserve.io/5g18q0pw/index.html
 * @abstract
 */
window.ColorUtils = (function() {

    /**
     * getSanitizedColor
     * 
     * Simply returns a Color instance for the passed in color string. I do some
     * light cleanup here because in the past, there were bugs whereby an rgb or
     * rbga color was invalidally formatted/parsed, and resulted in one of the
     * rgba or rgba color values being rendered as an NaN (Not a Number) value.
     * So I strip any of those out, and lowercase it, just to have things
     * standardarized as much as possible.
     * 
     * It's worth noting that on 16 April 2018, I cleaned out the database of
     * image json setting values that have NaN values in them, so this actually
     * shouldn't happen again. But it doesn't hurt to keep this in incase there
     * are formatting/parsing issues in the future.
     * 
     * Additionally: a default Color object representing the color black is set.
     * This is to ensure that if there are any issues parsing a color string, a
     * backup/default color is still returned.
     * 
     * I found that if people entered invalid hex code values (eg. #0z0z0z),
     * the jquery.minicolors widget would still pass that value along. This
     * would result in a failure to parse.
     * 
     * @see     https://i.imgur.com/lyxAUM2.png
     * @see     https://i.imgur.com/UXwU4ed.png
     * @see     https://i.imgur.com/RXrYKel.png
     * @note    Doing some "smart" replacement of hex code values, since I
     *          noticed a couple errors via Sentry. See screenshot below:
     * @see     https://i.imgur.com/3fR0cgs.png
     * @access  private
     * @param   String colorStr
     * @return  Color
     */
    var getSanitizedColor = function(colorStr) {
        if (typeof colorStr !== 'string') {
            colorStr = 'rgba(0, 0, 0, 1)';
        }
        if (colorStr.match(/^#/) !== null) {
            colorStr = colorStr.replace(/o/i, '0');
            colorStr = colorStr.replace(/i/i, '1');
            colorStr = colorStr.replace(/l/i, '1');
            colorStr = colorStr.replace(/s/i, '5');
        }
        colorStr = colorStr.toLowerCase();
        colorStr = colorStr.replace(/NaN/gi, '0');
        var color = pusher.color('rgba(0, 0, 0, 1)');
        try {
            color = pusher.color(colorStr);
        } catch (err) {
        }
        return color;
    };

    // Public
    return {

        /**
         * addSpaces
         * 
         * Formats either an rgb or rgba color to ensure consistent spacing.
         * This is important because it allows standardization between
         * libraries and rgba-sources to ensure conditionals can be written
         * without having to worry about formatting issues.
         * 
         * @access  public
         * @param   String str
         * @return  String
         */
        addSpaces: function(str) {
            return str.replace(/\,([0-9]+)/g, ', $1');
        },

        /**
         * convert
         * 
         * @access  public
         * @param   String colorStr
         * @param   String outputType
         * @param   undefined|Number opacity
         * @return  String
         */
        convert: function(colorStr, outputType, opacity) {
            if (outputType === 'hex') {
                outputType = 'hex6';
            }
            outputType = outputType.toLowerCase();
            var color = getSanitizedColor(colorStr);
            if (opacity !== undefined) {
                color = color.alpha(opacity);
            }
            if (outputType === 'rgb' || outputType === 'rgba') {
                return ColorUtils.addSpaces(
                    color.html(outputType)
                );
            }
            return color.html(outputType).toLowerCase();
        },

        /**
         * getAlpha
         * 
         * @access  public
         * @param   String colorStr
         * @return  Number
         */
        getAlpha: function(colorStr) {
            var color = ColorUtils.getColor(colorStr);
            return color.alpha();
        },

        /**
         * getBlack
         * 
         * @access  public
         * @param   undefined|String outputType (default: 'rgba')
         * @param   undefined|Number opacity (default: 1)
         * @return  String
         */
        getBlack: function(outputType, opacity) {
            outputType = DataUtils.getDefaultValue(outputType, 'rgba');
            opacity = DataUtils.getDefaultValue(opacity, 1);
            return ColorUtils.convert('black', outputType, opacity);
        },

        /**
         * getColor
         * 
         * @access  public
         * @param   String colorStr
         * @return  Color
         */
        getColor: function(colorStr) {
            var color = getSanitizedColor(colorStr);
            return color;
        },

        /**
         * getContrastingColorStr
         * 
         * @access  public
         * @param   String colorStr
         * @param   String outputType
         * @return  String
         */
        getContrastingColorStr: function(colorStr, outputType) {
            var color = getSanitizedColor(colorStr),
                contrastingColor = color.contrastWhiteBlack();
            if (outputType === 'rgb' || outputType === 'rgba') {
                return ColorUtils.addSpaces(
                    contrastingColor.html(outputType)
                );
            }
            return contrastingColor.html(outputType).toLowerCase();
        },

        /**
         * getWhite
         * 
         * @access  public
         * @param   undefined|String outputType (default: 'rgba')
         * @param   undefined|Number opacity (default: 1)
         * @return  String
         */
        getWhite: function(outputType, opacity) {
            outputType = DataUtils.getDefaultValue(outputType, 'rgba');
            opacity = DataUtils.getDefaultValue(opacity, 1);
            return ColorUtils.convert('white', outputType, opacity);
        }
    };
})();

/**
 * DataUtils
 * 
 * @abstract
 */
window.DataUtils = (function() {

    // Public
    return {

        /**
         * clearSelectedText
         * 
         * @see     http://stackoverflow.com/questions/6562727/is-there-a-function-to-deselect-all-text-using-javascript
         * @access  public
         * @return  void
         */
        clearSelectedText: function() {
            window.getSelection().removeAllRanges();
        },

        /**
         * convertDataUrlMime
         * 
         * @access  public
         * @param   String dataUrl
         * @param   String mime
         * @param   Function callback
         * @return  void
         */
        convertDataUrlMime: function(dataUrl, mime, callback) {
            var img = document.createElement('img');
            img.onload = function() {
                var canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d');
                canvas.width = this.width;
                canvas.height = this.height;
                ctx.drawImage(this, 0, 0, this.width, this.height);
                callback(canvas.toDataURL(mime, 1.0));
            };
            img.src = dataUrl;
        },

        /**
         * convertGoogleFontNames
         * 
         * @access  public
         * @param   Array arr
         * @return  Array
         */
        convertGoogleFontNames: function(arr) {
            var index;
            for (index in arr) {
                arr[index] = arr[index].replace(':n4', '');
                arr[index] = arr[index].replace(':n7', ':b');
                arr[index] = arr[index].replace(':i4', ':i');
                arr[index] = arr[index].replace(':i7', ':bi');
            }
            return arr;
        },

        /**
         * dataUrlToBlob
         * 
         * @see     http://stackoverflow.com/questions/4998908/convert-data-uri-to-file-then-append-to-formdata
         * @access  public
         * @param   String dataUrl
         * @return  Blob
         */
        dataUrlToBlob: function(dataUrl) {
            var byteString;
            if (dataUrl.split(',')[0].indexOf('base64') >= 0) {
                byteString = atob(dataUrl.split(',')[1]);
            } else {
                byteString = unescape(dataUrl.split(',')[1]);
            }
            var mimeString = dataUrl.split(',')[0].split(':')[1].split(';')[0],
                ab = new ArrayBuffer(byteString.length),
                ia = new Uint8Array(ab);
            for (var i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            try {
                return new Blob([ab], {type: mimeString});
            } catch (e) {
                var BlobBuilder = window.WebKitBlobBuilder || window.MozBlobBuilder,
                    bb = new BlobBuilder();
                bb.append(ab);
                return bb.getBlob(mimeString);
            }
        },

        /**
         * getBypassedDataTransferObject
         * 
         * This is a helper method to get around browser restrictions that
         * prevent having access to the drag-data. I get around this by encoding
         * data as a string, and then accessing it after. The reason I have to
         * look for the term bypass, is because Safari prepends any data in the
         * <types> property with a seemingly-random string. So I search for this.
         * 
         * If I need more context for this while debugging, console.log the type
         * in both Chrome and Safari to see what I mean, and how things work.
         * 
         * It's important to know that due to how JSON encoding works,
         * case-sensitivity is lost. So be sure that any checks against the
         * return-data is done in lowercase.
         * 
         * @see     http://stackoverflow.com/questions/11065803/determine-what-is-being-dragged-from-dragenter-dragover-events
         * @access  public
         * @param   Object dataTransfer
         * @return  false|Object
         */
        getBypassedDataTransferObject: function(dataTransfer) {
            if (DataUtils.valid(dataTransfer) === false) {
                return false;
            }
            if (DataUtils.valid(dataTransfer.types) === false) {
                return false;
            }
            var type, index;
            for (index in dataTransfer.types) {
                type = dataTransfer.types[index];
                if (type.match(/^bypass/) !== null) {
                    return JSON.parse(type.replace(/^bypass/, ''));
                }
            }
            return false;
        },

        /**
         * getDefaultValue
         * 
         * @access  public
         * @param   undefined|mixed value
         * @param   mixed defaultValue
         * @return  mixed
         */
        getDefaultValue: function(value, defaultValue) {
            if (value === undefined) {
                return defaultValue;
            }
            return value;
        },

        /**
         * getRandomString
         * 
         * @see     http://stackoverflow.com/questions/1349404/generate-a-string-of-5-random-characters-in-javascript
         * @access  public
         * @param   Number length (default: 10)
         * @return  String
         */
        getRandomString: function(length) {
            length = DataUtils.getDefaultValue(length, 10);
            var str = '',
                range = '0123456789abcdefghijklmnopqrstuvwxyz',
                i = 0;
            for (i; i < length; i++) {
                str += range.charAt(Math.floor(Math.random() * range.length));
            }
            return str;
        },

        /**
         * getUrlsAsBlobs
         * 
         * @access  public
         * @param   Array urls
         * @param   Function callback
         * @return  void
         */
        getUrlsAsBlobs: function(urls, callback) {
            Stencil.ajax({
                signature: {file: 'DataUtils', line: 176},
                url: '/utils/proxy',
                data: {
                    urls: urls
                },
                type: 'GET',
                success: function(response) {
                    if (response.success === true) {
                        var blobs = [];
                        for (var index in response.data.files) {
                            var file = response.data.files[index],
                                content = file.content,
                                str = 'data:' + (file.mime) + ';base64,' +
                                    (file.content),
                                blob = DataUtils.dataUrlToBlob(str);
                            blob.name = file.filename;
                            blobs.push(blob);
                        }
                        callback(blobs);
                    } else {
                        callback(false);
                    }
                }
            });
        },

        /**
         * merge
         * 
         * @access  public
         * @return  Object
         */
        merge: function() {
            var objs = arguments,
                args = [true, {}];
            args = ArrayUtils.merge(args, objs);
            return jQuery.extend.apply(jQuery, args);
        },

        /**
         * render
         * 
         * @see     https://stackoverflow.com/questions/5653207/remove-html-comments-with-regex-in-javascript
         * @access  public
         * @param   String view
         * @param   undefined|Object data (default: {})
         * @return  jQuery
         */
        render: function(view, data) {
            data = DataUtils.getDefaultValue(data, {});
            var $script = $('script[name="' + (view) + '"]'),
                markup = $script.html(),
                compiler = _.template(markup),
                rendered = compiler(data).trim(),
                parsed = jQuery.parseHTML(rendered),
                $element = $(parsed);
            return $element;
        },

        /**
         * resizeDataUrl
         * 
         * @see     http://stackoverflow.com/questions/20958078/resize-a-base-64-image-in-javascript-without-using-canvas
         * @see     https://stackoverflow.com/questions/23481210/resize-the-canvas-output-image-to-a-specific-size-width-height
         * @access  public
         * @param   String dataUrl
         * @param   Number width
         * @param   Number height
         * @param   String mime
         * @param   Function callback
         * @return  void
         */
        resizeDataUrl: function(dataUrl, width, height, mime, callback) {
            var img = document.createElement('img');
            img.onload = function() {
                var canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d');
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(this, 0, 0, width, height);
                callback(canvas.toDataURL(mime, 1.0));
            };
            img.src = dataUrl;
        },

        /**
         * valid
         * 
         * @access  public
         * @param   mixed value
         * @return  Boolean
         */
        valid: function(value) {
            if (value === undefined) {
                return false;
            }
            if (value === null) {
                return false;
            }
            return true;
        }
    };
})();

/**
 * DownloadUtils
 * 
 * @abstract
 */
window.DownloadUtils = (function() {

    // Public
    return {

        /**
         * attemptDownload
         * 
         * @access  public
         * @param   String path
         * @param   String cookieKey
         * @return  void
         */
        attemptDownload: function(path, cookieKey) {
            var intervals = {},
                checks = {
                    cookie: function() {
                        if (Cookies.get(cookieKey) !== undefined) {
                            IntervalPool.clear(intervals.cookie);
                            Stencil.cookies.remove(cookieKey);
                            Stencil.set('redirecting', false);
                            Stencil.triggerHandler('redirect/complete');
                        }
                    },
                    connections: function() {
                        if (XHRPool.length() === 0) {
                            IntervalPool.clear(intervals.connections);
                            Stencil.triggerHandler('redirect/start');
                            Stencil.set('redirecting', true);
                            if (
                                (
                                    UserAgent.extension() === true
                                    && UserAgent.hasCSP() === true
                                )
                            ) {
                                window.open(path);
                            } else {
                                window.location.assign(path);
                            }
                            intervals.cookie = checks.cookie.interval(50);
                        }
                    }
                };
            intervals.connections = checks.connections.interval(50);
        }
    };
})();

/**
 * DTUtils
 * 
 * @abstract
 */
window.DTUtils = (function() {

    // Public
    return {

        /**
         * timestampWithin
         * 
         * @access  public
         * @param   Number earlierTimestamp
         * @param   Number laterTimestamp
         * @param   Number range
         * @return  Boolean
         */
        timestampWithin: function(earlierTimestamp, laterTimestamp, range) {
            return (laterTimestamp - earlierTimestamp) <= range;
        }
    };
})();

/**
 * ElectronUtils
 * 
 * @abstract
 */
window.ElectronUtils = (function() {

    /**
     * __getRandomString
     * 
     * @access  private
     * @return  String
     */
    var __getRandomString = function() {
        return DataUtils.getRandomString();
    };

    // Public
    return {

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  Promise
         */
        get: function(key) {
            return new Promise(function(resolve, reject) {
                var signature = __getRandomString(),
                    requestObj = {
                        action: 'get',
                        key: key,
                        signature: signature
                    };
                if ('window.electron'.validObject() === true) {
                    window.electron.ipcRenderer.once(function(obj) {
                        if (obj.requestObj.signature === requestObj.signature) {
                            if (obj.success === true) {
                                resolve(obj.data);
                            } else {
                                var msg = obj.errors[0].message,
                                    err = new Error(msg);
                                reject(err);
                            }
                        }
                    });
                    window.electron.ipcRenderer.send(requestObj);
                } else {
                    var msg = 'window.electron is not valid',
                        err = new Error(msg);
                    reject(err);
                }
            });
        }
    };
})();

/**
 * JSONUtils
 * 
 * @abstract
 */
window.JSONUtils = (function() {

    // Public
    return {

        /**
         * valid
         * 
         * @access  public
         * @param   String str
         * @return  Boolean
         */
        valid: function(str) {
            try {
                JSON.parse(str);
                return true;
            } catch(e) {}
            return false;
        }
    };
})();

/**
 * LogUtils
 * 
 * Notice that I check for alwaysLog first. This is partially to
 * accommodate the case where a call to /import fails. In that case,
 * it is likely that the config file will not be availble, and thus
 * the next check will fail. This should probably be more elegant.
 * 
 * @abstract
 */
window.LogUtils = (function() {

    /**
     * __colors
     * 
     * @see     http://www.w3schools.com/cssref/css_colornames.asp
     * @access  private
     * @var     Object
     */
    var __colors = {
        'classTypes' : {
            'accessor':     'orange',
            'account':      'green',
            'collection':   'red',
            'drawing':      'blueviolet',
            'layer':        'cadetblue',
            'model':        'brown',
            'router':       'purple',
            'stencil':      'chocolate',
            'user':         'darkolivegreen',
            'view':         'blue'
        },
        'simple':   'crimson'
    };

    /**
     * __counter
     * 
     * @access  private
     * @var     Number (default: 0)
     */
    var __counter = 0;

    /**
     * __format
     * 
     * @access  private
     * @param   String msg
     * @param   String type
     * @param   String label
     * @return  Array
     */
    var __format = function(msg, type, label) {
        var color = __getColor(type),
            timestamp = __getTimestamp(),
            msgs = [];
        msgs.push('%c' + (timestamp) + '  ' + (label));
        msgs.push('color:' + (color) + ';');
        msgs.push(msg);
        return msgs;
    };

    /**
     * __getColor
     * 
     * @access  private
     * @param   String type
     * @return  String
     */
    var __getColor = function(type) {
        if (__colors.classTypes[type] !== undefined) {
            var color = __colors.classTypes[type];
            return color;
        }
        var color = __colors.simple;
        return color;
    };

    /**
     * __getTimestamp
     * 
     * Returns a string which represents the timestamp, up to the microsecond.
     * 
     * @access  private
     * @return  String
     */
    var __getTimestamp = function() {
        var timestamp = moment().format('HH:mm:ss (0.SSSS)');
        return timestamp;
    };

    /**
     * __log
     * 
     * @access  private
     * @return  Boolean
     */
    var __log = function() {
        if (__loggingEnable() === true) {
            return true;
        }
        var account = Stencil.account();
        if (account === undefined) {
            return false;
        }
        if (account.userAccount() === undefined) {
            return false;
        }
        if (account.userAccount().setting('logging').toInt() === 1) {
            return true;
        }
        return false;
    };

    /**
     * __loggingEnable
     * 
     * @access  private
     * @return  Boolean
     */
    var __loggingEnable = function() {
        var ready = Config.ready();
        if (ready === false) {
            return false;
        }
        var enabled = Config.default('logging');
        return enabled;
    };

    /**
     * __writeToConsole
     * 
     * @access  private
     * @param   Array arr
     * @return  void
     */
    var __writeToConsole = function(arr) {
        if (window.console !== undefined) {
            if (window.console.log !== undefined) {
                window.console.log.apply(window.console, arr);
                ++__counter;
            }
        }
    };

    // Public
    return {

        /**
         * log
         * 
         * @access  public
         * @var     Object
         */
        log: {

            /**
             * object
             * 
             * @access  public
             * @param   Object obj
             * @param   undefined|String msg (default: '(no message)')
             * @param   undefined|Boolean override (default: false)
             * @return  void
             */
            object: function(obj, msg, override) {
                msg = DataUtils.getDefaultValue(msg, '(no message)');
                override = DataUtils.getDefaultValue(override, false);
                if (__log() === true || override === true) {
                    var classType = obj.getClassType(),
                        label = obj.toString();
                    msg = __format(msg, classType, label);
                    __writeToConsole(msg);
                }
            },

            /**
             * simple
             * 
             * @access  public
             * @param   undefined|String msg (default: '(no message)')
             * @param   undefined|Boolean override (default: false)
             * @return  void
             */
            simple: function(msg, override) {
                msg = DataUtils.getDefaultValue(msg, '(no message)');
                override = DataUtils.getDefaultValue(override, false);
                if (__log() === true || override === true) {
                    msg = __format(msg, 'simple', 'Simple');
                    __writeToConsole(msg);
                }
            }
        }
    };
})();

/**
 * StatUtils
 * 
 * @abstract
 */
window.StatUtils = (function() {

    // Public
    return {

        /**
         * getAlgoliaQuotesCount
         * 
         * @access  public
         * @return  String
         */
        getAlgoliaQuotesCount: function() {
            return Config.get('algolia').total.commas();
        },

        /**
         * getPhotoPartnerImageCount
         * 
         * @access  public
         * @return  String
         */
        getPhotoPartnerImageCount: function() {
            var gateway = Config.default('photoSearchDefaultGateway'),
                range = Config.default('photoSearchRange');
            gateway = gateway.toLowerCase();
            if (range === 'single') {
                return Config.get(gateway).total.commas();
            }
            var total = Config.get('pixabay').total + Config.get('pexels').total;
            return total.commas();
        }
    };
})();

/**
 * StringUtils
 * 
 * @abstract
 */
window.StringUtils = (function() {

    /**
     * __accentSets
     * 
     * @access  public
     * @var     Object
     */
    var __accentSets = [
        {to: 'a', from: '[]'},
        {to: 'c', from: '[]'},
        {to: 'd', from: '[]'},
        {to: 'e', from: '[]'},
        {to: 'g', from: '[]'},
        {to: 'h', from: '[]'},
        {to: 'i', from: '[]'},
        {to: 'j', from: '[]'},
        {to: 'ij', from: '[]'},
        {to: 'k', from: '[]'},
        {to: 'l', from: '[]'},
        {to: 'm', from: '[]'},
        {to: 'n', from: '[]'},
        {to: 'o', from: '[]'},
        {to: 'oe', from: '[]'},
        {to: 'p', from: '[]'},
        {to: 'r', from: '[]'},
        {to: 's', from: '[]'},
        {to: 't', from: '[]'},
        {to: 'u', from: '[]'},
        {to: 'w', from: '[]'},
        {to: 'x', from: '[]'},
        {to: 'y', from: '[]'},
        {to: 'z', from: '[]'},
        {to: '-', from: '[/_,:;\']'}
    ];

    // Public
    return {

        /**
         * getHash
         * 
         * Simple hashing algorithm so I can hash strings and compare them to
         * one another to determine if anything's changed.
         * 
         * @note    The escape call needs to be used to prevent issues with
         *          unicode characters throwing issues within the md5 function.
         *          Specifically, the md5 vendor library makes use of
         *          encodeURIComponent, and when certain characters
         *          (eg. '\uD800') are passed in, it bails with a URIError:
         *          https://i.imgur.com/JGlAFZi.jpg
         *          Calling escape will convert non-alphan-numeric characters to
         *          "safe" characters, which prevents the issues seen above.
         * @see     https://i.imgur.com/JGlAFZi.jpg
         * @see     https://stackoverflow.com/questions/2670037/how-to-remove-invalid-utf-8-characters-from-a-javascript-string
         * @see     https://github.com/tc39/ecma262/issues/944
         * @see     https://github.com/blueimp/JavaScript-MD5
         * @see     https://stackoverflow.com/a/7616484/115025
         * @access  public
         * @param   String str
         * @return  String
         */
        getHash: function(str) {
            str = escape(str);
            var hash = md5(str);
            return hash;
        },

        /**
         * insertSpacesIntoCamelCase
         * 
         * @access  public
         * @param   String str
         * @return  str
         */
        insertSpacesIntoCamelCase: function(str) {
            var spaced = str.replace(/([A-Z])/g, ' $1').trim();
            return spaced;
        },

        /**
         * slugify
         * 
         * @see     https://gist.github.com/mathewbyrne/1280286
         * @access  public
         * @param   String str
         * @param   Number limit
         * @return  String
         */
        slugify: function(str, limit) {
            var index, set, regExp;
            for (index in __accentSets) {
                set = __accentSets[index];
                regExp = new RegExp(set.from, 'gi');
                str = str.replace(regExp, set.to);
            }
            limit = limit.toInt();
            str = str.trim();
            str = str.toLowerCase();
            str = str.replace(/'/g, '');
            str = str.replace(/&amp;/g, '&');
            str = str.replace(/&/g, '-and-');
            str = str.replace(/[^a-zA-Z0-9-]/g, ' ');
            str = str.replace(/-/g, ' ');
            str = str.replace(/[\s]{2,}/g, ' ');
            str = str.trim();
            str = str.replace(/ /g, '-');
            str = str.slice(0, limit);
            return str;
        },

        /**
         * url
         * 
         * @access  public
         * @param   String str
         * @return  Boolean
         */
        url: function(str) {
            if (str.match(/^http[s]?\:\/\//) === null) {
                return false;
            }
            return true;
        }
    };
})();
StencilBooter.queue.push(StencilBooter.requires('Base', function() {

    /**
     * Drawing
     * 
     * @events  change/angle
     *          change/position
     *          change/scale
     * @extends Base
     */
    window.Drawing = Base.extend({

        /**
         * _boxInRatio
         * 
         * @access  protected
         * @var     Number (default: 0.25)
         */
        _boxInRatio: 0.25,

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'drawing')
         */
        _classType: 'drawing',

        /**
         * _cotton
         * 
         * @access  protected
         * @var     null|fabric.Object (default: null)
         */
        _cotton: null,

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _layer
         * 
         * @access  protected
         * @var     Layer (default: null)
         */
        _layer: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return {
                'change/position': function() {
                    this._layer.on({
                        'change/position': function(event, position) {
                            var objects = this.getCanvas().getCotton().getObjects();
                            jQuery.each(objects, function(index, object) {
                                object.setCoords();
                            });
                        }
                    });
                },
                'delete': function() {
                    this._layer.on({
                        'delete': function(event) {
                            if (this._drawing.drawn() === true) {
                                var cotton = this.getCotton(),
                                    drawing = this._drawing;
                                drawing.magnets.demagnetize.apply(drawing);
                                    // backdrop = cotton.backdrop;
                                // if (backdrop !== undefined) {
                                    // cotton.clearBackdrop();
                                // }
                                cotton.remove();
                                Toolbars.hide();
                            }
                        }
                    });
                },
                'flip': function() {
                    this._layer.on({
                        'flip/x': function(event, flip) {
                            var cotton = this.getCotton();
                            cotton.setFlipX(flip);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'flip/y': function(event, flip) {
                            var cotton = this.getCotton();
                            cotton.setFlipY(flip);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                },

                /**
                 * Nudging
                 * 
                 */
                'move': function() {
                    this._layer.on({
                        'move/up': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/right': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/down': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        },
                        'move/left': function(event) {
                            this.setChangeOperationType('nudged');
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                },
                'order': function() {
                    this._layer.on({
                        'change/order': function(event, forward) {
                            this.getCanvas().render();
                        }
                    });
                },
                'position': function() {
                    this._layer.on({
                        'position/restored': function(event) {

                            // Top
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                top = drawing.relative.top.apply(drawing);
                            cotton.setTop(top);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();

                            // Left
                            cotton = this.getCotton();
                            drawing = this._drawing;
                            left = drawing.relative.left.apply(drawing);
                            cotton.setLeft(left);
                            cotton.setCoords();
                            this.triggerHandler('refresh/dimensions');
                            // cotton.trigger('changed');
                            this.getCanvas().render();
                        }
                    });
                }
            };
        },

        /**
         * _outline
         * 
         * @access  protected
         * @var     fabric.Rect (default: null)
         */
        _outline: null,

        /**
         * _rotateIconPath
         * 
         * @access  protected
         * @var     String (default: '/app/static/images/icons/rotate.v3.small.png')
         */
        _rotateIconPath: '/app/static/images/icons/rotate.v3.small.png',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Drawing')
         */
        _string: 'Drawing',

        /**
         * init
         * 
         * @access  public
         * @param   Layer layer
         * @return  void
         */
        init: function(layer) {
            this._super();
            this._layer = layer;
            this._preloadRotateIcon();
            this._setupListeners();
            this.magnets = this.magnets();
            this.relative = this.relative();
        },

        /**
         * _addBoxInListeners
         * 
         * Ensures that when an object is boxed in, it's left / top coordinates
         * are properly set.
         * 
         * @access  protected
         * @return  void
         */
        _addBoxInListeners: function() {
            this._cotton.on({
                'boxedIn': function(options) {
                    this.trigger('moving/manual');
                }
            });
        },

        /**
         * _addMoveListeners
         * 
         * Returns a 2-decimal-place position coordinate (left/top).
         * 
         * @note    The image property check, and the deleted property check,
         *          are performed to ensure that after a layer has been
         *          "deleted", we don't keep tracking (and triggered) background
         *          position changes.
         * @access  protected
         * @return  void
         */
        _addMoveListeners: function() {
            var _this = this,
                closure = function(options) {
                    if (_this._layer.toString() == 'BackgroundBitmapImageLayer') {
                        var image = _this._layer.getProperty('image');
                        if (image !== false) {
                            var position = {
                                left: (this.getRelativeLeft() * 100).round(4),
                                top: (this.getRelativeTop() * 100).round(4)
                            };
                            _this._layer.triggerHandler('change/position', [position]);
                        }
                    } else {
                        if (_this._layer.get('deleted') !== true) {
                            var position = {
                                left: (this.getRelativeLeft() * 100).round(4),
                                top: (this.getRelativeTop() * 100).round(4)
                            };
                            _this._layer.triggerHandler('change/position', [position]);
                        }
                    }
                };
            this._cotton.on({
                'moving': closure.proxy(this._cotton),
                'moving/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addRotateListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRotateListeners: function() {
            var _this = this,
                closure = function(event) {
                    var angle = this.getAngle().round(4);
                    _this._layer.triggerHandler('change/angle', [angle]);
                };
            this._cotton.on({
                'rotating': closure.proxy(this._cotton),
                'rotating/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addSnapListeners
         * 
         * Listens for snap events on the fabric object to ensure that the saved
         * top / left value is exactly the magnet-value. Without this listener,
         * the drawing would appear to snap, but once saved, the value would be
         * off. It'd also affect keyboard-shortcut nudging, since the
         * layer-stored left/top value wouldn't be the actual value that is seen
         * in the canvas/UI.
         * 
         * The same applies to snap / angle
         * 
         * @access  protected
         * @return  void
         */
        _addSnapListeners: function() {
            this._cotton.on({
                'snap/angle': function(options) {
                    this.trigger('rotating/manual');
                },
                'snap/position': function(options) {
                    this.trigger('moving/manual');
                },
                'snap/scale': function(options) {
                    this.trigger('scaling/manual');
                }
            });
        },

        /**
         * _getContrastingColor
         * 
         * @access  protected
         * @param   String colorStr
         * @return  String either black or white as an rgb string
         */
        _getContrastingColor: function(colorStr) {
            return ColorUtils.getContrastingColorStr(
                colorStr,
                'rgb'
            );
        },

        /**
         * _getDefaults
         * 
         * Worth noting is that the only time the originX or originY values will
         * not be set to center is in the case of a TextLayer in a legacy image.
         * This is because positioning was determined by the top + left
         * coordinate rather than center-point. If this is ever the case, right
         * after drawing the text will be converted to be use the center +
         * center origin.
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaults: function() {
            var white = ColorUtils.getWhite('rgba'),
                black = ColorUtils.getBlack('rgba');
            return {
                stencilCornerFillColor: white,
                stencilCornerStrokeColor: black,
                stencilBorderColor1: black,
                stencilBorderColor2: white,
                stencilRotatingPointColor1: black,
                stencilRotatingPointColor2: white,
                // perPixelTargetFind: true,
                borderColor: black,
                cornerSize: UserAgent.is.tablet() === true ? 30 : 12,
                hasRotatingPoint: false,
                padding: UserAgent.is.tablet() === true ? 10 : 0,
                originX: 'center',
                originY: 'center',
                rotatingPointOffset: 20,
                transparentCorners: false,
                lockSkewingX: true,
                lockSkewingY: true
            };
        },

        /**
         * _preloadRotateIcon
         * 
         * @access  protected
         * @return  void
         */
        _preloadRotateIcon: function() {
            var rotateIconPreloaded = Stencil.get('rotateIconPreloaded');
            if (rotateIconPreloaded !== true) {
                var url = STATIC + this._rotateIconPath,
                    image = new Image();
                Stencil.set('rotateIconPreloaded', true);
                image.crossOrigin = 'anonymous';
                image.onload = function() {
                    Stencil.set('rotateIconImageReference', this);
                };
                image.src = url;
            }
        },

        /**
         * _setupListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupListeners: function() {
            var _this = this;
            this._listeners = this._listeners();
            jQuery.each(
                this._listeners,
                function(type, listener) {
                    listener.apply(_this);
                }
            );
        },

        /**
         * _setupOutline
         * 
         * @access  protected
         * @return  void
         */
        _setupOutline: function() {
            if (
                this.magnets.highlight === true
                && this.getCanvas() !== Canvases.Ghost
            ) {
                var cottons = {
                    centers: {
                        top: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        right: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        bottom: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        }),
                        left: new fabric.Circle({
                            selectable: false,
                            visible: false,
                            fill: 'rgba(255, 0, 0, 1)',
                            left: 0,
                            radius: 2.5
                        })
                    },
                    red: new fabric.Rect({
                        selectable: false,
                        visible: false,
                        stroke: 'rgba(255, 0, 0, 1)',
                        strokeDashArray: [5, 5],
                        strokeWidth: 1,
                        fill: ColorUtils.getBlack('rgba', 0),
                        left: 200,
                        top: 200,
                        width: 50,
                        height: 50
                    }),
                    white: new fabric.Rect({
                        selectable: false,
                        visible: false,
                        stroke: ColorUtils.getWhite('rgba'),
                        strokeDashArray: [0, 5, 5, 0],
                        strokeWidth: 1,
                        fill: ColorUtils.getBlack('rgba', 0),
                        left: 200,
                        top: 200,
                        width: 50,
                        height: 50
                    })
                };
                this.getCanvas().getCotton().add(cottons.centers.top);
                this.getCanvas().getCotton().add(cottons.centers.right);
                this.getCanvas().getCotton().add(cottons.centers.bottom);
                this.getCanvas().getCotton().add(cottons.centers.left);
                this.getCanvas().getCotton().add(cottons.red);
                this.getCanvas().getCotton().add(cottons.white);
                this._outline = cottons;

                /** 
                 * resize
                 * 
                 * Moves the outline and center points to the relevant positions
                 * for a drawing.
                 * 
                 * @access  private
                 * @return  void
                 */
                var resize = function() {

                    // Reposition centers
                    this.setCoords();
                    var bounding = this.getBoundingRect();
                    cottons.centers.top.set({
                        left: bounding.left + (bounding.width / 2).round(0) - 2 - 1 - 0.5,
                        top: bounding.top - 2
                    });
                    cottons.centers.right.set({
                        left: bounding.left + bounding.width - 2,
                        top: bounding.top + (bounding.height / 2).round(0) - 2
                    });
                    cottons.centers.bottom.set({
                        left: bounding.left + (bounding.width / 2).round(0) - 2 - 1 - 0.5,
                        top: bounding.top + bounding.height - 2
                    });
                    cottons.centers.left.set({
                        left: bounding.left - 2,
                        top: bounding.top + (bounding.height / 2).round(0) - 2
                    });

                    // Reposition borders
                    cottons.red.set({
                        left: bounding.left,
                        top: bounding.top,
                        width: bounding.width,
                        height: bounding.height
                    });
                    cottons.white.set({
                        left: bounding.left,
                        top: bounding.top,
                        width: bounding.width,
                        height: bounding.height
                    });
                };
                this.on({
                    'refresh': function(event) {
                        resize.apply(this._cotton);
                    }
                });
                this._cotton.on({
                    'changed': resize.proxy(this._cotton),
                    'removed': function() {
                        cottons.centers.top.remove();
                        cottons.centers.right.remove();
                        cottons.centers.bottom.remove();
                        cottons.centers.left.remove();
                        cottons.red.remove();
                        cottons.white.remove();
                    },
                    'moving': resize.proxy(this._cotton),
                    'resize/outline': resize.proxy(this._cotton),
                    'rotating': resize.proxy(this._cotton),
                    'scaling': resize.proxy(this._cotton)
                });
                this._layer.on({
                    'refresh/dimensions': resize.proxy(this._cotton)
                });
                this._cotton.canvas.on({
                    'mouse:move': function() {
                        cottons.centers.top.set('visible', false);
                        cottons.centers.right.set('visible', false);
                        cottons.centers.bottom.set('visible', false);
                        cottons.centers.left.set('visible', false);
                        cottons.red.set('visible', false);
                        cottons.white.set('visible', false);
                    }
                });
                resize.apply(this._cotton);
            }
        },

        /**
         * autoAlign
         * 
         * Centers the drawing both vertically and horizontally in the canvas.
         * Then triggers the appropriate style changes in the Layer to ensure
         * it's properly saved.
         * 
         * @access  public
         * @return  void
         */
        autoAlign: function() {
            var backgroundRectangleLayer = Canvases.Preview.getBackgroundRectangleLayer(),
                boundingRect = backgroundRectangleLayer.getCotton().getBoundingRect(),
                middlePoint = {
                    x: boundingRect.width / 2,
                    y: boundingRect.height / 2
                };
            this._cotton.set({
                left: middlePoint.x,
                top: middlePoint.y
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    left: ((middlePoint.x * 100) / dimensions.width).round(4),
                    top: ((middlePoint.y * 100) / dimensions.height).round(4)
                };
            this._layer.setStyles(relative);
            Canvases.Preview.render();
            this.triggerHandler('refresh');
        },

        /**
         * bb
         * 
         * Bounding box controls.
         * 
         * @todo!   Look into whether this is needed
         * @access  public
         * @var     Object
         */
        bb: {

            /**
             * hide
             * 
             * @access  public
             * @return  Drawing
             */
            hide: function() {
                var type = this._string;
                if (type === 'BackgroundRectangleDrawing') {
                    return this;
                }
                this._cotton.hasBorders = false;
                this._cotton.hasControls = false;
                this._cotton.hasRotatingPoint = false;
                this._cotton.canvas.renderAll();
                return this;
            },

            /**
             * show
             * 
             * @access  public
             * @return  Drawing
             */
            show: function() {
                var type = this._string;
                if (type === 'BackgroundRectangleDrawing') {
                    return this;
                }
                this._cotton.hasBorders = true;
                this._cotton.hasControls = true;
                this._cotton.hasRotatingPoint = true;
                this._cotton.canvas.renderAll();
                return this;
            }
        },

        /**
         * drawn
         * 
         * @access  public
         * @return  Boolean
         */
        drawn: function() {
            return this._drawn === true;
        },

        /**
         * getCanvas
         * 
         * @access  public
         * @return  CanvasView
         */
        getCanvas: function() {
            return this._layer.getCanvas();
        },

        /**
         * getCotton
         * 
         * @access  public
         * @return  fabric.Object
         */
        getCotton: function() {
            return this._cotton;
        },

        /**
         * getLayer
         * 
         * @access  public
         * @return  Layer
         */
        getLayer: function() {
            return this._layer;
        },

        /**
         * getOutline
         * 
         * @access  public
         * @return  null|Object
         */
        getOutline: function() {
            return this._outline;
        },

        /**
         * highlight
         * 
         * @access  public
         * @param   Object options
         * @return  void
         */
        highlight: function(options) {
            if (this.magnets.highlight === true) {
                this._outline.red.setVisible(true);
                this._outline.white.setVisible(true);
                if (Account.highlightCenterGuidesOnSnap() === true) {
                    if (options.showHorizontalLineCenters === true) {
                        this._outline.centers.top.setVisible(true);
                        this._outline.centers.bottom.setVisible(true);
                    } else if (options.showVerticalLineCenters === true) {
                        this._outline.centers.right.setVisible(true);
                        this._outline.centers.left.setVisible(true);
                    }
                }
            }
        },

        /**
         * magnets
         * 
         * Wrapper object for magnet-related functions. Ensure that the proper
         * context is defined against functions called within this object.
         * 
         * @access  public
         * @var     Function
         */
        magnets: function() {
            return {

                /**
                 * angles
                 * 
                 * Magnetizes a drawing to 45-degree angles so long as the
                 * canvas is not a Ghost (useless there).
                 * 
                 * @access  protected
                 * @return  void
                 */
                angles: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        var threshold = this.magnets.thresholds.rotating;
                        this._cotton.snapToAngleOnRotate(
                            threshold.angle,
                            threshold.pixels
                        );
                    }
                },

                /**
                 * demagnetize
                 * 
                 * Demagnetizes a drawing by removing it from the array of
                 * drawings stored within the canvas fabric object.
                 * Demagnetizing prevents other drawings from snapping to it.
                 * 
                 * @access  protected
                 * @return  void
                 */
                demagnetize: function() {
                    var _this = this,
                        drawings = this._cotton.canvas.magnets.drawings;
                    jQuery.each(drawings, function(index, drawing) {
                        if (drawing === _this) {
                            drawings.splice(index, 1);
                        }
                    });
                },

                /**
                 * highlight
                 * 
                 * @access  protected
                 * @var     Boolean (default: true)
                 */
                highlight: true,

                /**
                 * inbound
                 * 
                 * Ensures other drawings can be snapped to this one by adding
                 * the drawing to the array of drawings stored within the canvas
                 * fabric object. A check between the current and ghost canvas
                 * is made to ensure drawings that are temporary (eg. created
                 * during the ghost rendering process) are not added, since
                 * there's no point for those to be magnetized (and doing so
                 * causes issues since those drawings are never formally
                 * deleted, which results in drawings not available in the
                 * preview canvas being snapped to).
                 * 
                 * @access  protected
                 * @return  void
                 */
                inbound: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        this._setupOutline();
                        this._cotton.canvas.magnets.drawings.push(this);
                    }
                },

                /**
                 * outbound
                 * 
                 * Ensures the drawing can be snapped to other drawings by
                 * adding listeners on the fabric object. A check is made
                 * between the current ghost canvas to prevent adding the events
                 * when it's the ghost canvas being rendered. Not useful there.
                 * 
                 * @access  protected
                 * @return  void
                 */
                outbound: function() {
                    if (this.getCanvas() !== Canvases.Ghost) {
                        var snapToDrawingsOnScale = Config.default('snapToDrawingsOnScale');
                        this._cotton.snapToDrawingsOnMove();
                        if (snapToDrawingsOnScale === true) {
                            this._cotton.snapToDrawingsOnScale();
                        }
                    }
                },

                /**
                 * thresholds
                 * 
                 * @note    Order here reflects how I visualize them in my head,
                 *          rather than alphabetically.
                 * @access  protected
                 * @var     Object
                 */
                thresholds: {
                    moving: {
                        pixels: {
                            horizontal: {
                                centerToCenter: 6,
                                // centerToLeft: 6
                                // centerToRight: 6,

                                leftToCenter: 6,// Helpful for collages
                                leftToLeft: 6,
                                leftToRight: 6,

                                rightToCenter: 6,// Helpful for collages
                                rightToLeft: 6,
                                rightToRight: 6
                            },
                            vertical: {
                                centerToCenter: 6,
                                // centerToTop: 6,
                                // centerToBottom: 6,

                                topToCenter: 6,// Helpful for collages
                                topToTop: 6,
                                topToBottom: 6,

                                bottomToCenter: 6,// Helpful for collages
                                bottomToTop: 6,
                                bottomToBottom: 6
                            }
                        }
                    },
                    rotating: {
                        angle: 45,
                        pixels: 5
                    },
                    scaling: {
                        pixels: 6
                    }
                }
            };
        },

        /**
         * relative
         * 
         * @access  protected
         * @var     Function
         */
        relative: function() {
            return {

                /**
                 * left
                 * 
                 * @access  public
                 * @return  Number
                 */
                left: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('left').toFloat() / 100,
                        pixels = (dimensions.width * percentage).round(4);
                    return pixels;
                },

                /**
                 * top
                 * 
                 * @access  public
                 * @return  Number
                 */
                top: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('top').toFloat() / 100,
                        pixels = (dimensions.height * percentage).round(4);
                    return pixels;
                },

                /**
                 * width
                 * 
                 * @access  public
                 * @return  Number
                 */
                width: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('width').toFloat() / 100,
                        pixels = (dimensions.width * percentage).round(4);
                    return pixels;
                }
            };
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            this.getCanvas().getCotton().setActiveObject(this._cotton);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageDrawing', function() {

    /**
     * BackgroundBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.BackgroundBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundBitmapImageDrawing')
         */
        _string: 'BackgroundBitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   BackgroundBitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addFiltersListeners();
            this._addMoveListeners();
            this._addSelectListeners();
            this._addSnapListeners();
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    Toolbars.show('backgroundBitmapImage');
                }
            });
        },

        /**
         * _getDefaults
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaults: function() {
            var defaults = {
                hasBorders: false,
                hasControls: false,
                padding: 0
            };
            return jQuery.extend({}, this._super(), defaults);
        },

        /**
         * _getInvisibleImage
         * 
         * @access  protected
         * @return  String
         */
        _getInvisibleImage: function() {
            return (window.STATIC) + '/app/static/images/invisible.png';
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    flipX: layer.getStyle('flipX') === true,
                    flipY: layer.getStyle('flipY') === true,
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    zoom: layer.getStyle('zoom')
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _getUrl
         * 
         * Attempts to load the image url for this layer, based on the image
         * property. If no image property defined (aka. false), or else it
         * points to a resource accessor that isn't in memory (can happen if
         * they switch to a resource, the image configuration gets saved, and
         * then they reload the page before the resource has been converted to
         * an asset), false is returned.
         * 
         * @access  protected
         * @return  false|String
         */
        _getUrl: function() {

            /**
             * No image defined in the layer, so send back false (which will
             * result in the empty image being drawn, and hidden).
             */
            var key = this._layer.getProperty('image');
            if (key === false) {
                return false;
            }

            /**
             * See Images.js for detailed documentation on the <getFrameUrl>
             * method. In short, it attempts to determine the ideal URL to use,
             * given the canvas' width / height.
             */
            if (key.match(/^asst/) !== null || key.match(/^upld/) !== null) {
                return Images.getFrameUrl(key, this.getCanvas());
            }

            /**
             * Not an asset or upload record; this ought to mean it's a
             * resource. Check if it's in memory. If it's not, then it's likely
             * an invalid pointer to a 3rd-party resource that for some reason
             * did not get converted to an asset.
             * 
             * Otherwise, send back the small version of the 3rd-party resource.
             */
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                return false;
            }
            return accessor.url('small');
        },

        /**
         * _loadInvisibleImage
         * 
         * Loads the backup invisible (1px by 1px) image, to be used when either
         * no image is set in the layer, or else one of the urls failed when
         * loading.
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _loadInvisibleImage: function(callback) {
            var preload = new Image();
            preload.crossOrigin = 'anonymous';
            preload.onload = function() {
                callback(this);
            };
            preload.onerror = function() {
                var code = 'bbi262',
                    reference = 'backgroundBitmapImage';
                Stencil.error(code, reference);
            };
            preload.src = this._getInvisibleImage();
        },

        /**
         * _loadImage
         * 
         * Attempts to load the image for this layer. If no image is explicitly
         * defined, callback is passed an image object, but with visible set to
         * false to ensure it's hidden.
         * 
         * @note    Cloudinary bails when half-pixel width / height values are
         *          passed in, so I always round up (<ceil> call). Not sure
         *          eactly how this affects scrubbing.
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _loadImage: function(callback) {

            /** 
             * Grab the url for the image to load. If no valid image found (can
             * happen when no image was selected, or else referencing an invalid
             * 3rd-party resource), then substitute the invisible image, and 
             * mark the image as not-visible.
             */
            var _this = this,
                key = this._layer.getProperty('image'),
                url = this._getUrl();

            // An image was found
            if (url !== false) {

                // Preload the image
                var preload = new Image();
                preload.crossOrigin = 'anonymous';
                preload.onload = function() {
                    var dimensions = _this.getCanvas().getRenderedDimensions(),
                        secondary;

                    /**
                     * If the layer's image is an asset or upload, attempts to
                     * load the proper dimensioned-version of it, at the exact
                     * desired width / height scale.
                     */
                    if (
                        key.match(/^asst/) !== null
                        || key.match(/^upld/) !== null
                    ) {
                        /**
                         * This is making use of Cloudinary's new API feature to
                         * dynamically resize to a minimum width or height
                         * depending on the aspect ratio of the original image
                         * (and by comparing that aspect ratio to the selected
                         * Frame).
                         * 
                         * If you need to revert, see the following commit:
                         * dacd90d55129ea8017bfe76abb58fbb6631ebc31
                         */
                        secondary = Images.getFrameUrl(key, _this.getCanvas());

                        // Load image, and pass it to the callback
                        preload = new Image();
                        preload.crossOrigin = 'anonymous';
                        preload.onload = function() {
                            callback({
                                image: this,
                                visible: true
                            });
                        };
                        preload.onerror = function() {
                            _this._loadInvisibleImage(function(image) {
                                callback({
                                    image: image,
                                    visible: false
                                });
                            });
                        };
                        preload.src = secondary;
                    }
                    /**
                     * Otherwise, the image must be a 3rd-party resource (eg.
                     * Pixabay). In that case, we load the small version of the
                     * resource (regardless of which dimension).
                     */
                    else {
                        var accessor = Stencil.getAccessor(key);
                        secondary = accessor.url('small');
                        preload = new Image();
                        preload.crossOrigin = 'anonymous';
                        preload.onload = function() {
                            callback({
                                image: this,
                                visible: true
                            });
                        };
                        preload.onerror = function() {
                            _this._loadInvisibleImage(function(image) {
                                callback({
                                    image: image,
                                    visible: false
                                });
                            });
                        };
                        preload.src = secondary;
                    }
                };
                preload.onerror = function() {
                    _this._loadInvisibleImage(function(image) {
                        callback({
                            image: image,
                            visible: false
                        });
                    });
                };
                preload.src = url;
            }
            // No image found
            else {
                this._loadInvisibleImage(function(image) {
                    callback({
                        image: image,
                        visible: false
                    });
                });
            }
        },

        /**
         * _resize
         * 
         * Notice that the resize event (and the property value) isn't triggered
         * until after the canvas itself has been rendered. This is to ensure
         * that any filters set against the image have been processed.
         * 
         * @see     https://i.imgur.com/eOpBX73.png
         * @access  protected
         * @return  void
         */
        _resize: function() {
            this.triggerHandler('resize/start');
            var _this = this;
            this._resizing = true;
            this._loadImage(function(response) {
                _this._cotton.setElement(
                    response.image,
                    function() {
                        _this._cotton.setCoords();
                        _this._scaleToFrame();
                        _this.getCanvas().once({
                            'render': function(event) {
                                _this._resizing = false;
                                _this.triggerHandler('resize/complete');
                            }
                        });
                        _this.getCanvas().render();
                    }
                );
            });
        },

        /**
         * _scaleToFrame
         * 
         * @access  protected
         * @return  void
         */
        _scaleToFrame: function() {
            var dimensions = this.getCanvas().getRenderedDimensions(),
                ratio = this._cotton.width / this._cotton.height,
                zoom = this._getOptions().zoom;
            if (ratio > Frame.getRatio()) {
                this._cotton.scaleToHeight(dimensions.height * zoom);
            } else {
                this._cotton.scaleToWidth(dimensions.width * zoom);
            }
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions();
            this._loadImage(function(response) {

                // Fabric basics
                var cotton = new fabric.Image(response.image);
                layer.getCanvas().getCotton().add(cotton);
                _this._cotton = cotton;

                // Options (including visibility incase image removed)
                options.visible = response.visible;
                cotton.set(options);
                _this._scaleToFrame();

                // Filters
                _this._drawFilters();

                /**
                 * Note that while I add handlers like in other drawings, I do
                 * not call this.magnets.inbound, since the background rectangle
                 * view does the job of presenting an object that can have other
                 * layers snapped to it.
                 */
                _this._addListeners();
                cotton.makeSlidable();

                // Event dispatching
                _this._drawn = true;
                _this.triggerHandler('draw', [_this]);
            });
        },

        /**
         * filters
         * 
         * Applies the filters registered against the fabric object to the image.
         * 
         * @access  public
         * @return  void
         */
        // filters: function() {
        //     var canvas = this.getCanvas(),
        //         callback = canvas.render.proxy(canvas);
        //     this._cotton.applyFilters(callback);
        // },

        /**
         * refresh
         * 
         * @see     Resizing: http://jsfiddle.net/7gvJG/70/
         * @access  public
         * @return  void
         */
        refresh: function() {
            this._scaleToFrame();
            this._getUrl() !== false && this._cotton.set({
                'visible': true
            });
            this._cotton.set({
                left: this.relative.left.apply(this),
                top: this.relative.top.apply(this)
            });
            this._scale();
            this._scaleToFrame();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * reload
         * 
         * This method has only one responsibility: to reload the image that is
         * set in the layer. To do so, it calls the helper _loadImage method,
         * and once the image has been loaded into memory, calls the
         * fabric-native setElement method.
         * 
         * It then calls refresh in order to have the image's width or height
         * scaled to the proper canvas-dimension, before scaling the image
         * itself (which itself calls the _resize method).
         * 
         * The issue with this flow is that it seems multiple calls to
         * _loadImage and setElement are made, since it's done below, and then
         * in the refresh method (via the _scale / _resize methods). Not sure
         * what's ideal here :/
         * 
         * @access  public
         * @return  void
         */
        reload: function() {
            var _this = this;
            this._loadImage(function(response) {
                _this._cotton.setElement(
                    response.image,
                    function() {
                        _this.refresh();
                    }
                );
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('RectangleDrawing', function() {

    /**
     * BackgroundRectangleDrawing
     * 
     * @extends RectangleDrawing
     */
    window.BackgroundRectangleDrawing = RectangleDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundRectangleDrawing')
         */
        _string: 'BackgroundRectangleDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   RectangleLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement. Other controls go through the
         * toolbar.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addSelectListeners();
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    Toolbars.show('backgroundRectangle');
                }
            });
        },

        /**
         * _getDefaults
         * 
         * Note that although the Rectangle fabric drawing's bounding box cannot
         * be seen (because it's set to the exact dimensions of the canvas), it
         * is important for it's padding to be set to 0, otherwise layers snap
         * incorrectly when moving.
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaults: function() {
            var defaults = {
                hasBorders: false,
                hasControls: false,
                hasRotatingPoint: false,
                hoverCursor: 'default',
                lockMovementX: true,
                lockMovementY: true,
                moveCursor: 'default',
                padding: 0,
                selectable: true
            };
            return jQuery.extend({}, this._super(), defaults);
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    fill: layer.getStyle('backgroundColor'),
                    height: this.relative.height.apply(this),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var options = this._getOptions(),
                cotton = new fabric.Rect(options);
            this.getCanvas().getCotton().add(cotton);
            this._cotton = cotton;
            this.magnets.inbound.apply(this);
            this._addListeners();
            this._drawn = true;
            this.triggerHandler('draw', [this]);
            // this._cotton.on({
            //     'moving': function() {
            //         this.set({
            //             hoverCursor: 'default'
            //         });
            //     }
            // });
        },

        /**
         * highlight
         * 
         * Overwrites the Drawing::highlight method in order to use the Html
         * guides as the target for highlighting.
         * 
         * @access  public
         * @param   Object options
         * @return  void
         */
        highlight: function(options) {
            var $guides = App.getElement().find('div.guides'),
                $verticalGuide = $guides.find('div.vertical'),
                $horizontalGuide = $guides.find('div.horizontal');
            if (this.magnets.highlight === true) {
                if (Account.highlightCenterGuidesOnSnap() === true) {
                    if (options.showHorizontalLineCenters === true) {
                        $verticalGuide.removeClass('hidden');
                    } else if (options.showVerticalLineCenters === true) {
                        $horizontalGuide.removeClass('hidden');
                    }
                }
            }
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var options = this._getOptions();
            this._cotton.set(options);
            this._cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * relative
         * 
         * @access  public
         * @var     Object
         */
        relative: function() {
            return jQuery.extend(true, {}, this._super(), {
                /**
                 * height
                 * 
                 * @access  public
                 * @return  Number
                 */
                height: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        percentage = this._layer.getStyle('height').toInt() / 100,
                        pixels = (dimensions.height * percentage).round(4);
                    return pixels;
                }
            })
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageDrawing', function() {

    /**
     * BitmapImageDrawing
     * 
     * @events  resize/start
     *          resize/complete
     *          applyFilters/complete
     *          applyFilters/start
     * @see     http://jsperf.com/lanczos-resampling
     * @see     https://www.viget.com/articles/instagram-style-filters-in-html5-canvas
     * @see     http://stackoverflow.com/questions/2303690/resizing-an-image-in-an-html5-canvas?lq=1
     * @extends ImageDrawing
     */
    window.BitmapImageDrawing = ImageDrawing.extend({

        /**
         * _listeners
         * 
         * @see     http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access  protected
         * @var     Object
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'filters': function() {
                    this._layer.on({
                        'filter/add': function(event, obj) {
                            var cotton = this.getCotton(),
                                drawing = this._drawing,
                                type = obj.type,
                                properties = obj.properties || {},
                                filter;
                            filter = drawing._filter[type].apply(this, [properties]);
                            filter.set('_stencilType', type);
                            cotton.filters.push(filter);
                            this.getCanvas().render();
                        },
                        'filter/remove': function(event, obj) {
                            var cotton = this.getCotton(),
                                filters = cotton.filters || [];
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].get('_stencilType') === obj.type) {
                                    filters.splice(i, 1);
                                }
                            }
                            this.getCanvas().render();
                        },
                        'filter/update': function(event, obj) {
                            var cotton = this.getCotton(),
                                rawFilters = cotton.get('filters'),
                                index, rawFilter;
                            for (index in rawFilters) {
                                rawFilter = rawFilters[index];
                                if (rawFilter.get('_stencilType') === obj.type) {
                                    if (obj.type === 'blur') {
                                        var radius = obj.properties.strength / 3,
                                            dimensions = this.getCanvas().getRenderedDimensions();
                                        radius *= dimensions.width;
                                        radius /= 365;
                                        radius = radius.round(0);
                                        rawFilter.options.args = [radius];
                                    } else if (obj.type === 'colorOverlay') {
                                        // StencilBooter.log(JSON.stringify(obj));
                                        rawFilter.color = obj.properties.color;
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'darken') {
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'lighten') {
                                        rawFilter.opacity = obj.properties.strength / 100;
                                    } else if (obj.type === 'opacity') {
                                        rawFilter.opacity = (100 - obj.properties.strength) / 100;
                                    }
                                }
                            }
                            this.getCanvas().render();
                        },
                    });
                }//,
                // 'colorOverlay': function() {
                //     this._layer.on({
                //         'change/colorOverlay': function(event, colorOverlay) {
                //             // var drawing = this._drawing,
                //             //     cotton = drawing.getCotton();
                //             // drawing.refreshStroke();
                //             // drawing.refreshShadow();
                //             // // cotton.trigger('changed');
                //             // this.triggerHandler('refresh/dimensions');
                //             // this.getCanvas().render();
                //         },
                //         'clear/colorOverlay': function(event) {
                //             // var drawing = this._drawing,
                //             //     cotton = this.getCotton();
                //             // drawing.refreshShadow();
                //             // cotton.setStroke(null);
                //             // cotton.setStrokeWidth(0);
                //             // // cotton.trigger('changed');
                //             // this.triggerHandler('refresh/dimensions');
                //             // this.getCanvas().render();
                //         }
                //     });
                // }
            });
        },

        /**
         * _resizing
         * 
         * @access  protected
         * @var     false|Boolean (default: false)
         */
        _resizing: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BitmapImageDrawing')
         */
        _string: 'BitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   BitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addFiltersListeners
         * 
         * @access  protected
         * @return  void
         */
        _addFiltersListeners: function() {
            var _this = this;
            this.on({
                'resize/start': function(event) {
                    var key = 'bitmapImageResizings',
                        bitmapImageResizings = Stencil.get(key) || 0;
                    Stencil.set(key, bitmapImageResizings);
                    if (this._layer.getProperty('filters').length > 0) {
                        bitmapImageResizings++;
                        Stencil.set(key, bitmapImageResizings);
                        var content = App.getStage().getContent();
                        content.interaction.block.apply(content);
                    }
                },
                'resize/complete': function(event) {
                    var key = 'bitmapImageResizings',
                        bitmapImageResizings = Stencil.get(key);
                    if (this._layer.getProperty('filters').length > 0) {
                        bitmapImageResizings--;
                        Stencil.set(key, bitmapImageResizings);
                        if (bitmapImageResizings === 0) {
                            var content = App.getStage().getContent();
                            content.interaction.unblock.apply(content);
                        }
                    }
                }
            });
            this._cotton.on({
                'applyFilters/complete': function() {
                    _this.triggerHandler('applyFilters/complete');
                },
                'applyFilters/start': function() {
                    _this.triggerHandler('applyFilters/start');
                }
            });
        },

        /**
         * _addListeners
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._super();
            this._addFiltersListeners();
        },

        /**
         * _drawFilters
         * 
         * @note    A check is made against the _filter object to ensure the
         *          filter-by-type is actually defined as a method, to prevent
         *          legacy images that used filters that are not supported (eg.
         *          colorsize) from breaking things.
         * @access  protected
         * @return  void
         */
        _drawFilters: function() {
            var _this = this,
                filters = this._layer.getProperty('filters'),
                filter,
                cotton = this._cotton,
                properties;
            jQuery.each(filters, function(index, obj) {
                if (_this._filter[obj.type] !== undefined) {
                    properties = obj.properties || {};
                    filter = _this._filter[obj.type].apply(_this, [properties]);
                    filter.set('_stencilType', obj.type);
                    cotton.filters.push(filter);
                    _this._layer.set({'renderFilters': true});
                }
            });
        },

        /**
         * _filter
         * 
         * @access  protected
         * @var     Object
         */
        _filter: {
            _1977: function(properties) {
                return new fabric.Image.filters.Caman('1977');
            },
            blur: function(properties) {
                var radius = 5;
                if (typeof properties.strength !== 'undefined') {
                    radius = properties.strength / 3;
                }
                var dimensions = this.getCanvas().getRenderedDimensions();
                radius *= dimensions.width;
                radius /= 365;
                return new fabric.Image.filters.Caman(
                    'stackBlur',
                    {
                        args: [
                            radius.round(0)
                        ]
                    }
                );
            },
            brannan: function(properties) {
                return new fabric.Image.filters.Caman('brannan');
            },
            bw: function() {
                return new fabric.Image.filters.Grayscale();
            },
            clarity: function(properties) {
                return new fabric.Image.filters.Caman('clarity');
            },
            colorOverlay: function(properties) {
                var color = ColorUtils.getBlack('rgba'),
                    strength = 0.5;
                if (typeof properties.color !== 'undefined') {
                    color = properties.color;
                }
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: color,
                    opacity: strength
                });
            },
            // concentrate: function(properties) {
            //     return new fabric.Image.filters.Caman('concentrate');
            // },
            // crossProcess: function(properties) {
            //     return new fabric.Image.filters.Caman('crossProcess');
            // },
            darken: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: '#000000',
                    opacity: strength
                });
            },
            // glowingSun: function(properties) {
            //     return new fabric.Image.filters.Caman('glowingSun');
            // },
            gotham: function(properties) {
                return new fabric.Image.filters.Caman('gotham');
            },
            // grungy: function(properties) {
            //     return new fabric.Image.filters.Caman('grungy');
            // },
            // hazyDays: function(properties) {
            //     return new fabric.Image.filters.Caman('hazyDays');
            // },
            hefe: function(properties) {
                return new fabric.Image.filters.Caman('hefe');
            },
            // hemingway: function(properties) {
            //     return new fabric.Image.filters.Caman('hemingway');
            // },
            // herMajesty: function(properties) {
            //     return new fabric.Image.filters.Caman('herMajesty');
            // },
            // jarques: function(properties) {
            //     return new fabric.Image.filters.Caman('jarques');
            // },
            lighten: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = properties.strength / 100;
                }
                return new fabric.Image.filters.Tint({
                    color: '#ffffff',
                    opacity: strength
                });
            },
            lomo: function(properties) {
                return new fabric.Image.filters.Caman('lomo');
            },
            lordKelvin: function(properties) {
                return new fabric.Image.filters.Caman('lordKelvin');
            },
            // love: function(properties) {
            //     return new fabric.Image.filters.Caman('love');
            // },
            // oldBoot: function(properties) {
            //     return new fabric.Image.filters.Caman('oldBoot');
            // },
            opacity: function(properties) {
                var strength = 0.5;
                if (typeof properties.strength !== 'undefined') {
                    strength = (100 - properties.strength) / 100;
                }
                return new fabric.Image.filters.Fade({
                    // drawing: this,
                    opacity: strength
                });
            },
            // orangePeel: function(properties) {
            //     return new fabric.Image.filters.Caman('orangePeel');
            // },
            // pinhole: function(properties) {
            //     return new fabric.Image.filters.Caman('pinhole');
            // },
            nashville: function(properties) {
                return new fabric.Image.filters.Caman('nashville');
            },
            // nostalgia: function(properties) {
            //     return new fabric.Image.filters.Caman('nostalgia');
            // },
            sepia: function() {
                // return new fabric.Image.filters.Sepia();
                // return new fabric.Image.filters.Sepia2();
                return new fabric.Image.filters.Caman('sepia');
            },
            sinCity: function(properties) {
                return new fabric.Image.filters.Caman('sinCity');
            },
            sunrise: function(properties) {
                return new fabric.Image.filters.Caman('sunrise');
            },
            vintage: function(properties) {
                return new fabric.Image.filters.Caman('vintage');
            },
            xPro: function(properties) {
                return new fabric.Image.filters.Caman('xPro');
            }
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    angle: layer.getStyle('angle').toFloat(),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _resize
         * 
         * Loads in a resized version of the image, relative to the width value
         * for the layer. Note that since this is the parent-class for various
         * ImageLayer types, not all require a width-parameter to be sent to the
         * _getUrl method. Those that do not need it (at the moment,
         * VectorImageLayer since a width is not needed for resample there, and
         * BackgroundBitmapImageLayer, as the width is automatically determined
         * based on the Frame and preview-canvas sizing), simply ignore it.
         * 
         * @access  protected
         * @return  void
         */
        _resize: function() {
            this.triggerHandler('resize/start');
            this._resizing = true;
            var _this = this,
                cotton = this._cotton,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            this._cotton.setSrc(
                url,
                function() {
                    cotton.setCoords();
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();
                    layer.getCanvas().render();
                    _this._resizing = false;
                    _this.triggerHandler('resize/complete');
                },
                {
                    crossOrigin: 'anonymous'
                }
            );
        },

        /**
         * _scale
         * 
         * This is a helper method to facilitate some race-conditions that were
         * going on. This logic is also employed in BackgroundBitmapImageLayer
         * layers. The race-condition was that when the user resized the browser
         * too fast, it was possible for multiple resize-flows to happen. When
         * that was the case, sometimes the first resize-flow would be slow in
         * loading the new-sized image asset (done via the setSrc method below).
         * This would sometimes result in the wrong image being rendered after
         * the user let go of their mouse, simply because the second-resize-flow
         * would return faster than the first. This would be common if the
         * second-resize dimensions pointed to an image that was already in
         * cache.
         * 
         * So the logic here is intended to force the application to wait until
         * a resize has happened before initiating a new one. It's essentially
         * chaining them. While this isn't ideal for memory, it's suitable for
         * now.
         * 
         * Hypothetically, a more performative flow would be to cancel the
         * initial resize (if one is going on), and start with this new one.
         * 
         * It's also worth noting that with this logic, it's possible to
         * reproduce a janky experience whereby if the user resizes their window
         * fast-enough, images can shift between the wrong and right dimensions.
         * This is again because of race-conditions. The above
         * hypothetical-approach would address this.
         * 
         * @access  protected
         * @return  void
         */
        _scale: function() {
            this._resizing !== true ? this._resize() : this.once({
                'resize/complete': this._resize.proxy(this)
            });
        },

        /**
         * refresh
         * 
         * Resizes position properties of the layer relative to the new canvas
         * size (which comes into play via the _getOptions method).
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var cotton = this._cotton,
                options = this._getOptions();
            cotton.set({
                left: options.left,
                top: options.top
            });
            var scaledWidth = this._getScaledWidth();
            cotton.scaleToWidth(scaledWidth);
            var scaleX = (cotton.scaleX * this._layer.getStyle('stretchX')).round(4),
                scaleY = (cotton.scaleY * this._layer.getStyle('stretchY')).round(4);
            cotton.setScaleX(scaleX);
            cotton.setScaleY(scaleY);
            cotton.setCoords();
            this._scale();
            cotton.scaleToWidth(scaledWidth);
            this.triggerHandler('refresh', [this]);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('VectorImageDrawing', function() {

    /**
     * ColorVectorImageDrawing
     * 
     * @extends VectorImageDrawing
     */
    window.ColorVectorImageDrawing = VectorImageDrawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'opacityStrength': function() {
                    this._layer.on({
                        'change/opacityStrength': function(event, opacityStrength) {
                            var cotton = this.getCotton(),
                                opacityValue = ((100 - opacityStrength) / 100).round(2);
                            cotton.setOpacity(opacityValue);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorVectorImageDrawing')
         */
        _string: 'ColorVectorImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   VectorImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('colorVectorImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    angle: layer.getStyle('angle').toFloat(),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    opacity: layer.getStyle('opacity').toFloat(),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageDrawing', function() {

    /**
     * ForegroundBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.ForegroundBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ForegroundBitmapImageDrawing')
         */
        _string: 'ForegroundBitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   ForegroundBitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addMoveListeners
         * 
         * @access  protected
         * @return  void
         */
        _addMoveListeners: function() {
            this._super();
            var transformed = false;
            this._cotton.on({
                'moving': function(event) {
                    if (transformed === false) {
                        transformed = true;
                        this.set({
                            opacity: 0.7
                        });
                        Canvases.Preview.render();
                    }
                },
                'modified': function(event) {
                    transformed = false;
                    this.set({
                        opacity: 1
                    });
                    Canvases.Preview.render();
                }
            });
        },

        /**
         * _addScaleListeners
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            this._super();
            var delay = Stencil.getResizeDelay('foregroundBitmapImage');
            this._cotton.on({
                'scaling': _.debounce(this._scale.proxy(this), delay),
                'scaling/manual': _.debounce(this._scale.proxy(this), delay)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('foregroundBitmapImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        // _getOptions: function() {
        //     var custom = {
        //         },
        //         parent = this._super();
        //     return jQuery.extend({}, parent, custom);
        // },

        /**
         * _getUrl
         * 
         * @access  protected
         * @param   Number width
         * @return  String
         */
        _getUrl: function(width) {

            // 
            var key = this._layer.getProperty('image');
            if (key.match(/^asst/) !== null || key.match(/^upld/) !== null) {
                var ratio = window.devicePixelRatio || 1,
                    key = this._layer.getProperty('image');
                width *= ratio;
                return Images.thumb(key, {
                    type: 'scale',
                    width: width.round(0)
                });
            }

            /**
             * Not an asset or upload record; this ought to mean it's a
             * resource. Check if it's in memory. If it's not, then it's likely
             * an invalid pointer to a 3rd-party resource that for some reason
             * did not get converted to an asset.
             * 
             * Otherwise, send back the small version of the 3rd-party resource.
             */
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                return false;
            }
            return accessor.url('small');
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            fabric.util.loadImage(
                url,
                function(image) {

                    // Fabric basics
                    var cotton = new fabric.Image(image);
                    layer.getCanvas().getCotton().add(cotton);
                    _this._cotton = cotton;

                    /**
                     * Options
                     * 
                     * I set the general options first. I then set the width by
                     * scaling the object to the desired value. Finally, I set
                     * the angle *_after_* the width has been set. If I set the
                     * angle first, the width is decreased.
                     */
                    var angle = options.angle;
                    delete options.angle;
                    delete options.width;
                    cotton.set(options);
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    cotton.setAngle(angle);

                    // Scaling
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();

                    // Filters
                    _this._drawFilters();

                    // Events
                    _this._addListeners();
                    _this.magnets.angles.apply(_this);
                    _this.magnets.outbound.apply(_this);
                    cotton.boxIn(_this._boxInRatio);
                    _this.magnets.inbound.apply(_this);

                    // Done drawing; trigger event
                    _this._drawn = true;
                    _this.triggerHandler('draw', [_this]);
                },
                this,
                {
                    crossOrigin: 'anonymous'
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Drawing', function() {

    /**
     * ImageDrawing
     * 
     * @extends Drawing
     */
    window.ImageDrawing = Drawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageDrawing')
         */
        _string: 'ImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   ImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addBoxInListeners();
            this._addMoveListeners();
            this._addRotateListeners();
            this._addScaleListeners();
            this._addSelectListeners();
            this._addSnapListeners();
        },

        /**
         * _addScaleListeners
         * 
         * This is a complicated beast. Scaling a VectorImageDrawing affects the
         * positioning (left/right), flip properties (since it can be stretched
         * beyond/above/below an axis/fold) and scale properties. The below
         * logic interprets scaling, and finds the lowest scale value for the
         * x/y axis. I do this to ensure I get _some_ width value stored in the
         * layer. I then normalize the stretch and width values relative to that
         * scaling value. The width and left/top styles are then normalized
         * relative to the canvas dimensions.
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            var _this = this,
                closure = function(event) {

                    // Dimensions
                    var scaleX = this.scaleX,
                        scaleY = this.scaleY,
                        flipX = this.flipX,
                        flipY = this.flipY,
                        factor = Math.min(scaleX, scaleY),
                        width = (this.width * factor).round(4),
                        stretchX = (scaleX / factor).round(4),
                        stretchY = (scaleY / factor).round(4);

                    // Adjust width to be relative
                    var current = _this.getCanvas().getRenderedDimensions();
                    width = ((width / current.width) * 100).round(4);

                    // Adjust left/right to be relative
                    var left = ((this.left / current.width) * 100).round(4),
                        top = ((this.top / current.height) * 100).round(4);
                    // width = (current.width * percentage).round(4);

                    // Done
                    var dimensions = {
                        left: left,
                        top: top,
                        width: width,
                        stretchX: stretchX,
                        stretchY: stretchY,
                        flipX: flipX,
                        flipY: flipY
                    };
                    _this._layer.triggerHandler('change/dimensions', [dimensions]);
                };
            this._cotton.on({
                'scaling': closure.proxy(this._cotton),
                'scaling/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _getScaledWidth
         * 
         * This function returns the adjusted width for the cotton object,
         * taking into consideration the size of the bounding rectangle. Most of
         * the time, nothing is actually changed, since the bounding rectangle
         * and the cotton object width are the same. But on tablets, for
         * example, it is different, since padding is added to layers. Because
         * of this, the bounding rectangle dimensions are increased.
         * 
         * A funny gotcha is that when the cotton object is initially drawn (in
         * the draw method), regardless of whether there is padding defined,
         * the bounding rectangle dimensions match that of the cotton object
         * itself. I believe this is because the canvas hasn't been rendered
         * (via the renderAll method against the canvas cotton object). So while
         * I'm calling this helper-method from within the draw logic, it is
         * irrelevant (at least right now). This may change later depending on
         * the flow I do for rendering cotton objects, or else for some other
         * unforeseen reason.
         * 
         * @access  protected
         * @return  Number
         */
        _getScaledWidth: function() {
            var options = this._getOptions(),
                width = options.width,
                cotton = this._cotton,
                boundingRectFactor = cotton.getBoundingRect().width / cotton.getWidth();
            return (width * boundingRectFactor).round(4);
        },

        /**
         * animate
         * 
         * @note    There's a bug here with some icons (VectorImage drawings),
         *          whereby if it's made up of many paths, some of them might not
         *          animate. This can be seen with this icon:
         *          https://i.imgur.com/sOPbC4d.png
         *          It's really subtle, but it's there.
         * @note    I have to detect the initial opacity, because for
         *          ColorVectorImageDrawing's the opacity can be controlled, and
         *          before, I was simply setting the opacity to 1 for this
         *          animation, which was creating inconsistencies when a
         *          ColorVectorImageLayer was cloned (and the original had an
         *          opacity value that was not set to 1).
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton(),
                top = this._cotton.get('top'),
                opacity = this._cotton.get('opacity');
            this._cotton.animate('top', top, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: top - 50,
                onChange: cotton.renderAll.bind(cotton)
            });
            this._cotton.animate('opacity', opacity, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: Math.max(0.2, opacity - 0.7),
                onChange: cotton.renderAll.bind(cotton)
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Drawing', function() {

    /**
     * RectangleDrawing
     * 
     * @extends Drawing
     */
    window.RectangleDrawing = Drawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Object
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'backgroundColor': function() {
                    this._layer.on({
                        'change/backgroundColor': function(event, backgroundColor, removed) {
                            var cotton = this.getCotton();
                            cotton.setColor(backgroundColor);
                            this.getCanvas().render();
                        },
                        'clear/backgroundColor': function(event) {
                            var cotton = this.getCotton(),
                                transparentBlack = ColorUtils.getBlack('rgba', 0);
                            cotton.setColor(transparentBlack);
                            this.getCanvas().render();
                        },
                        'reset/backgroundColor': function(event) {
                            var cotton = this.getCotton(),
                                white = ColorUtils.getWhite('rgba');
                            cotton.setColor(white);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RectangleDrawing')
         */
        _string: 'RectangleDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   RectangleLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Drawing', function() {

    /**
     * TextDrawing
     * 
     * @fires   draw
     *          refresh
     *          preview/fontFamily
     * @extends Drawing
     */
    window.TextDrawing = Drawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'align': function() {
                    this._layer.on({
                        'change/align': function(event, position) {
                            var cotton = this.getCotton();
                            cotton.setTextAlign(position);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'backdropColor': function() {
                    this._layer.on({
                        'change/backdropColor': function(event, backdropColor) {
                            var cotton = this.getCotton(),
                                backdropStretch = this.getStyle('backdropStretch');
                            cotton.addBackdrop(backdropColor, backdropStretch);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'change/backdropStretch': function(event, backdropStretch) {
                            var cotton = this.getCotton(),
                                backdropColor = this.getStyle('backdropColor');
                            cotton.addBackdrop(backdropColor, backdropStretch);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'clear/backdropColor': function(event) {
                            var cotton = this.getCotton();
                            cotton.clearBackdrop();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                    });
                },
                'bold': function() {
                    this._layer.on({
                        'change/bold': function(event, on) {
                            var _this = this,
                                fontFamily = this.getStyle('fontFamily'),
                                drawing = this._drawing,
                                cotton = drawing.getCotton();

                            // Load font
                            var fontsCollection = Stencil.account().collection('fonts'),
                                font = fontsCollection.findByFamilyName(fontFamily);
                            font.loadFull(function() {
                                var weight = 'normal';
                                if (on === true) {
                                    weight = 'bold';
                                }
                                cotton.setFontWeight(weight);
                                drawing.refreshStroke();
                                drawing.refreshShadow();
                                // cotton.trigger('changed');
                                _this.triggerHandler('refresh/dimensions');
                                _this.getCanvas().render();
                            });
                        },
                        'revert/bold': function(event) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setFontWeight('normal');
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'shadowStrength': function() {
                    this._layer.on({
                        'change/shadowStrength': function(event, shadowStrength) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'fontFamily': function() {
                    this._layer.on({

                        /**
                         * (anonymous)
                         * 
                         * @access  private
                         * @param   Object event
                         * @param   FontAccessor font
                         * @return  void
                         */
                        'change/fontFamily': function(event, font) {
                            var fontFamily = font.get('familyName'),
                                cotton = this.getCotton();
                            cotton.setFontFamily(fontFamily);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @access  private
                         * @param   Object event
                         * @param   FontAccessor font
                         * @return  void
                         */
                        'preview/fontFamily': function(event, font) {
                            var fontFamily = font.get('familyName');
                            this._cotton.setFontFamily(fontFamily);
                            // this._cotton.trigger('changed');
                            this.getLayer().triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'fontSize': function() {
                    this._layer.on({
                        'change/fontSize': function(event, fontSize) {
                            var drawing = this._drawing,
                                size = drawing.relative.fontSize.apply(drawing),
                                cotton = drawing.getCotton();
                            cotton.setFontSize(size);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'italic': function() {
                    this._layer.on({
                        'change/italic': function(event, on) {
                            var _this = this,
                                fontFamily = this.getStyle('fontFamily'),
                                drawing = this._drawing,
                                cotton = drawing.getCotton();

                            // Load font
                            var fontsCollection = Stencil.account().collection('fonts'),
                                font = fontsCollection.findByFamilyName(fontFamily);
                            font.loadFull(function() {
                                var style = 'normal';
                                if (on === true) {
                                    style = 'italic';
                                }
                                cotton.setFontStyle(style);
                                drawing.refreshStroke();
                                drawing.refreshShadow();
                                // cotton.trigger('changed');
                                _this.triggerHandler('refresh/dimensions');
                                _this.getCanvas().render();
                            });
                        },
                        'revert/italic': function(event) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setFontStyle('normal');
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'lineHeight': function() {
                    this._layer.on({
                        'change/lineHeight': function(event, lineHeight) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            cotton.setLineHeight(lineHeight);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'strokeColor': function() {
                    this._layer.on({
                        'change/strokeColor': function(event, strokeColor) {
                            var drawing = this._drawing,
                                cotton = drawing.getCotton();
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        },
                        'clear/strokeColor': function(event) {
                            var drawing = this._drawing,
                                cotton = this.getCotton();
                            drawing.refreshShadow();
                            cotton.setStroke(null);
                            cotton.setStrokeWidth(0);
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                },
                'textColor': function() {
                    this._layer.on({
                        'change/textColor': function(event, textColor) {
                            var cotton = this.getCotton();
                            cotton.setColor(textColor);
                            this._drawing.refreshShadow();
                            this.getCanvas().render();
                        }
                    });
                },
                'underline': function() {
                    this._layer.on({
                        'change/underline': function(event, on) {
                            var decoration = '',
                                drawing = this._drawing,
                                cotton = drawing.getCotton();
                            if (on === true) {
                                decoration = 'underline';
                            }
                            cotton.setTextDecoration(decoration);
                            drawing.refreshStroke();
                            drawing.refreshShadow();
                            // cotton.trigger('changed');
                            this.triggerHandler('refresh/dimensions');
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TextDrawing')
         */
        _string: 'TextDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   TextLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addListeners
         * 
         * Adds event listeners to the fabric object that only occur through
         * interaction with the HTMLCanvasElement. Other controls go through the
         * text toolbar.
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this._addBoxInListeners();
            this._addMoveListeners();
            this._addRotateListeners();
            this._addScaleListeners();
            this._addSelectListeners();
            this._addSnapListeners();
            this._addTextChangeListeners();
        },

        /**
         * _addScaleListeners
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            var _this = this,
                closure = function(event) {
                    _this._layer.triggerHandler(
                        'change/dimensions',
                        [_this.getDimensions()]
                    );
                    _this._layer.setChangeOperationType('scaled');
                };
            this._cotton.on({
                'scaling': closure.proxy(this._cotton),
                'scaling/manual': closure.proxy(this._cotton)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('text');
                }
            });
        },

//         /**
//          * _addSelectListeners
//          * 
//          * So this was something I was playing with on January 5th, 2016, to
//          * make selecting a layer smarter. It was attempting to do the
//          * following:
//          * When an object was selected, check if there are any other layers
//          * that have an exact pixel of the object clicked (hence the usage of
//          * the <isTargetTransparent> method). The <containsPoint> might not
//          * be required? Hmm. Not sure. When a pixel was found, I waited 0
//          * milliseconds, and switched to that one. Noticed the bounding box
//          * appeared for a moment, so this may not be the most elegant
//          * solution. Don't delete this code, since I'll probably want to come
//          * back to it post-launch.
//          * 
//          * @see      https://github.com/kangax/fabric.js/issues/601
//          * @see      https://github.com/kangax/fabric.js/issues/28
//          * @see      http://stackoverflow.com/questions/19033989/fabric-js-containspoint-function-to-find-if-the-point-is-inside-the-actual-conte
//          * @see      https://groups.google.com/forum/#!topic/fabricjs/OhMkv6Mmpgo
//          * @access  protected
//          * @return  void
//          */
//         _addSelectListeners: function() {
//             var _this = this;
//             this._cotton.on({
//                 'selected': function(options) {
//                     var layers = [];
//                     if (options.e !== undefined) {
// StencilBooter.log(_this._layer);
//                         var point = new fabric.Point(
//                             options.e.layerX,
//                             options.e.layerY
//                         );
//                         layers = Canvases.Preview.getImageDocument().filter(
//                             function(index, layer) {
//                                 var cotton = layer.getCotton();
//                                 return layer.getStyle('order').toInt() !== 0
//                                     && layer !== _this._layer
//                                     && cotton.containsPoint(point) === true
//                                     && Canvases.Preview.getCotton().isTargetTransparent(
//                                         cotton,
//                                         options.e.layerX,
//                                         options.e.layerY
//                                     ) === false;
//                             }
//                         );
//                     }
// StencilBooter.log(layers);
//                     if (layers.length === 0) {
//                         Canvases.Preview.setSelectedLayer(_this._layer);
//                         _this.bb.show.apply(_this);
//                         Toolbars.getToolbar('text').show();
//                         Toolbars.getToolbar('vectorImage').hide();
//                         Toolbars.getToolbar('watermarkBitmapImage').hide();
//                     } else {
//                         var layer = layers[0],
//                             _fabric = layer.getCotton();
// // StencilBooter.log(layer, _fabric);
//                         setTimeout(function() {
//                             Canvases.Preview.setSelectedLayer(layer);
//                             Canvases.Preview.getCotton().setActiveObject(_fabric);
//                         }, 0);
//                     }
//                 }
//             });
//         },

        /**
         * _addTextChangeListeners
         * 
         * @access  protected
         * @return  void
         */
        _addTextChangeListeners: function() {
            var _this = this;
            this._cotton.on({
                'changed': function(event) {
                    var text = this.getText();
                    _this._layer.triggerHandler('change/text', [text]);
                }
            });
        },

        /**
         * _getBackdropPaddingFactor
         * 
         * @access  protected
         * @return  Number
         */
        _getBackdropPaddingFactor: function() {
            var backdropPaddingFactor = this._layer.getStyle(
                'backdropPaddingFactor'
            );
            if (backdropPaddingFactor === undefined) {
                return Config.default('backdropPaddingFactor').toFloat();
            }
            return backdropPaddingFactor.toFloat();
        },

        /**
         * _getDefaults
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaults: function() {
            var defaults = {
                cursorColor: ColorUtils.getBlack('rgba'),
                cursorDelay: 1000,
                cursorDuration: 200,
                cursorWidth: 1,
                editingBorderColor: ColorUtils.getBlack('rgba', 0.25),
                strokeLineCap: 'round',
                strokeLineJoin: 'round'
            };
            return jQuery.extend({}, this._super(), defaults);
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {

            // Formatting
            var layer = this._layer,
                fontWeight = 'normal',
                fontStyle = 'normal',
                textDecoration = '';
            if (layer.getStyle('bold') === true) {
                fontWeight = 'bold';
            }
            if (layer.getStyle('italic') === true) {
                fontStyle = 'italic';
            }
            if (layer.getStyle('underline') === true) {
                textDecoration = 'underline';
            }

            // Options
            var custom = {
                    angle: layer.getStyle('angle').toFloat(),
                    backdropPaddingFactor: this._getBackdropPaddingFactor(),
                    fill: layer.getStyle('textColor'),
                    fontFamily: layer.getStyle('fontFamily'),
                    fontSize: this.relative.fontSize.apply(this),
                    fontStyle: fontStyle,
                    fontWeight: fontWeight,
                    left: this.relative.left.apply(this),
                    lineHeight: layer.getStyle('lineHeight').toFloat(),
                    shadow: this.relative.shadow.apply(this),
                    textAlign: layer.getStyle('align'),
                    top: this.relative.top.apply(this),
                    textDecoration: textDecoration,
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _getStrokeWidth
         * 
         * Since the fontSize style is relative to the canvas width, I only need
         * to multiply the number by an arbitrary constant to get a good looking
         * stroke across the board.
         * 
         * @access  protected
         * @return  Number
         */
        _getStrokeWidth: function() {
            var size = this.relative.fontSize.apply(this),
            // var size = this._cotton.get('fontSize'),
                strokeWidthDividingFactor = this._getStrokeWidthDividingFactor();
            return (size * strokeWidthDividingFactor).round(4);
        },

        /**
         * _getStrokeWidthDividingFactor
         * 
         * @access  protected
         * @return  Number
         */
        _getStrokeWidthDividingFactor: function() {
            var strokeWidthDividingFactor = this._layer.getStyle(
                'strokeWidthDividingFactor'
            );
            if (strokeWidthDividingFactor === undefined) {
                return Config.default('strokeWidthDividingFactor').toFloat();
            }
            return strokeWidthDividingFactor.toFloat();
        },

        /**
         * _reposition
         * 
         * Changes the left and top style values for the text layer, as well as
         * the drawn cotton-position styles, to be in sync with how positioning
         * worked with Share As Image.
         * 
         * @access  protected
         * @return  void
         */
        _reposition: function() {

            // Left
            if (this._layer.getStyle('repositionLeft') === true) {
                this._layer.setStyle('repositionLeft', false);

                // UI
                var width = Math.min(this._cotton.width, this._cotton._getTextWidth() * 1.05),
                    left = this._cotton.left + width / 2;
                this._cotton.set({
                    width: width,
                    left: left
                });
                this._cotton.setCoords();

                // Layer
                var dimensions = this.getCanvas().getRenderedDimensions(),
                    relative = {
                        width: ((width * 100) / dimensions.width).round(4),
                        left: ((left * 100) / dimensions.width).round(4)
                    };
                this._layer.setStyles(relative);
            }
            // Top
            if (this._layer.getStyle('repositionTop') === true) {
                this._layer.setStyle('repositionTop', false);

                // UI
                var height = this._cotton._getTextHeight(),
                    top = this._cotton.top + height / 2;
                this._cotton.set({top: top});
                this._cotton.setCoords();

                // Layer
                var dimensions = this.getCanvas().getRenderedDimensions(),
                    relative = (top * 100) / dimensions.height;
                this._layer.setStyle('top', relative.round(4));
            }
        },

        /**
         * _setStroke
         * 
         * @access  protected
         * @param   String strokeColor
         * @return  void
         */
        _setStroke: function(strokeColor) {
            var strokeWidth = this._getStrokeWidth();
            this._cotton.setStrokeWidth(strokeWidth);
            this._cotton.setStroke(strokeColor);
        },

        /**
         * animate
         * 
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton(),
                top = this._cotton.get('top');
            this._cotton.animate('top', top, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: top - 50,
                onChange: cotton.renderAll.bind(cotton)
            });
            this._cotton.animate('opacity', 1, {
                duration: 500,
                easing: fabric.util.ease.easeOutBounce,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
            if (this._layer.getStyle('backdropColor') !== false) {
                var backdrop = this._cotton.get('backdrop');
                top = backdrop.get('top');
                backdrop.animate('top', top, {
                    duration: 500,
                    easing: fabric.util.ease.easeOutBounce,
                    from: top - 50,
                    onChange: cotton.renderAll.bind(cotton)
                });
                backdrop.animate('opacity', 1, {
                    duration: 500,
                    easing: fabric.util.ease.easeOutBounce,
                    from: 0.3,
                    onChange: cotton.renderAll.bind(cotton)
                });
            }
        },

        /**
         * draw
         * 
         * Controls visibility is explicitly set here to restrict manipulation
         * to width and rotation.
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                text = layer.getProperty('text'),
                fontFamily = layer.getStyle('fontFamily');

            // Fallback to default if font is no longer available
            var fontsCollection = Stencil.account().collection('fonts'),
                font = fontsCollection.findByFamilyName(fontFamily);
            if (font === false) {
                var appDefaultFontFamily = Stencil.account().getDefaultFontFamily();
                font = fontsCollection.findByFamilyName(appDefaultFontFamily);
                layer.setStyle('fontFamily', appDefaultFontFamily);
            }

            // Let's do this!
            var options = this._getOptions();
            font.loadFull(function() {

                // Backdrop
                _this.on({
                    'refresh': function(event) {
                        this.refreshBackdrop();
                    }
                });

                // Fabric basics
                var cotton = new fabric.Textbox(text, options);
                layer.getCanvas().getCotton().add(cotton);
                _this._cotton = cotton;
                _this._cotton.originalPadding = options.padding;

                // Controls
                cotton.setControlsVisibility({
                    ml: true,
                    mr: true,
                    mtr: true
                });

                // Events
                _this._addListeners();
                _this.magnets.angles.apply(_this);
                _this.magnets.outbound.apply(_this);
                cotton.boxIn(_this._boxInRatio);
                _this.magnets.inbound.apply(_this);

                /**
                 * Reposition the image if it's from Share As Image and was
                 * normalized.
                 */
                if (
                    layer.getStyle('repositionLeft') === true
                    || layer.getStyle('repositionTop') === true
                ) {
                    _this._reposition();
                }

                /**
                 * Stroke
                 * 
                 * This should be before the backdrop addition, since the stroke
                 * often affects the dimensions of the bounding box. Ran into
                 * this issue in Firefox when the order was reversed. Notice the
                 * spacing around the backdrop:
                 * https://i.imgur.com/KzHpKxe.png
                 * 
                 */
                _this.refreshStroke();
                _this.refreshShadow();

                // Backdrop
                var backdropColor = layer.getStyle('backdropColor');
                if (backdropColor !== false) {
                    var backdropStretch = layer.getStyle('backdropStretch');
                    cotton.addBackdrop(backdropColor, backdropStretch);
                }

                // Done drawing; trigger event
                _this._drawn = true;
                _this.triggerHandler('draw', [_this]);
            });
        },

        /**
         * getDimensions
         * 
         * @access  public
         * @return  Object
         */
        getDimensions: function() {
            var current = this.getCanvas().getRenderedDimensions(),
                left = ((this._cotton.left / current.width) * 100).round(4),
                top = ((this._cotton.top / current.height) * 100).round(4);
            return {
                left: left,
                top: top,
                width: (this._cotton.getRelativeWidth() * 100).round(4)
            };
        },

        /**
         * refresh
         * 
         * At the moment, refresh is only used on window resizing. When this
         * happens, the canvas dimensions may change. To accommodate for this,
         * only styles that are defined relative to the canvas size need to be
         * refreshed. These include:
         * - fontSize
         * - left
         * - top
         * - width
         * 
         * Additionally, the backdrop needs to be updated, so if one is defined
         * I manually call the position method.
         * 
         * Finally, I refresh the stroke since it's affected by the font size
         * applied to the layer, which may have been affected in the canvas
         * refresh.
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var layer = this._layer,
                options = this._getOptions();
            this._cotton.set({
                fontSize: options.fontSize,
                left: options.left,
                top: options.top,
                shadow: options.shadow,
                width: options.width
            });

            // Refresh stroke (since font size may have changed)
            this.refreshStroke();
            this.refreshShadow();

            // Done
            this._cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        },

        /**
         * refreshBackdrop
         * 
         * @access  public
         * @return  void
         */
        refreshBackdrop: function() {
            var backdropColor = this._layer.getStyle('backdropColor');
            if (backdropColor !== false) {
                this._cotton.positionBackdrop();
            }
        },

        /**
         * refreshShadow
         * 
         * @access  public
         * @return  void
         */
        refreshShadow: function() {
            var shadow = this.relative.shadow.apply(this);
            this._cotton.setShadow(shadow);
        },

        /**
         * refreshStroke
         * 
         * Helper method that sets the stroke on the cotton-object. Note that
         * although this method is only called from within this file, it is
         * public because some places where it's called, it's being done so
         * where the context is a different object (specifically, a TextLayer
         * instance).
         * 
         * @access  public
         * @return  void
         */
        refreshStroke: function() {
            var strokeColor = this._layer.getStyle('strokeColor');
            if (strokeColor !== false) {
                this._setStroke(strokeColor);
            }
        },

        /**
         * relative
         * 
         * @access  public
         * @var     Object
         */
        relative: function() {
            return jQuery.extend(true, {}, this._super(), {

                /**
                 * fontSize
                 * 
                 * This calculation method works differently than others, since the
                 * fontSize is on a scale of 20 to 400, rather than a percentage or
                 * decimal value. So I determine the ratio of the canvas width to
                 * the frame, and determine the appropriate font size.
                 * 
                 * @access  public
                 * @return  Number
                 */
                fontSize: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        fontSize = this._layer.getStyle('fontSize').toFloat();
                    return (fontSize / 100 / 10) * dimensions.width;
                },

                /**
                 * shadow
                 * 
                 * @access  public
                 * @return  String
                 */
                shadow: function() {
                    var dimensions = this.getCanvas().getRenderedDimensions(),
                        textColor = this._layer.getStyle('textColor'),
                        strokeColor = this._layer.getStyle('strokeColor'),
                        shadow = {
                            offsetX: this._layer.getStyle('shadowOffsetX') || 4,
                            offsetY: this._layer.getStyle('shadowOffsetY') || 4,
                            blur: this._layer.getStyle('shadowBlur') || 10,
                            color: this._layer.getStyle('shadowColor') || this._getContrastingColor(textColor),
                            strength: this._layer.getStyle('shadowStrength') === undefined ? 0 : this._layer.getStyle('shadowStrength')
                        };
                    if (strokeColor !== false) {
                        shadow.color = this._getContrastingColor(strokeColor);
                    }
                    shadow.strength /= 100
                    shadow.color = shadow.color.replace('rgb', 'rgba');
                    shadow.color = shadow.color.replace(')', ', ' + (shadow.strength) + ')');
                    var factor = (1 / 100 / 2) * this.relative.fontSize.apply(this);// * window.devicePixelRatio,
                        strokePadding = 0;
                    if (strokeColor !== false) {
                        strokePadding = this._getStrokeWidth() * 0.5;
                    }
                    shadow.offsetX = (shadow.offsetX * factor);
                    shadow.offsetY = (shadow.offsetY * factor);
                    shadow.blur = (shadow.blur * factor).round(0);
                    var offsetX = ((shadow.offsetX + strokePadding) * (window.devicePixelRatio)).round(0),
                        offsetY = ((shadow.offsetY + strokePadding) * (window.devicePixelRatio)).round(0),
                        blur = (shadow.blur),
                        color = shadow.color,
                        properties = [
                            (offsetX) + 'px',
                            (offsetY) + 'px',
                            (blur) + 'px',
                            color
                        ];
                    return properties.join(' ');
                }
            });
        },

        /**
         * repositionRelativeTo
         * 
         * Used with quotes to position a drawing directly below another
         * drawing.
         * 
         * @access  public
         * @param   Drawing drawing
         * @return  void
         */
        repositionRelativeTo: function(drawing) {
            var rect = drawing.getCotton().getBoundingRect(),
                buffer = 4,
                adjusted = (rect.top + rect.height + this._cotton.getBoundingRect().height / 2) * ((100 + buffer) / 100);
            this._cotton.set({
                top: adjusted
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    top: ((adjusted * 100) / dimensions.height).round(4)
                };
            this._layer.setStyles(relative);
        },

        /**
         * trim
         * 
         * @access  public
         * @return  void
         */
        trim: function() {
            var width = this._cotton._getTextWidth(),
                buffer = 30,
                adjusted = width * ((100 + buffer) / 100);
            this._cotton.set({
                width: adjusted
            });
            this._cotton.setCoords();
            var dimensions = this.getCanvas().getRenderedDimensions(),
                relative = {
                    width: ((adjusted * 100) / dimensions.width).round(4)
                };
            this._layer.setStyles(relative);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageDrawing', function() {

    /**
     * VectorImageDrawing
     * 
     * @extends ImageDrawing
     */
    window.VectorImageDrawing = ImageDrawing.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'fillColor': function() {
                    this._layer.on({
                        'change/fillColor': function(event, fillColor) {
                            var cotton = this.getCotton();
                            cotton.setFillColor(fillColor);
                            this.getCanvas().render();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorImageDrawing')
         */
        _string: 'VectorImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   VectorImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('vectorImage');
                }
            });
        },

        /**
         * _getOptions
         * 
         * @access  protected
         * @return  Object
         */
        _getOptions: function() {
            var layer = this._layer,
                custom = {
                    angle: layer.getStyle('angle').toFloat(),
                    fill: layer.getStyle('fillColor'),
                    flipX: layer.getStyle('flipX'),
                    flipY: layer.getStyle('flipY'),
                    left: this.relative.left.apply(this),
                    top: this.relative.top.apply(this),
                    width: this.relative.width.apply(this)
                },
                defaults = this._getDefaults();
            return jQuery.extend({}, defaults, custom);
        },

        /**
         * _getUrl
         * 
         * Returns the path to the vector's stored asset, or else assumes that
         * the accessor for this vector (eg. The Noun Project) is on the page.
         * In the latter case, it's likely to be a ResourceAccessor.
         * 
         * In the case where the image is an asset, I go directly to S3 instead
         * of through Cloudinary, as it seems Cloudinary doesn't serve SVGs
         * properly.
         * 
         * If the image isn't an asset, then, at the moment, it's likely a
         * resource (eg. The Noun Project), in which case I just grab the svg
         * url directly.
         * 
         * @access  protected
         * @return  String|false
         */
        _getUrl: function() {
            var image = this._layer.getProperty('image'),
                accessor;
            if (image.match(/^asst/) !== null) {
                var key = (image) + '.svg';
                // return Images.s3(key);
                return Images.cloudFront(key);
            }
            accessor = Stencil.getAccessor(image);
            if (accessor !== false) {
                return accessor.url('svg');
            }
            return false;
        },

        /**
         * _prepare
         * 
         * @access  protected
         * @var     Object
         */
        _prepare: {

            /**
             * _prepare.clip
             * 
             * @see     https://i.imgur.com/KvUG12A.png
             * @access  protected
             * @param   Number width
             * @param   Number height
             * @return  void
             */
            clip: function(width, height) {

                /**
                 * clip
                 * 
                 * Some icons were coming in as sprites. As a result, drawing an
                 * icon could result in a bunch of other icons being written. I
                 * tried to get around this by using the isContainedWithinObject
                 * and  isContainedWithinRect methods against the PathGroup
                 * object, but it didn't work well, possibly because paths
                 * pivotel to the desired icon started/ended outside of the
                 * object / rectangle. To get around this, I simply clip the
                 * vector according to it's width/height. The reason I have to
                 * set x / y as negative values is because the origin is set as
                 * center / center.
                 * 
                 * @access  private
                 * @param   CanvasRenderingContext2D ctx
                 * @return  void
                 */
                var clip = function (ctx) {
                    var x = -width / 2,
                        y = -height / 2;
                    ctx.rect(x, y, width, height);
                };
                this._cotton.setClipTo(clip);
            },

            /**
             * _prepare.draw
             * 
             * @access  protected
             * @param   Boolean fresh
             * @return  void
             */
            draw: function(fresh) {

                // Options
                var layer = this._layer,
                    cotton = this._cotton,
                    options = this._getOptions(),
                    width = options.width,
                    fill = options.fill;

                /**
                 * Checks whether this is a "fresh" addition to the canvas
                 * (an addition via the Preview.addVectorImagelayer method). If
                 * it is, it checks the ratio, and if it's a really tall image,
                 * it maxes out the height to 25% of the height of the canvas.
                 */
                if (fresh === true) {
                    if (cotton.getRatio() < 1) {
                        var height = 25,
                            dimensions = layer.getCanvas().getRenderedDimensions(),
                            percentage = height / 100,
                            pixels = (dimensions.height * percentage).round(4),
                            adjustedWidth;
                        width = pixels * cotton.getRatio();
                        adjustedWidth = ((width / dimensions.width) * 100).round(4);
                        layer.setStyles({
                            'width': adjustedWidth
                        });

                        // Update change history with new value
                        var undoHistory = ChangeHistory.history.undo(),
                            index = undoHistory.length - 1,
                            operation = undoHistory[index],
                            imageKey = this._layer.getProperty('image'),
                            json = operation.configuration.settings.json,
                            regExp,
                            pattern = '(' + (imageKey) + '".+?"width":)15';
                            replacement = '$1' + (adjustedWidth);
                        regExp = new RegExp(pattern);
                        json = json.replace(regExp, replacement);
                        operation.configuration.settings.json = json;
                        ChangeHistory.replaceLastUndoOperation(operation);
                    }
                }

                // Set options
                var angle = options.angle;
                delete options.angle;
                delete options.fill;
                delete options.width;
                cotton.set(options);
                var scaled = this._getScaledWidth();
                cotton.scaleToWidth(scaled);
                cotton.setAngle(angle);

                // Scaling
                var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                    scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                cotton.setScaleX(scaleX);
                cotton.setScaleY(scaleY);
                cotton.setCoords();

                // Color
                if (fill !== undefined) {
                    cotton.setFillColor(fill);
                }

                // Controls
                this._addListeners();

                // Cashmere
                this.magnets.angles.apply(this);
                this.magnets.outbound.apply(this);
                cotton.boxIn(this._boxInRatio);
                this.magnets.inbound.apply(this);

                // Event dispatching
                this._drawn = true;
                this.triggerHandler('draw', [this]);
            },

            /**
             * _prepare.shapes
             * 
             * @access  protected
             * @param   Array shapes
             * @return  Array
             */
            shapes: function(shapes) {

                /**
                 * Stripping out any shapes that are text to deal with
                 * issues like the following:
                 * https://i.imgur.com/JHXI3Vi.png
                 * https://i.imgur.com/HHnupvi.png
                 * 
                 * @note    Not sure if there are any icons that are using text
                 *          paths as part of their image. Hope not :/
                 * @note    May not be needed, since I'm using a clipping
                 *          function now (which out to hide any text that might
                 *          be contained in a sprite).
                 */
                shapes = jQuery.grep(shapes, function(shape, index) {
                    return shape.type !== 'text';
                });

                /**
                 * Adjust for stroke
                 * 
                 * Some icons (for example, the ice cream below), are 100%
                 * composed of strokes. So when I set the strokeWidth for all
                 * fabric objects to 0, it messed these ones up. So here, I
                 * check to see whether a stroke is defined on any of the
                 * shapes, and if so, set the stroke for that shape (not
                 * PathGroup) to 1.
                 * 
                 * @see     https://i.imgur.com/oVD08Pn.png
                 *          https://s3-us-west-2.amazonaws.com/app.local.getstencil.com/asst5afa89ce.svg
                 */
                jQuery.each(shapes, function(index, shape) {
                    if (shape.stroke && shape.stroke !== '') {
                        if (
                            shape.strokeWidth === undefined
                            || shape.strokeWidth === null
                            || shape.strokeWidth === 0
                        ) {
                            shape.strokeWidth = 1;
                        }
                    }
                });

                // 
                return shapes;
            },

            /**
             * _prepare.trim
             * 
             * Oh, trim-method. This one was gnarly, and took a long time to get
             * right. It scales a vector to 400px wide, and then sets up a
             * temporary canvas. The canvas has it's width and height set to
             * match the vector, and then a fabric-canvas is made from it. I
             * then add the vector to the canvas and proceed to run the trim
             * helper function to determine the exact fit.
             * 
             * The tricky thing is that fabric now automatically scales things
             * according to whether the client is using a retina monitor. So
             * after the trim comes back, I need to devide the number by the
             * pixel ratio, otherwise it's too high when i transform the vector
             * paths.
             * 
             * Note that the 400px-wide vector setting is to try and get the
             * best possible fidelity in terms of the truest fit. The higher
             * that width, the more specific the trim function is, but it's also
             * a heavy computation, thus the note below to look into web
             * workers.
             * 
             * When the value is too high, it causes a lag in the animation of
             * the icon dropping into the canvas, likely because the browser's
             * memory is full (hmm, look into this). It was especially noticable
             * with retina devices (Adam's monitor), because when the temporary
             * canvas is drawn, retina has 4-times more pixels (which requires
             * 4-times more computations).
             * 
             * @todo    Look into using web workers here since it can cause lag
             *          https://blog.idrsolutions.com/2012/09/how-to-draw-svg-on-html-5-canvas-and-why-you-might-want-to/
             * @access  protected
             * @param   Function callback
             * @return  void
             */
            trim: function(callback) {
                // this._cotton.scaleToWidth(200);
                this._cotton.scaleToWidth(400);
                // this._cotton.scaleToWidth(600);
                var factor = this._cotton.getScaleX(),
                    width = this._cotton.getWidth(),
                    height = this._cotton.getHeight(),
                    element = document.createElement('canvas'),
                    ratio = window.devicePixelRatio || 1,
                    ctx = element.getContext('2d');
                element.setAttribute('width', width);
                element.setAttribute('height', height);
                var canvas = new fabric.Canvas(element);
                canvas.add(this._cotton);
                var details = element.trimWhitespace();
                details.width /= ratio;
                details.height /= ratio;
                details.bounds.left /= ratio;
                details.bounds.top /= ratio;
                canvas.remove(this._cotton);
                callback({
                    ratio: details.width / details.height,
                    width: details.width / factor,
                    height: details.height / factor,
                    bounds: {
                        left: details.bounds.left / factor,
                        top: details.bounds.top / factor
                    }
                });
            },

            /**
             * _prepare.xml
             * 
             * @access  protected
             * @param   String xml
             * @return  String
             */
            xml: function(xml) {

                /**
                 * Strips out any <clipPath> tags to prevent issues with
                 * some icons. This one specifically had an issue:
                 * https://i.imgur.com/MbMAx9w.png
                 */
                xml = xml.replace(/\<clipPath.*\<\/clipPath>/gi, '');

                /**
                 * Strips out any <switch> tags, which was causing some issues.
                 * Noticed with this icon:
                 * https://i.imgur.com/lIFE8wO.png
                 * 
                 * @see     https://jsfiddle.net/bsnsd6ku/
                 */
                xml = xml.replace(/\<switch\>(.*)\<\/switch\>/gi, '$1');

                /**
                 * Fix any translate calls that were not set up
                 * properly. Specifically, some TNP icons were coming
                 * through with:
                 * transform="translate(-273.07-554.7)
                 * 
                 * This is an invalid translate / transform value, since
                 * there needs to be a space between the two values. To
                 * get around this, check when two negative translate /
                 * transform values are defined, and insert a space when
                 * there isn't one.
                 * 
                 * @see     http://stackoverflow.com/questions/34683134/svg-on-canvas-using-fabricjs-cant-be-seen-because-of-transform-translate-rul
                 * @see     https://i.imgur.com/nDtRJ62.png
                 */
                // if (transform.match(/translate\(\-[0-9\.]+,?\-[0-9\.]+/) === null) {
                xml = xml.replace(
                    /translate\((\-?[0-9\.]+)(\-{1}[0-9\.]+)\)/gi,
                    'translate($1 $2)'
                );

                // Done for now
                return xml;
            }
        },

        /**
         * draw
         * 
         * @note    Filtering out text nodes to prevent the following:
         *          vector, but rather part of a sprite. Sometimes these sprites
         *          would include the following shapes:
         *          rect
         *          text
         *          line
         *          path
         *          polygon
         *          circle
         *          See: https://i.imgur.com/jldKsgt.png
         * @see     https://m.alphasights.com/killing-cors-preflight-requests-on-a-react-spa-1f9b04aa5730#.h1516nbjv
         * @see     http://www.w3schools.com/tags/canvas_rect.asp
         * @see     http://fabricjs.com/clipping/
         * @see     https://github.com/kangax/fabric.js/issues/2555
         * @see     http://fabricjs.com/clipping/
         * @todo    Implement some sort of caching so that if multiple versions
         *          of the same vector on the canvas, it doesn't fire multiple
         *          ajax requests. Simplest would be to create a helper method
         *          that checks for a layer with the same src, and if found,
         *          grabs the pathing info from it and uses that instead. This
         *          will also speed up the Ghost canvas, which would make
         *          Google+Firefox downloading even faster (when I get around to
         *          it). See <svgCache> in fabric.js. At the moment, it's not so
         *          bad, since the browser is caching them, resulting in a 4ms
         *          local lookup: https://i.imgur.com/aTggRQX.png
         *          This 4ms delay may not seem like much, but if there are a
         *          bunch of icons in the canvas, it's multipled, along with the
         *          delay in the http request itself.
         * @param   Boolean fresh
         * @access  public
         * @return  void
         */
        draw: function(fresh) {

            // Overhead
            var _this = this,
                layer = this._layer,
                url = this._getUrl();

            // Something went wrong
            if (url === false) {
                Stencil.alert('svg.load.fail.2');
                layer.triggerHandler('delete');
            }
            // Preload (to check CORS, since TNP sometimes flakes)
            else {
                var signature = {file: 'VectorImage', line: 458};
                Stencil.ajax({
                    excludeDefaultData: true,
                    signature: signature,
                    cache: true,
                    crossDomain: true,
                    url: url,
                    type: 'GET',

                    /**
                     * error
                     * 
                     * Shows the alert, and if there is an active XHR call,
                     * decrements the count to ensure the user can reload the page
                     * if they'd like to. I need to do this because there are two
                     * ways in which this request can fail:
                     * 1) The preflight request fails because of a CORS issue. When
                     *    outbound preflight calls are made, I do not believe jQuery
                     *    increments the <active> count. Because of this, I don't
                     *    decrement the count here.
                     * 2) The preflight goes through successfully, but the actual
                     *    request for data (GET) fails. When this is the case, I
                     *    need to decrement the count since the <active> property
                     *    would have been incremented.
                     * @todo    The logic below simply communicates to the user that
                     *          the icon isn't available, instead of failing
                     *          silently. The real issue is that if it does fail,
                     *          it's likely because of a hiccup on The Noun Project's
                     *          side, in that it's not passing the proper CORS
                     *          headers. I've seen this with AWS before. Once that
                     *          happens, the user caches the request. So there may
                     *          not be a way for them to eventually get that icon
                     *          unless they clear their cache. One possible way would
                     *          be to change the layer src value by appending a cache
                     *          busting value (eg. random=123), and trying again with
                     *          that before erroring out. Then, each time they click
                     *          on the icon, it'll try another random one. For this
                     *          to work, thought, this new src value will need to be
                     *          set in the layer and saved. Hard to test this.
                     * @access  private
                     * @param   Object jqXHR
                     * @param   String textStatus
                     * @param   String errorThrown
                     * @return  void
                     */
                    error: function(jqXHR, textStatus, errorThrown) {
                        App.log('jQuery AJAX error', true);
                        App.log(signature, true);
                        App.log(arguments, true);
                        Stencil.alert('svg.load.fail');
                        layer.triggerHandler('delete');
                    },
                    success: function(xml) {
                        xml = _this._prepare.xml.apply(_this, [xml]);
                        fabric.loadSVGFromString(
                            xml,
                            function(shapes, passed) {
                                shapes = _this._prepare.shapes.apply(_this, [shapes]);
                                var cotton = fabric.util.groupSVGElements(
                                    shapes,
                                    passed
                                );
                                _this._cotton = cotton;
                                _this._prepare.trim.apply(_this, [function(details) {
                                    _this._cotton.set({
                                        width: details.width,
                                        height: details.height
                                    });
                                    var transformMatrix;
                                    jQuery.each(_this._cotton.paths, function(index, path) {
                                        transformMatrix = path.transformMatrix || [1, 0, 0, 1, 0, 0];
                                        path.setTransformMatrix([
                                            transformMatrix[0],
                                            transformMatrix[1],
                                            transformMatrix[2],
                                            transformMatrix[3],
                                            transformMatrix[4] - details.bounds.left,
                                            transformMatrix[5] - details.bounds.top
                                        ]);
                                    });

                                    // 
                                    layer.getCanvas().getCotton().add(cotton);
                                    // if (_this._cotton.paths.length > 1) {
                                        _this._prepare.clip.apply(
                                            _this,
                                            [
                                                details.width,
                                                details.height
                                            ]
                                        );
                                    // }
                                    _this._prepare.draw.apply(_this, [fresh]);
                                }]);
                            }
                        );
                    },
                    dataType: 'text'
                });
            }
        },

        /**
         * refresh
         * 
         * This method is essentially the same as the one in the ImageLayer
         * class. The exception is that there isn't a call to _scale (which is
         * a proxy for a call to _resize), since the VectorImageLayer layers are
         * references to vectors, which for scaling, only require to have their
         * width set (which is done via the _getScaleWidth method).
         * 
         * The _getScaleWidth method takes care of cases where padding is
         * defined (eg. on tablets).
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            var cotton = this._cotton,
                options = this._getOptions();
            cotton.set({
                left: options.left,
                top: options.top
            });
            var scaled = this._getScaledWidth();
            cotton.scaleToWidth(scaled);
            var scaleX = (cotton.scaleX * this._layer.getStyle('stretchX')).round(4),
                scaleY = (cotton.scaleY * this._layer.getStyle('stretchY')).round(4);
            cotton.setScaleX(scaleX);
            cotton.setScaleY(scaleY);
            cotton.setCoords();
            this.triggerHandler('refresh', [this]);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageDrawing', function() {

    /**
     * WatermarkBitmapImageDrawing
     * 
     * @extends BitmapImageDrawing
     */
    window.WatermarkBitmapImageDrawing = BitmapImageDrawing.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkBitmapImageDrawing')
         */
        _string: 'WatermarkBitmapImageDrawing',

        /**
         * init
         * 
         * @access  public
         * @param   WatermarkBitmapImageLayer layer
         * @return  void
         */
        init: function(layer) {
            this._super(layer);
        },

        /**
         * _addScaleListeners
         * 
         * @access  protected
         * @return  void
         */
        _addScaleListeners: function() {
            this._super();
            var delay = Stencil.getResizeDelay('watermarkBitmapImage');
            this._cotton.on({
                'scaling': _.debounce(this._scale.proxy(this), delay),
                'scaling/manual': _.debounce(this._scale.proxy(this), delay)
            });
        },

        /**
         * _addSelectListeners
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListeners: function() {
            var _this = this;
            this._cotton.on({
                'selected': function(options) {
                    _this.getCanvas().setSelectedLayer(_this._layer);
                    _this.getCanvas().render();
                    _this.bb.show.apply(_this);
                    Toolbars.show('watermarkBitmapImage');
                }
            });
        },

        /**
         * _getUrl
         * 
         * @access  protected
         * @param   Number width
         * @return  String
         */
        _getUrl: function(width) {
            var ratio = window.devicePixelRatio || 1,
                key = this._layer.getProperty('image');
            width *= ratio;
            return Images.thumb(key, {
                type: 'scale',
                width: width.round(0)
            });
        },

        /**
         * animate
         * 
         * Fades the watermark in, using an easeOutBack transition. I'm noting
         * this because the transition is different than other drawings, which
         * use easeOutBounce. The issue with that is when it's just an opacity
         * change / fade, the opacity fades but bounces for a second at the end
         * when I use the easeOutBounce transition. The easeOutBack transition
         * has the same initial momentum, but doesn't have the opacity bounce at
         * the end. That being said, I am using that transition in other
         * drawings for opacity, but only when the bounce is applied with a
         * movement transition (eg. top). In that case, it makes sense that the
         * opacity bounces at the same bounce the position does.
         * 
         * @access  public
         * @return  void
         */
        animate: function() {
            var cotton = this.getCanvas().getCotton();
            this._cotton.animate('opacity', 1, {
                duration: 750,
                easing: fabric.util.ease.easeOutBack,
                from: 0.3,
                onChange: cotton.renderAll.bind(cotton)
            });
        },

        /**
         * draw
         * 
         * @access  public
         * @return  void
         */
        draw: function() {
            var _this = this,
                layer = this._layer,
                options = this._getOptions(),
                width = options.width,
                url = this._getUrl(width.round(0));
            fabric.util.loadImage(
                url,
                function(image) {

                    // Fabric basics
                    var cotton = new fabric.Image(image);
                    layer.getCanvas().getCotton().add(cotton);
                    _this._cotton = cotton;

                    // Set controls visibility to prevent stretching knobs
                    cotton.setControlsVisibility({
                        tl: true,
                        tr: true,
                        br: true,
                        bl: true,
                        ml: false,
                        mt: false,
                        mr: false,
                        mb: false,
                        mtr: true
                    });

                    /**
                     * Options
                     * 
                     * I set the general options first. I then set the width by
                     * scaling the object to the desired value. Finally, I set
                     * the angle *_after_* the width has been set. If I set the
                     * angle first, the width is decreased.
                     */
                    var angle = options.angle;
                    delete options.angle;
                    delete options.width;
                    cotton.set(options);
                    var scaled = _this._getScaledWidth();
                    cotton.scaleToWidth(scaled);
                    cotton.setAngle(angle);

                    // Scaling
                    var scaleX = (cotton.scaleX * layer.getStyle('stretchX')).round(4),
                        scaleY = (cotton.scaleY * layer.getStyle('stretchY')).round(4);
                    cotton.setScaleX(scaleX);
                    cotton.setScaleY(scaleY);
                    cotton.setCoords();

                    // Filters
                    _this._drawFilters();

                    // Events
                    _this._addListeners();
                    _this.magnets.angles.apply(_this);
                    _this.magnets.outbound.apply(_this);
                    cotton.boxIn(_this._boxInRatio);
                    _this.magnets.inbound.apply(_this);

                    // Done drawing; trigger event
                    _this._drawn = true;
                    _this.triggerHandler('draw', [_this]);
                },
                this,
                {
                    crossOrigin: 'anonymous'
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Base', function() {

    /**
     * ImageDocument
     * 
     * @extends Base
     */
    window.ImageDocument = Base.extend({

        /**
         * _canvas
         * 
         * @access  protected
         * @var     false|CanvasView (default: false)
         */
        _canvas: false,

        /**
         * _document
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _document: {},

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'imageDocument')
         */
        _classType: 'imageDocument',

        /**
         * _image
         * 
         * @access  protected
         * @var     ImageAccessor (default: false)
         */
        _image: false,

        /**
         * _layers
         * 
         * Keeps track of all layers, including those that contain order-style
         * values (eg. any kind of TextLayer, VectorImage or
         * ForegroundBitmapImage).
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _layers: [],

        /**
         * init
         * 
         * @access  public
         * @param   Object document
         * @param   ImageAccessor image
         * @param   CanvasView canvas
         * @return  void
         */
        init: function(document, image, canvas) {
            this._super();
            this._layers = [];
            this._document = document;
            this._image = image;
            this._canvas = canvas;
        },

        /**
         * addLayer
         * 
         * Simply pushes a Layer object into the ImageDocument's layers array.
         * 
         * @access  public
         * @param   Layer layer
         * @return  void
         */
        addLayer: function(layer) {
            this._layers.push(layer);
            this._image.setConfiguration();
        },

        /**
         * deleteAllLayers
         * 
         * @access  public
         * @return  void
         */
        deleteAllLayers: function() {
            for (var x = this._layers.length - 1; x >= 0; x--) {
                this._layers[x].triggerHandler('delete');
            }
            this._image.triggerHandler('delete/all/finish');
        },

        /**
         * each
         * 
         * Runs an interator function against all the layers, with the
         * ImageDocument set as the context.
         * 
         * @access  public
         * @param   Function iterator
         * @return  void
         */
        each: function(iterator) {
            jQuery.each(this._layers, (function(index, layer) {
                iterator.apply(this, [index, layer]);
            }).proxy(this));
        },

        /**
         * filter
         * 
         * Applies a filter function to the layers, returning whichever ones
         * pass the test. Filter function has the ImageDocument set as the
         * context.
         * 
         * @access  public
         * @param   Function filter
         * @return  Array
         */
        filter: function(filter) {
            var matching = [];
            jQuery.each(this._layers, (function(index, layer) {
                if (filter.apply(this, [index, layer]) === true) {
                    matching.push(layer);
                }
            }).proxy(this));
            return matching;
        },

        /**
         * find
         * 
         * Searches through layers for a specific Layer object. Currently
         * supports searching properties and styles on layers. Returns false if
         * no match could be found.
         * 
         * @access  public
         * @param   String type
         * @param   String key
         * @param   mixed value
         * @return  false|Layer
         */
        find: function(type, key, value) {
            var filtered = this.filter(function(index, layer) {
                if (type === 'property') {
                    return layer.getProperty(key) === value;
                }
                if (type === 'style') {
                    return layer.getStyle(key) === value;
                }
                return false;
            });
            if (filtered.length === 0) {
                return false;
            }
            return filtered[0];
        },

        /**
         * getBackgroundBitmapImageLayer
         * 
         * @access  public
         * @return  BackgroundBitmapImageLayer
         */
        getBackgroundBitmapImageLayer: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('background') === true
                    && layer.getProperty('type') === 'image';
            })[0];
        },

        /**
         * getBackgroundRectangleLayer
         * 
         * @access  public
         * @return  BackgroundRectangleLayer
         */
        getBackgroundRectangleLayer: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('background') === true
                    && layer.getProperty('type') === 'rectangle';
            })[0];
        },

        /**
         * getBottomOrderedLayer
         * 
         * Returns the layer that has the lowest order-style value. At the
         * moment, I don't allow specification on whether watermark layers
         * could be returned, since there isn't a way to move watermarks that
         * far back anyhow.
         * 
         * @access  public
         * @return  Layer|false
         */
        getBottomOrderedLayer: function() {
            var layers = this.filter(function(index, layer) {
                return layer.getProperty('background') !== true
                    && layer.getStyle('order') === 0;
            });
            if (layers.length > 0) {
                return layers[0];
            }
            return false;
        },

        /**
         * getBwVectorImageLayers
         * 
         * @note    I check that the color property is not equal to true, rather
         *          than checking if it's set to false, because there was a time
         *          whereby the color property didn't exist on these layers. So
         *          if I were to check for a false value, previously saved
         *          images would cause inconsistencies.
         *          Note that I also address this in VectorImageLayer through
         *          the _normalizeProperties method, so this may be redundant.
         * @access  public
         * @return  Array
         */
        getBwVectorImageLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') === true
                    && layer.getProperty('color') !== true;
            });
        },

        /**
         * getCanvas
         * 
         * @access  public
         * @return  CanvasView
         */
        getCanvas: function() {
            return this._canvas;
        },

        /**
         * getDocument
         * 
         * @access  public
         * @return  Object
         */
        getDocument: function() {
            return this._document;
        },

        /**
         * getForegroundBitmapImageLayers
         * 
         * @access  public
         * @return  Array
         */
        getForegroundBitmapImageLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('background') !== true
                    && layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') !== true
                    && layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getImage
         * 
         * @access  public
         * @return  ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getLayers
         * 
         * Returns all layers in the image document, possibly including
         * watermarks.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Array
         */
        getLayers: function(includeWatermarks) {
            if (includeWatermarks === true) {
                return this._layers;
            }
            return this.filter(function(index, layer) {
                return layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getLockedLayers
         * 
         * @access  public
         * @return  Array
         */
        getLockedLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('locked') === true;
            });
        },

        /**
         * getOrderedLayers
         * 
         * Returns layers that have a order-style property assigned to them,
         * which by nature excludes the background rectangle and background
         * image. Watermarks may be included in the check.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Array
         */
        getOrderedLayers: function(includeWatermarks) {
            return this.filter(function(index, layer) {
                if (includeWatermarks === true) {
                    return layer.getProperty('background') !== true;
                }
                return layer.getProperty('background') !== true
                    && layer.getProperty('watermark') !== true;
            });
        },

        /**
         * getTextLayers
         * 
         * @access  public
         * @return  Array
         */
        getTextLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('type') === 'text';
            });
        },

        /**
         * getTheNounProjectVectorImageLayers
         * 
         * @note    The below logic does not account for TNP icons that are added
         *          to the canvas, a page refresh happens, and at the time of
         *          running this method, the accessor referencing this
         *          resource/asset is not available in memory. This is because
         *          the image document does not contain details on what type
         *          of resource/asset it is inherently (other than the key).
         * @access  public
         * @return  Array
         */
        getTheNounProjectVectorImageLayers: function() {
            return this.filter(function(index, layer) {
                var isVectorImageLayer = layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') === true;
                if (isVectorImageLayer === true) {
                    var imageKey = layer.getProperty('image'),
                        accessor = Stencil.getAccessor(imageKey);
                    if (accessor === false) {
                        return false;
                    }
                    if (imageKey.match(/^asst/) !== null) {
                        return accessor.get('resourceType') === 'TheNounProject';
                    }
                    return accessor.get('platform') === 'TheNounProject';
                }
                return false;
            });
        },

        /**
         * getTopOrderedLayer
         * 
         * Returns the layer that has the highest order-style value, possibly
         * including watermarks.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Layer|false
         */
        getTopOrderedLayer: function(includeWatermarks) {
            var orderedLayers = this.getOrderedLayers(includeWatermarks).length,
                layers = this.filter(function(index, layer) {
                    return layer.getProperty('background') !== true
                        && layer.getStyle('order') === orderedLayers - 1;
                });
            if (layers.length > 0) {
                return layers[0];
            }
            return false;
        },

        /**
         * getVectorImageLayers
         * 
         * @access  public
         * @return  Array
         */
        getVectorImageLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('type') === 'image'
                    && layer.getProperty('vector') === true;
            });
        },

        /**
         * getWatermarkLayers
         * 
         * Returns _only_ watermark layers, which contrasts with the getLayers
         * method when true is passed in, which will return all layers
         * _including_ watermark layers.
         * 
         * @access  public
         * @return  Array
         */
        getWatermarkLayers: function() {
            return this.filter(function(index, layer) {
                return layer.getProperty('watermark') === true;
            });
        },

        /**
         * getWatermarkLayersJson
         * 
         * Returns an object of all the watermark layer's properties as JSON.
         * I am not removing the order style-property, since at the moment, this
         * is only being used to track watermark json in an ImageAccessor to
         * determine if the image has changed, at which point the order of
         * watermarks is important.
         * 
         * @access  public
         * @return  Object
         */
        getWatermarkLayersJson: function() {
            var json = {
                    layers: []
                },
                layers = this.getWatermarkLayers();
            jQuery.each(layers, function(index, layer) {
                json.layers.push(layer.getProperties());
            });
            return json;
        },

        /**
         * json
         * 
         * Returns the JSON representation of the document.
         * 
         * @access  public
         * @param   Boolean includeWatermarks
         * @return  Object
         */
        json: function(includeWatermarks) {
            var json = {
                    layers: []
                },
                layers = this.getLayers(includeWatermarks);
            jQuery.each(layers, function(index, layer) {
                json.layers.push(layer.getProperties());
            });
            return json;
        },

        /**
         * mergeWatermarks
         * 
         * @access  public
         * @return  void
         */
        mergeWatermarks: function() {
            if (Stencil.get('smartToggleWatermarks') === true) {
                var _this = this,
                    document = this._document,
                    imageWatermarksJson = _this._image.setting('watermarks'),
                    imageWatermarks,
                    watermarks = Stencil.account().collection('watermarks'),
                    filters,
                    styles;
                if (imageWatermarksJson === '') {
                    imageWatermarksJson = JSON.stringify({
                        layers: []
                    });
                }
                if (JSONUtils.valid(imageWatermarksJson) === false) {
                    imageWatermarksJson = JSON.stringify({
                        layers: []
                    });
                }
                imageWatermarks = JSON.parse(imageWatermarksJson).layers;

                /**
                 * Loop through all the watermarks that the account has stored
                 * in the associated collection.
                 */
                watermarks.each(function(index, watermark) {
                    var watermarkIsPartOfImage = function(watermark, imageWatermarks) {
                        for (var index in imageWatermarks) {
                            if (imageWatermarks[index].image === watermark.get('key')) {
                                return true;
                            }
                        }
                        return false;
                    };
                    if (watermarkIsPartOfImage(watermark, imageWatermarks) === true) {
                        for (var index in imageWatermarks) {
                            if (imageWatermarks[index].image === watermark.get('key')) {
                                filters = imageWatermarks[index].filters;
                                styles = imageWatermarks[index].styles;
                                styles.order = document.layers.length - 2;
                                document.layers.push({
                                    filters: filters,
                                    image: watermark.get('key'),
                                    styles: styles,
                                    type: 'image',
                                    watermark: true,
                                    locked: false
                                });
                                if (watermark.setting('active').toInt() === 0) {
                                    watermark.set({
                                        'settings.active': 1
                                    });
                                    watermark.save(['settings.active']);
                                }
                            }
                        }
                    } else {
                        if (watermark.setting('active').toInt() === 1) {
                            watermark.set({
                                'settings.active': 0
                            });
                            watermark.save(['settings.active']);
                        }
                    }
                });
            } else {
                Stencil.set('smartToggleWatermarks', false);
                var _this = this,
                    document = this._document,
                    watermarks = Stencil.account().collection('watermarks'),
                    filters,
                    styles,
                    active;
                watermarks.each(function(index, watermark) {
                    active = watermark.setting('active').toInt() === 1;
                    if (active === true) {
                        if (
                            JSONUtils.valid(watermark.setting('filters')) === true
                            && JSONUtils.valid(watermark.setting('styles')) === true
                        ) {
                            filters = JSON.parse(watermark.setting('filters'));
                            styles = JSON.parse(watermark.setting('styles'));
                            styles.order = document.layers.length - 2;
                            document.layers.push({
                                image: watermark.get('key'),
                                filters: filters,
                                styles: styles,
                                type: 'image',
                                watermark: true
                            });
                        } else {
                            StencilBooter.log('JSON parse error (ID:mW)');
                        }
                    }
                });
            }
        },

        /**
         * removeLayer
         * 
         * After removal, loops over the layers, and ensures that a proper
         * order-value is set (since removing a layer changes the order-values
         * across the board).
         * 
         * I only retrieve the ordered layers (for adjusting order-style
         * values), since the background rectangle and background image layers
         * would never be affected by a layer being removed (since they don't
         * have a order-style property, and their order can't actually be
         * changed).
         * 
         * It's important that the layer not be deleted from memory (eg. with a
         * delete call). This is because it might be referenced by a delayed
         * save function (at the moment, only ones I can think of are
         * watermarks). They'll reference the styles / properties of the layer
         * when it goes off and saves things.
         * 
         * @access  public
         * @param   Layer toRemove
         * @return  void
         */
        removeLayer: function(toRemove) {
            this.each(function(index, layer) {
                if (layer === toRemove) {
                    this._layers.splice(index, 1);
                }
            });
            var layers = this.getOrderedLayers(true);
            jQuery.each(layers, function(index, layer) {
                layer.setStyle('order', index);
            });
            this.sortLayers();
            this._image.setConfiguration();
        },

        /**
         * reorderWatermarks
         * 
         * Ensures that the watermarks are the top most layer by adjusting their
         * order-style value. This function works by setting the order of the
         * watermark style value to the index of the watermark among all other
         * watermarks on the canvas, in addition to the number of previous
         * non-watermark layers. You might want to draw this on a piece of paper
         * to help visualize it if you need to.
         * 
         * @access  public
         * @return  void
         */
        reorderWatermarks: function() {
            var ordered = this.getOrderedLayers(false).length,
                watermarks = this.getWatermarkLayers();
            jQuery.each(watermarks, function(index, layer) {
                layer.setStyle('order', index + ordered);
            });
            this.sortLayers();
        },

        /**
         * setImage
         * 
         * @access  public
         * @param   ImageAccessor image
         * @return  void
         */
        setImage: function(image) {
            this._image = image;
        },

        /**
         * setupLayers
         * 
         * @access  public
         * @return  void
         */
        setupLayers: function() {
            var layer,
                klass,
                _this = this;
            this._layers = [];
            jQuery.each(this._document.layers, function(index, properties) {
                klass = false;
                if (properties.type === 'text') {
                    klass = TextLayer;
                } else if (properties.type === 'rectangle') {
                    klass = BackgroundRectangleLayer;
                } else if (properties.type === 'image') {
                    if (properties.vector === true) {
                        if (properties.color === true) {
                            klass = ColorVectorImageLayer;
                        } else {
                            klass = VectorImageLayer;
                        }
                    } else if (properties.watermark === true) {
                        klass = WatermarkBitmapImageLayer;
                    } else {
                        if (properties.background === true) {
                            klass = BackgroundBitmapImageLayer;
                        } else {
                            klass = ForegroundBitmapImageLayer;
                        }
                    }
                }
                layer = new klass(properties, _this);
                if (layer.valid() === true) {
                    _this._layers.push(layer);
                }
            });
        },

        /**
         * sortLayers
         * 
         * I had a lot of trouble with this function, and ended up converting it
         * to a simpler (Sergei inspired) algorithm whereby I convert the
         * toString values to integers based on the desired order (background
         * rectangle as 0, background image as 1, followed by the layers with
         * their style order value being used [with 2 being added since the
         * order values start at 0]). Then when I perform the sort, I simply
         * perform it numerically by casting the strings as integers. After the
         * sort has been completed, I revert the _string values.
         * 
         * While this seems more cumbersome, it's much more dependable than what
         * I was doing before. I have no idea how to use the comparison function
         * with properties :/
         * 
         * @access  public
         * @return  void
         */
        sortLayers: function() {
            jQuery.each(this._layers, function(index, layer) {
                layer._previous = layer._string;
                if (
                    layer.getProperty('type') === 'rectangle'
                    && layer.getProperty('background') === true
                ) {
                    layer._string = 0;
                } else if (
                    layer.getProperty('type') === 'image'
                    && layer.getProperty('background') === true
                ) {
                    layer._string = 1;
                } else {
                    layer._string = layer.getStyle('order').toInt() + 2;
                }
            });
            this._layers.sort(function(a, b) {
                return a.toString().toInt() - b.toString().toInt();
            });
            jQuery.each(this._layers, function(index, layer) {
                layer._string = layer._previous;
                delete layer._previous;
            });
        },

        /**
         * syncLockedState
         * 
         * @access  public
         * @return  void
         */
        syncLockedState: function() {
            var lockedLayers = this.getLockedLayers(),
                draft = Stencil.account().draft();
            if (Account.draftIsLocked() === true) {
                if (lockedLayers.length === 0) {
                    draft.set({
                        'settings.locked': 0
                    });
                    draft.save(['settings.locked']);
                }
            } else {
                if (lockedLayers.length > 0) {
                    draft.set({
                        'settings.locked': 1
                    });
                    draft.save(['settings.locked']);
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Base', function() {

    /**
     * Layer
     * 
     * @fires   change/angle
     *          change/position
     *          change/scale
     *          set/property
     *          set/property/x
     *          set/style
     *          set/style/x
     *          move/up
     *          move/down
     *          move/right
     *          move/left
     *          refresh/dimensions
     * @extends Base
     */
    window.Layer = Base.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     undefined|String (default: undefined)
         */
        _changeHistoryKeyPrefix: undefined,

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'layer')
         */
        _classType: 'layer',

        /**
         * _drawing
         * 
         * @access  protected
         * @var     null|Drawing (default: null)
         */
        _drawing: null,

        /**
         * _imageDocument
         * 
         * @access  protected
         * @var     false|ImageDocument (default: false)
         */
        _imageDocument: false,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return {
                'angle': function() {
                    this.on({
                        'change/angle': function(event, angle) {
                            this.setChangeOperationType('rotated');
                            this.setStyle('angle', angle);
                        }
                    });
                },
                'clone': function() {
                    this.on({
                        'clone': function(event) {
                            this.setChangeOperationType('cloned');
                            this.clone();
                        }
                    });
                },
                'delete': function() {
                    this.on({

                        /*
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() is
                         *          important for the case where a user is dragging
                         *          the layer around, and while they're dragging,
                         *          they click the delete-key. Without the call,
                         *          the canvas change gets registered as a
                         *          move-operation, rather than a delete operation.
                         *          See before/after screenshots below, with the
                         *          code below commented/uncommented out:
                         *          https://i.imgur.com/dgnsQBW.png
                         *          https://i.imgur.com/gCFkf43.png
                         */
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            Canvases.Preview.deselectSelectedLayer();
                            this._imageDocument.removeLayer(this);
                        }
                    });
                },
                'flip': function() {
                    this.on({
                        'flip/x': function(event, flip) {
                            this.setChangeOperationType('flipped:x');
                            this.setStyle('flipX', flip);
                        },
                        'flip/y': function(event, flip) {
                            this.setChangeOperationType('flipped:y');
                            this.setStyle('flipY', flip);
                        }
                    });
                },
                'move': function() {
                    this.on({
                        'move/up': function(event) {
                            var height = this.getCanvas().getRenderedDimensions().height,
                                pixel = ((1 / height) * 100).round(4),
                                top = this._properties.styles.top,
                                adjusted = top - pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('top', rounded);
                        },
                        'move/right': function(event) {
                            var width = this.getCanvas().getRenderedDimensions().width,
                                pixel = ((1 / width) * 100).round(4),
                                left = this._properties.styles.left,
                                adjusted = left + pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('left', rounded);
                        },
                        'move/down': function(event) {
                            var height = this.getCanvas().getRenderedDimensions().height,
                                pixel = ((1 / height) * 100).round(4),
                                top = this._properties.styles.top,
                                adjusted = top + pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('top', rounded);
                        },
                        'move/left': function(event) {
                            var width = this.getCanvas().getRenderedDimensions().width,
                                pixel = ((1 / width) * 100).round(4),
                                left = this._properties.styles.left,
                                adjusted = left - pixel,
                                rounded = adjusted.round(4);
                            this.setStyle('left', rounded);
                        }
                    });
                },
                'order': function() {
                    this.on({
                        'change/order': function(event, forward) {
                            if (forward === true) {
                                this.setChangeOperationType('sent:forward');
                                this.bringForward();
                            } else {
                                this.setChangeOperationType('sent:back');
                                this.sendBack();
                            }
                        }
                    });
                },
                'position': function() {
                    this.on({
                        'change/position': function(event, position) {
                            this.setChangeOperationType('moved');
                            this.setStyles({
                                'left': position.left,
                                'top': position.top
                            });
                        }
                    });
                },
                'properties': function() {
                    this.on({
                        'set/property': function(event, name, value, previous) {
                            this._imageDocument.getImage().setConfiguration();
                        },
                        'set/style': function(event, name, value, previous) {
                            this._imageDocument.getImage().setConfiguration();
                        }
                    });
                }
            };
        },

        /**
         * _properties
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _properties: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Layer')
         */
        _string: 'Layer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super();
            this._properties = properties;
            this._setupListeners();
            this._imageDocument = imageDocument;
        },

        /**
         * _setupListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupListeners: function() {
            this._listeners = this._listeners();
            for (var index in this._listeners) {
                this._listeners[index].apply(this);
            }
        },

        /**
         * autoAlign
         * 
         * @access  public
         * @return  void
         */
        autoAlign: function() {
            this.setChangeOperationType('centered');
            this._drawing.autoAlign();
        },

        /**
         * back
         * 
         * Returns whether the layer is the back-most layer, which is currently
         * exclusively used to determine whether or not the front / back buttons
         * should be shown. Because of this, it's not a truly semantic method,
         * since what it really means is "is it the front-most non-background
         * layer". Heads up incase an issue comes up down the line related to
         * this.
         * 
         * Also note that it doesn't take watermarks into consideration at the
         * moment, since they're always the front-most layers.
         * 
         * @access  public
         * @return  Boolean
         */
        back: function() {
            return this === this._imageDocument.getBottomOrderedLayer();
        },

        /**
         * bringForward
         * 
         * Sends the layer one order forward, adjusting the one it replaced to
         * take it's order-value.
         * 
         * @todo!   Detect if the layer is overlapping any other ones, and when
         *          it is, show the layer-UI button options. This might prevent
         *          people from clicking them when there are no overlap layers,
         *          and not noticing a change (and thus not sure what the
         *          buttons do)
         * @access  public
         * @return  void
         */
        bringForward: function() {
            var order = this._properties.styles.order.toInt(),
                layer = this._imageDocument.find(
                    'style',
                    'order',
                    order + 1
                );
            this.setStyle('order', order + 1);
            layer.setStyle('order', order);
            this._imageDocument.sortLayers();
        },

        /**
         * clone
         * 
         * @access  public
         * @return  void
         */
        clone: function() {
            var properties = jQuery.extend(true, {}, this._properties),
                canvas = this.getCanvas();
            properties.styles.order = this._imageDocument.getOrderedLayers(false).length;
            properties.styles.left += 5;
            properties.styles.top += 5;
            var layer = new this.constructor(properties, this._imageDocument),
                drawing = layer.getDrawing();
            this._imageDocument.addLayer(layer);
            this._imageDocument.reorderWatermarks();
            drawing.once({
                'draw': function(event) {
                    this.select();
                    canvas.render();
                    drawing.animate();
                }
            });
            drawing.draw();
        },

        /**
         * front
         * 
         * Returns whether the layer is the front-most layer, which is currently
         * exclusively used to determine whether or not the front / back buttons
         * should be shown. Because of this, it's not a truly semantic method,
         * since what it really means is "is it the front-most non-watermark
         * layer". Heads up incase an issue comes up down the line related to
         * this.
         * 
         * @access  public
         * @return  Boolean
         */
        front: function() {
            return this === this._imageDocument.getTopOrderedLayer(false);
        },

        /**
         * getCanvas
         * 
         * @access  public
         * @return  CanvasView
         */
        getCanvas: function() {
            return this._imageDocument.getCanvas();
        },

        /**
         * getCotton
         * 
         * @access  public
         * @return  fabric.Object
         */
        getCotton: function() {
            return this._drawing.getCotton();
        },

        /**
         * getDrawing
         * 
         * @access  public
         * @return  Drawing
         */
        getDrawing: function() {
            return this._drawing;
        },

        /**
         * getImageDocument
         * 
         * @access  public
         * @return  ImageDocument
         */
        getImageDocument: function() {
            return this._imageDocument;
        },

        /**
         * getProperties
         * 
         * @access  public
         * @return  Object
         */
        getProperties: function() {
            return this._properties;
        },

        /**
         * getProperty
         * 
         * @access  public
         * @param   String name
         * @return  mixed
         */
        getProperty: function(name) {
            return this._properties[name];
        },

        /**
         * getStyle
         * 
         * @access  public
         * @param   String name
         * @return  mixed
         */
        getStyle: function(name) {
            return this._properties.styles[name];
        },

        /**
         * getStyles
         * 
         * @access  public
         * @return  Object
         */
        getStyles: function() {
            return this._properties.styles;
        },

        /**
         * goto
         * 
         * @access  public
         * @var     Object
         */
        goto: {

            /**
             * previous
             * 
             * Focuses on the layer in the position lower than the selected
             * one. If no layer is lower, it grabs the top layer. If no layer
             * other than the one already selected is found, nothing happens.
             * 
             * @access  public
             * @return  void
             */
            previous: function() {
                var order = this._properties.styles.order.toInt(),
                    previousLayer = this._imageDocument.find(
                        'style',
                        'order',
                        order - 1
                    );
                if (previousLayer === false) {
                    var activeBackgroundLayer = Canvases.Preview.getActiveBackgroundLayer();
                    activeBackgroundLayer.select();
                } else {
                    if (previousLayer !== this.getCanvas().getSelectedLayer()) {
                        previousLayer.select();
                    }
                }
            },

            /**
             * next
             * 
             * Focuses on the layer in the position higher than the selected
             * one. If no layer is higher, it grabs the bottom layer. If no
             * layer other than the one already selected is found, nothing
             * happens.
             * 
             * @access  public
             * @return  void
             */
            next: function() {
                var order = this._properties.styles.order.toInt(),
                    nextLayer = this._imageDocument.find(
                        'style',
                        'order',
                        order + 1
                    );
                if (nextLayer === false) {
                    var activeBackgroundLayer = Canvases.Preview.getActiveBackgroundLayer();
                    activeBackgroundLayer.select();
                } else {
                    if (nextLayer !== this.getCanvas().getSelectedLayer()) {
                        nextLayer.select();
                    }
                }
            }
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            this._drawing.select();
        },

        /**
         * sendBack
         * 
         * Sends the layer one order back, adjusting the one it replaced to take
         * it's position-value.
         * 
         * @todo!   Detect if the layer is overlapping any other ones, and when
         *          it is, show the layer-UI button options. This might prevent
         *          people from clicking them when there are no overlap layers,
         *          and not noticing a change (and thus not sure what the
         *          buttons do)
         * @access  public
         * @return  void
         */
        sendBack: function() {
            var order = this._properties.styles.order.toInt(),
                layer = this._imageDocument.find(
                    'style',
                    'order',
                    order - 1
                );
            this.setStyle('order', order - 1);
            layer.setStyle('order', order);
            this._imageDocument.sortLayers();
        },

        /**
         * setImageDocument
         * 
         * @access  public
         * @param   ImageDocument imageDocument
         * @return  void
         */
        // setImageDocument: function(imageDocument) {
        //     this._imageDocument = imageDocument;
        // },

        /**
         * setChangeOperationType
         * 
         * This is more or less a proxy for the ChangeHistory setOperatioType
         * method, to simplify the type that is passed. I lookup the type-prefix
         * for this layer, and pass that along.
         * 
         * @access  public
         * @param   String typePrefix
         * @return  void
         */
        setChangeOperationType: function(typePrefix) {
            var changeHistoryKeyPrefix = this._changeHistoryKeyPrefix,
                type = (changeHistoryKeyPrefix) + (typePrefix);
            ChangeHistory.setOperationType(type);
        },

        /**
         * setProperty
         * 
         * @access  public
         * @param   String name
         * @param   String value
         * @return  mixed
         */
        setProperty: function(name, value) {
            var previous = this._properties[name];
            this._properties[name] = value;
            this.triggerHandler('set/property', [name, value, previous]);
            this.triggerHandler('set/property/' + (name), [value, previous]);
        },

        /**
         * setStyle
         * 
         * @access  public
         * @param   String name
         * @param   mixed value
         * @return  void
         */
        setStyle: function(name, value) {
            var previous = this._properties.styles[name];
            this._properties.styles[name] = value;
            this.triggerHandler('set/style', [name, value, previous]);
            this.triggerHandler('set/style/' + (name), [value, previous]);
        },

        /**
         * setStyles
         * 
         * @access  public
         * @param   Object styles
         * @return  void
         */
        setStyles: function(styles) {
            for (var property in styles) {
                this.setStyle(property, styles[property]);
            }
            this.triggerHandler('set/styles', [styles]);
        },

        /**
         * valid
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            return true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageLayer', function() {

    /**
     * BackgroundBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.BackgroundBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, background: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, background: true // ',

        /**
         * _listeners
         * 
         * @see     http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'image/changed': function() {
                    this.on({
                        'set/property/image': function(event, value, previous) {
                            if (value === false) {
                                this.setProperty('locked', false);
                            }
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundBitmapImageLayer')
         */
        _string: 'BackgroundBitmapImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new BackgroundBitmapImageDrawing(this);
            this.listenForGatewaySave();
            this.setupGatewaySave();
        },

        /**
         * _normalizeProperties
         * 
         * @access  protected
         * @param   Object properties
         * @return  Object
         */
        _normalizeProperties: function(properties) {
            properties = this._super(properties);
            if (properties.styles.zoom === undefined) {
                properties.styles.zoom = 1;
            }
            return properties;
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  BackgroundBitmapImageToolbarView
         */
        getToolbar: function() {
            return Toolbars.getToolbar('backgroundBitmapImage');
        },

        /**
         * goto
         * 
         * @access  public
         * @var     Object
         */
        goto: {

            /**
             * previous
             * 
             * @access  public
             * @return  void
             */
            previous: function() {
                var topLayer = this._imageDocument.getTopOrderedLayer(true);
                if (topLayer !== false) {
                    topLayer.select();
                }
            },

            /**
             * next
             * 
             * @access  public
             * @return  void
             */
            next: function() {
                var bottomLayer = this._imageDocument.getBottomOrderedLayer(
                    true
                );
                if (bottomLayer !== false) {
                    bottomLayer.select();
                }
            }
        },

        /**
         * listenForGatewaySave
         * 
         * Listens for a save event against the ResourceAccessor that this
         * BackgroundBitmapImageLayer is set to (if any). This listener works a
         * bit differently than the similar one in VectorImageLayer layers, in
         * that it gets called multiple times. Specifically, whenever a
         * 3rd-party resource (at the moment, just Pixabay) is set as the
         * background image. This is because these layers work differently than
         * VectorImageLayer layers, in that they're never deleted, just shown /
         * hidden.
         * 
         * That being said, the calls need to exist in the constructor as well
         * to allow for the case when a 3rd-party resource is selected, and
         * before it's saved, a save attempt is made. In that case, when the
         * constructor is called, the image-property will be referencing that
         * 3rd-party resource, and the listener and save attempt logic need to
         * be triggered.
         * 
         * @access  public
         * @return  void
         */
        listenForGatewaySave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.getProperty('image') === previousKey) {
                            var newKey = asset.get('key');
                            ChangeHistory.syncResourceKeyInOperations(
                                previousKey,
                                newKey
                            );
                            _this.setImage(newKey);
                            var canvas = _this.getCanvas(),
                                background = canvas.getBackgroundBitmapImageLayer();
                            if (background.getCanvas() !== Canvases.Ghost) {
                                var drawing = background.getDrawing();
                                drawing.once({
                                    'refresh': function(event) {
                                        canvas.render();
                                    }
                                });
                                drawing.reload();
                            }
                        }
                    }
                });
            }
        },

        /**
         * setImage
         * 
         * This is a helper-method for dealing with times when the
         * image-property for the layer needs to change. It's intention was to
         * reset position-styles when needed, hide the layer which an image was
         * being removed, and change the image-property in the layer.
         * 
         * @access  public
         * @param   String|false image
         * @return  void
         */
        setImage: function(image) {

            /**
             * Image is being reset (eg. color being applied). I hide the layer
             * instead of deleting it, which would be the natually assumption,
             * to ensure the layer is always available.
             */
            if (image === false) {
                this.setStyles({
                    'flipX': false,
                    'flipY': false,
                    'left': 50,
                    'top': 50
                });
                this.getCotton().set({
                    'flipX': false,
                    'flipY': false,
                    'visible': false
                });
            } else {

                /**
                 * Reset position styles if the following are all true:
                 * 1. Image key is an asset
                 * 2. The asset doesn't correspond to a 3rd party resource that
                 *    is already set within the layer (detected via the
                 *    <getHash> check)
                 * 3. The asset isn't already set within the layer
                 */
                if (image.match(/^asst/) !== null) {
                    var asset = Stencil.getAccessor(image);
                    if (asset.getHash() !== this._properties.image) {
                        if (this._properties.image !== asset.get('key')) {
                            this.setStyles({
                                'flipX': false,
                                'flipY': false,
                                'left': 50,
                                'top': 50
                            });
                            this.getCotton().set({
                                'flipX': this._properties.styles.flipX,
                                'flipY': this._properties.styles.flipY
                            });
                        }
                    }
                }
                /**
                 * Not an asset, so it could be an upload or resource reference.
                 * Just check whether the image is being switched, or set to the
                 * same record.
                 */
                else {
                    if (image !== this._properties.image) {
                        this.setStyles({
                            'flipX': false,
                            'flipY': false,
                            'left': 50,
                            'top': 50
                        });
                        this.getCotton().set({
                            'flipX': this._properties.styles.flipX,
                            'flipY': this._properties.styles.flipY
                        });
                    }
                }
            }

            // Go ahead and switch the image
            this.setProperty('image', image);
        },

        /**
         * setupGatewaySave
         * 
         * Very similar to the save logic setup in VectorImageLayer layers, with
         * the exception that a save call is not made if the image-property is
         * different than the one when this method was initially called. This is
         * because these layers are never deleted, just shown / hidden.
         * 
         * Like the listener method above, this method is called each time the
         * image is changed.
         * 
         * This delay-method is not prone to the issues that VectorImageLayer
         * layers are because of the property-check that is being made below
         * within the delayed function. That check prevents a possible issue
         * whereby the _getResource method was returning an AssetAccessor
         * (instead of a ResourceAccessor), therefore circumventing the issue.
         * 
         * If that check was not being made, then yes, the _getResource lookup
         * would need to be executed before the delay.
         * 
         * @access  public
         * @return  void
         */
        setupGatewaySave: function() {
            if (this._isResource() === true) {
                var delay = Stencil.getSaveDelay('resource'),
                    resource = this._getResource(),
                    key = this._properties.image;
                (function() {
                    if (this.getProperty('image') === key) {
                        resource.save();
                    }
                }).delay(delay, this);
            }
        },
        // https://github.com/onassar/Stencil/blob/9cbc58f42361ee2ddbdeb53c54fd5c64ae2fda75/TurtlePHP/application/webroot/app/static/js/layers/BackgroundBitmapImage.js
        // https://i.imgur.com/seOP36x.png

        /**
         * valid
         * 
         * I'm overriding the parent method because I need to ensure a
         * BackgroundBitmapImageLayer is always part of the image document. So
         * here, I use the parent to check if it's a valid layer (which in this
         * case means that if an image value is defined, it's set to an upload
         * or asset record), and if it's not, I still return true to ensure the
         * layer is not "skipped".
         * 
         * It should not cause any issues, since in the parent <valid> method,
         * it properly updates the image-property for the layer.
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            var image = this._properties.image;
            if (image === false) {
                return true;
            }
            if (this._super() === true) {
                return true;
            }
            return true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('RectangleLayer', function() {

    /**
     * BackgroundRectangleLayer
     * 
     * @extends RectangleLayer
     */
    window.BackgroundRectangleLayer = RectangleLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: rectangle, background: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: rectangle, background: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'backgroundColor': function() {
                    this.on({
                        'change/backgroundColor': function(event, backgroundColor, removed) {
                            if (removed === true) {
                                this.setChangeOperationType('backgroundColor:removed');
                            } else {
                                this.setChangeOperationType('backgroundColor:changed');
                            }
                            this.setStyle('backgroundColor', backgroundColor);
                        },
                        'clear/backgroundColor': function(event) {
                            this.setChangeOperationType('backgroundColor:cleared');
                            var transparentBlack = ColorUtils.getBlack('rgba', 0);
                            this.setStyle('backgroundColor', transparentBlack);
                        },
                        'reset/backgroundColor': function(event) {
                            var white = ColorUtils.getWhite('rgba');
                            this.setStyle('backgroundColor', white);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundRectangleLayer')
         */
        _string: 'BackgroundRectangleLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new BackgroundRectangleDrawing(this);
        },

        /**
         * goto
         * 
         * @access  public
         * @var     Object
         */
        goto: {

            /**
             * previous
             * 
             * @access  public
             * @return  void
             */
            previous: function() {
                var topLayer = this._imageDocument.getTopOrderedLayer(true);
                if (topLayer !== false) {
                    topLayer.select();
                }
            },

            /**
             * next
             * 
             * @access  public
             * @return  void
             */
            next: function() {
                var bottomLayer = this._imageDocument.getBottomOrderedLayer(
                    true
                );
                if (bottomLayer !== false) {
                    bottomLayer.select();
                }
            }
        },

        /**
         * hasTransparency
         * 
         * @access  public
         * @return  Boolean
         */
        hasTransparency: function() {
            var backgroundColor = this._properties.styles.backgroundColor,
                opacity = ColorUtils.getAlpha(backgroundColor);
            return opacity !== 1;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageLayer', function() {

    /**
     * BitmapImageLayer
     * 
     * @extends ImageLayer
     */
    window.BitmapImageLayer = ImageLayer.extend({

        /**
         * _listeners
         * 
         * @see     http://stackoverflow.com/questions/9792927/javascript-array-search-and-remove-string
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'filters': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            var filters = this.getProperty('filters');
                            filters.push(obj);
                            this.setProperty('filters', filters);
                        },
                        'filter/remove': function(event, obj) {
                            var filters = this.getProperty('filters');
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].type === obj.type) {
                                    filters.splice(i, 1);
                                }
                            }
                            this.setProperty('filters', filters);
                        },
                        'filter/update': function(event, obj) {
                            var filters = this.getProperty('filters');
                            for (var i = filters.length - 1; i >= 0; i--) {
                                if (filters[i].type === obj.type) {
                                    filters[i].properties = obj.properties;
                                }
                            }
                            this.setProperty('filters', filters);
                        }
                    });
                },
                'colorOverlay': function() {
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @note    There's a debounce on this because it results
                         *          in bitmap-level changes, which is slow.
                         */
                        'change/colorOverlay': _.debounce(
                            function(event, colorOverlay) {
                                var filter = this.getFilter('colorOverlay');
                                this.set({'renderFilters': true});
                                if (filter === false) {
                                    this.setChangeOperationType('filter:colorOverlay:added');
                                    this.triggerHandler('filter/add', [{
                                        type: 'colorOverlay',
                                        properties: {
                                            color: colorOverlay,
                                            strength: 75
                                        }
                                    }]);
                                } else {
                                    this.setChangeOperationType('filter:colorOverlay:set');
                                    filter.properties.color = colorOverlay;
                                    this.triggerHandler('filter/update', [filter]);
                                }

                                // 
                                App.triggerHandler('changeHistory/track');
                                // $range.on({
                                //     'mouseup': function(event) {
                                //         (function() {
                                //             App.triggerHandler('changeHistory/track');
                                //         }).delay(filterResampleDelay);
                                //     }
                                // });
                            },
                            Stencil.getFilterResampleDelay()
                        ),
                        'clear/colorOverlay': function(event) {
                            var filter = this.getFilter('colorOverlay');
                            if (filter !== false) {
                                this.setChangeOperationType('filter:colorOverlay:cleared');
                                this.set({'renderFilters': true});
                                this.triggerHandler('filter/remove', [filter]);
                            }
                        }
                    });
                },
                'customFiltersStrengths': function() {
                    var customFilterTypes = [
                            'blur',
                            'colorOverlay',
                            'darken',
                            'lighten',
                            'opacity'
                        ],
                        _this = this,
                        index,
                        customFilterType,
                        eventType;
                    for (index in customFilterTypes) {
                        customFilterType = customFilterTypes[index];
                        eventType = 'change/' + (customFilterType) + 'Strength';
                        (function(customFilterType) {
                            _this.on(
                                eventType,
                                function(event, strength) {
                                    strength = strength.toInt();
                                    _this.set({'renderFilters': true});
                                    if (strength === 0) {
                                        _this.setChangeOperationType('filter:' + (customFilterType) + ':removed');
                                        this.triggerHandler('filter/remove', [{
                                            type: customFilterType
                                        }]);
                                        if (customFilterType === 'colorOverlay') {
                                            var toolbar = _this.getToolbar();
                                            toolbar.colorOverlay.clear.apply(
                                                toolbar
                                            );
                                        }
                                    } else {
                                        var filter = _this.getFilter(customFilterType);
                                        if (filter === false) {
                                            _this.setChangeOperationType('filter:' + (customFilterType) + ':added');
                                            var properties = {
                                                strength: strength
                                            };
                                            if (customFilterType === 'colorOverlay') {
                                                var color = ColorUtils.getBlack('rgba'),
                                                    toolbar = _this.getToolbar();
                                                properties.color = color;
                                                toolbar._set.colorOverlay.apply(toolbar, [color]);
                                                toolbar.colorOverlay.show.apply(toolbar);
                                            }
                                            this.triggerHandler('filter/add', [{
                                                type: customFilterType,
                                                properties: properties
                                            }]);
                                        } else {
                                            _this.setChangeOperationType('filter:' + (customFilterType) + ':set');
                                            filter.properties.strength = strength;
                                            this.triggerHandler('filter/update', [filter]);
                                        }
                                    }
                                }
                            );
                        })(customFilterType);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BitmapImageLayer')
         */
        _string: 'BitmapImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            properties = this._normalizeProperties(properties);
            this._super(properties, imageDocument);
        },

        /**
         * _normalizeProperties
         * 
         * When we first launched Stencil, filters were stored in an array as an
         * array of strings. They were simply strings like "darken", "lighten"
         * etc. However when we introduced the new filters system, we started
         * storing filters as an array of objects, where the object defined the
         * type of filter, along with properties (eg. strength, color, etc).
         * 
         * So we normalize that here to ensure the same object storage pattern,
         * thus making operations against it simpler.
         * 
         * @access  protected
         * @param   Object properties
         * @return  Object
         */
        _normalizeProperties: function(properties) {
            if (properties.filters === undefined) {
                properties.filters = [];
            } else {
                var filter, index, normalized;
                for (index in properties.filters) {
                    filter = properties.filters[index];
                    if (typeof filter === 'string') {
                        normalized = {
                            type: filter,
                            properties: {}
                        };
                    } else {
                        normalized = {
                            type: filter.type,
                            properties: filter.properties || {}
                        };
                    }
                    properties.filters[index] = normalized;
                }
            }
            return properties;
        },

        /**
         * clearFilters
         * 
         * @note    The renderFilters set and render are called after all filters
         *          have been removed to ensure a render isn't done for each one.
         * @access  public
         * @return  void
         */
        clearFilters: function() {
            var filters = this.getProperty('filters'),
                x = filters.length - 1;
            for (; x >= 0; x--) {
                this.triggerHandler('filter/remove', [filters[x]]);
            }
            this.set({'renderFilters': true});
            this.getCanvas().render();
        },

        /**
         * getFilter
         * 
         * @access  public
         * @param   String type
         * @return  Object|false
         */
        getFilter: function(type) {
            var filters = this.getProperty('filters'),
                index;
            for (index in filters) {
                if (type === filters[index].type) {
                    return filters[index];
                }
            }
            return false;
        },

        /**
         * sortFilters
         * 
         * @access  public
         * @return  void
         */
        sortFilters: function() {
            var cotton = this.getCotton(),
                filters = cotton.get('filters');
            filters.sort(function(a, b) {
                if (a.get('_stencilType') < b.get('_stencilType')) {
                    return -1;
                }
                if (a.get('_stencilType') > b.get('_stencilType')) {
                    return 1;
                }
                return 0;
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageLayer', function() {

    /**
     * ColorVectorImageLayer
     * 
     * @extends VectorImageLayer
     */
    window.ColorVectorImageLayer = VectorImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, vector: true, color: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, vector: true, color: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'opacityStrength': function() {
                    this.on({
                        'change/opacityStrength': function(event, opacityStrength) {
                            this.setChangeOperationType('opacityStrength:changed');
                            var opacityValue = ((100 - opacityStrength) / 100).round(2);
                            this.setStyle('opacity', opacityValue);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorVectorImageLayer')
         */
        _string: 'ColorVectorImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new ColorVectorImageDrawing(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageLayer', function() {

    /**
     * ForegroundBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.ForegroundBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, background: false // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, background: false // ',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ForegroundBitmapImageLayer')
         */
        _string: 'ForegroundBitmapImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new ForegroundBitmapImageDrawing(this);
            this._listenForGatewaySave();
            this._setupGatewaySave();
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  ForegroundBitmapImageToolbarView
         */
        getToolbar: function() {
            return Toolbars.getToolbar('foregroundBitmapImage');
        },

        /**
         * listenForGatewaySave
         * 
         * @access  protected
         * @return  void
         */
        _listenForGatewaySave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousyKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.get('deleted') === undefined) {
                            var newKey = asset.get('key');
                            ChangeHistory.syncResourceKeyInOperations(
                                previousyKey,
                                newKey
                            );
                            _this.getImageDocument().getImage().set({
                                'resourceGatewaySave': '1'
                            });
                            _this.setProperty('image', newKey);
                            var canvas = _this.getCanvas();
                            if (canvas !== Canvases.Ghost) {
                                var drawing = _this.getDrawing();
                                drawing.once({
                                    'refresh': function(event) {
                                        canvas.render();
                                    }
                                });
                                drawing.refresh();
                            }
                        }
                    }
                });
            }
        },

        /**
         * _setupGatewaySave
         * 
         * @note    See layers/VectorImage.js for documentation on this method.
         * @access  protected
         * @return  void
         */
        _setupGatewaySave: function() {
            if (this._isResource() === true) {
                var delay = Stencil.getSaveDelay('resource'),
                    resource = this._getResource();
                (function() {
                    if (this.get('deleted') === undefined) {
                        resource.save();
                    }
                }).delay(delay, this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Layer', function() {

    /**
     * ImageLayer
     * 
     * @extends Layer
     */
    window.ImageLayer = Layer.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'delete': function() {
                    this.on({

                        /*
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() is
                         *          important for the case where a user is dragging
                         *          the layer around, and while they're dragging,
                         *          they click the delete-key. Without the call,
                         *          the canvas change gets registered as a
                         *          move-operation, rather than a delete operation.
                         *          See before/after screenshots below, with the
                         *          code below commented/uncommented out:
                         *          https://i.imgur.com/dgnsQBW.png
                         *          https://i.imgur.com/gCFkf43.png
                         */
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            Canvases.Preview.deselectSelectedLayer();
                            this._imageDocument.removeLayer(this);
                            Stencil.account().draft().getImageDocument().syncLockedState();
                        }
                    });
                },
                'dimensions': function() {
                    this.on({
                        'change/dimensions': function(event, dimensions) {
                            this.setChangeOperationType('scaled');
                            this.setStyles({
                                'flipX': dimensions.flipX,
                                'flipY': dimensions.flipY,
                                'left': dimensions.left,
                                'stretchX': dimensions.stretchX,
                                'stretchY': dimensions.stretchY,
                                'top': dimensions.top,
                                'width': dimensions.width
                            });
                        }
                    });
                },
                'locked': function() {
                    this.on({
                        'set/property/locked': function(event, locked) {
                            Stencil.account().draft().getImageDocument().syncLockedState();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageLayer')
         */
        _string: 'ImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
        },

        /**
         * _getResource
         * 
         * Returns a ResourceAccessor relating to a 3rd-party resource, or else
         * false if it couldn't be found in memory.
         * 
         * @access  protected
         * @return  ResourceAccessor|false
         */
        _getResource: function() {
            var key = this._properties.image;
            return Stencil.getAccessor(key);
        },

        /**
         * _isResource
         * 
         * Checks whether the key specified by the image property value
         * corresponds to a 3rd-party resource, and that it's availabel in
         * memory.
         * 
         * Note that the key equaling false check is only made to accommodate
         * BackgroundBitmapImageLayer layers, which allow for this. This will
         * not ever happy with VectorImageLayer layers.
         * 
         * @access  protected
         * @return  Boolean
         */
        _isResource: function() {
            var key = this._properties.image;
            if (key === false) {
                return false;
            }
            if (key.match(/^asst/) === null && key.match(/^upld/) === null) {
                return this._getResource() !== false;
            }
            return false;
        },

        /**
         * getAccessor
         * 
         * @access  protected
         * @return  false|Accessor
         */
        getAccessor: function() {
            var key = this._properties.image,
                accessor;
            if (key === false) {
                return false;
            }
            accessor = Stencil.getAccessor(key);
            if (accessor !== false) {
                return accessor;
            }
            if (key.match(/^asst/) !== null) {
                return Stencil.setAccessor(key, 'Asset', {
                    key: key
                });
            }
            if (key.match(/^upld/) !== null) {
                return Stencil.setAccessor(key, 'Upload', {
                    key: key
                });
            } else {
                return Stencil.setAccessor(key, 'Resource', {
                    key: key
                });
            }
        },

        /**
         * valid
         * 
         * Returns whether the layer has a valid image defined. A valid image is
         * one that points to either an asset or upload record, or else resource
         * accessor. This needs to happen because it's possible that when a user
         * chooses a TNP icon or Pixabay image, something goes wrong when trying
         * to save it and change the image key for the layer from the 3rd party
         * resource id/hash to the Stencil asset. Without this check, it's
         * possible that if something does go wrong, the image document will
         * fail to be drawn.
         * 
         * So for the end user, it's possible that something might appear to be
         * "missing" for them, but it's to prevent larger issues.
         * 
         * In real life, this could happen in the following situation:
         * They click an icon from the search results, and it gets added to the
         * canvas. If something breaks on the server side and the resource can't
         * be saved as an asset, the user will then see the ErrorModal view.
         * After this, they'll reload the page, with an image document that has
         * a layer, which in turn has an image-property referencing a TNP or
         * Pixabay resource. That is when this method is useful; it will ensure
         * that the canvas is still drawn, simply by "skipping" over the defunkt
         * layer (this "skipping" logic is done elsewhere).
         * 
         * Note that if the above situation does occur, it's possible for the
         * layer not to be marked as defunkt, because if the ImageAccessor's
         * <saveConfiguration> method doesn't fire before the ErrorModal UI
         * kills the app, the layer won't actually be saved to the DB. But it is
         * possible, if for instance it takes a long time to save the resource.
         * In that case, the ImageAccessor's saveConfiguration method may have
         * fired, thus saving to the DB, and thus turning the image defunkt.
         * 
         * Another possible case is if the user chooses a Pixabay image, and
         * closes the app before the /save call has gone out, but after the
         * PATCH call has. In that case, the draft is referencing a resource, so
         * when they revisit the app, it could break unless this validiation
         * method is called.
         * 
         * After checking for an asset or upload (via the /^asst/ and /^upld/
         * regular expressions), I check if the image is an accessor on the
         * page, since if the user very-quickly adds a resource to the canvas,
         * and before it's saved as an asset, tries to download the image, the
         * Ghost canvas will be referencing a resource (eg. TheNounProject:123),
         * which is valid, since it's in memory. This therefore needs to pass.
         * 
         * Also note that if the image is invalid, I set the image-property to
         * false. This is to ensure in the next image-saveConfiguration call
         * that goes out, the json for the image no longer references a defunkt
         * image property.
         * 
         * @access  public
         * @return  Boolean
         */
        valid: function() {
            var key = this._properties.image;
            if (key.match(/^asst/) !== null || key.match(/^upld/) !== null) {
                return true;
            }
            if (Stencil.getAccessor(key) !== false) {
                return true;
            }
            this.log('Layer marked as invalid', true);
            this.setProperty('image', false);
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Layer', function() {

    /**
     * RectangleLayer
     * 
     * @extends Layer
     */
    window.RectangleLayer = Layer.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RectangleLayer')
         */
        _string: 'RectangleLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Layer', function() {

    /**
     * TextLayer
     * 
     * @fires   change/fontFamily
     *          change/backdropColor
     *          change/fontSize
     *          change/bold
     *          change/italic
     *          change/underline
     *          change/align
     *          change/textColor
     *          change/text
     *          change/strokeColor
     * @extends Layer
     */
    window.TextLayer = Layer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: text // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: text // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'align': function() {
                    this.on({
                        'change/align': function(event, align) {
                            if (this.getStyle('align') !== align) {
                                this.setChangeOperationType('aligned:' + (align));
                            }
                            this.setStyle('align', align);
                        }
                    });
                },
                'backdropColor': function() {
                    this.on({
                        'change/backdropColor': function(event, backdropColor) {
                            var backdropAdded = this.getStyle('backdropColor') === false;
                            if (backdropAdded === true) {
                                this.setChangeOperationType('backdrop:colorAdded');
                            } else {
                                this.setChangeOperationType('backdrop:colorChanged');
                            }
                            this.setStyle('backdropColor', backdropColor);
                        },
                        'change/backdropStretch': function(event, backdropStretch) {
                            this.setChangeOperationType('backdrop:stretchChanged');
                            this.setStyle('backdropStretch', backdropStretch);
                        },
                        'clear/backdropColor': function(event) {
                            this.setChangeOperationType('backdrop:removed');
                            this.setStyle('backdropColor', false);
                        }
                    });
                },
                'bold': function() {
                    this.on({
                        'change/bold': function(event, bold) {
                            this.setStyle('bold', bold === true);
                            var changeName = 'bold:' + (
                                bold === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        },
                        'revert/bold': function(event) {
                            this.setStyle('bold', false);
                        }
                    });
                },
                /**
                 * Notice tht I'm accessing the fonts dropdown, and initiating a
                 * close call against it. This is because it's possible that a
                 * user selects a text layer, opens up the fonts drop down, and
                 * then presses the delete key on their keyboard. In this case,
                 * it's important to ensure the fonts dropdown is closed.
                 */
                'delete': function() {
                    this.on({

                        /*
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() is
                         *          important for the case where a user is dragging
                         *          the layer around, and while they're dragging,
                         *          they click the delete-key. Without the call,
                         *          the canvas change gets registered as a
                         *          move-operation, rather than a delete operation.
                         *          See before/after screenshots below, with the
                         *          code below commented/uncommented out:
                         *          https://i.imgur.com/dgnsQBW.png
                         *          https://i.imgur.com/gCFkf43.png
                         */
                        'delete': function(event, obj) {
                            if (obj !== undefined && obj.trigger !== 'undefined') {
                                if (obj.trigger === 'key.delete') {
                                    ChangeHistory.clearOperationType();
                                }
                            }
                            this.setChangeOperationType('deleted');
                            this.set({'deleted': true});
                            Canvases.Preview.deselectSelectedLayer();
                            this._imageDocument.removeLayer(this);
                            Toolbars.getToolbar('text').getFontsDropdown().close();
                        }
                    });
                },
                'dimensions': function() {
                    this.on({
                        'change/dimensions': function(event, dimensions) {
                            this.setStyles({
                                'left': dimensions.left,
                                'top': dimensions.top,
                                'width': dimensions.width
                            });
                        },
                        'refresh/dimensions': function(event) {
                            var dimensions = this._drawing.getDimensions();
                            this.triggerHandler(
                                'change/dimensions',
                                dimensions
                            );
                        }
                    });
                },
                'fontFamily': function() {
                    this.on({

                        /**
                         * (anonymous)
                         * 
                         * @access  private
                         * @param   Object event
                         * @param   FontAccessor font
                         * @return  void
                         */
                        'change/fontFamily': function(event, font) {
                            this.setChangeOperationType('fontFamilyChanged');
                            var fontFamily = font.get('familyName');
                            this.setStyle('fontFamily', fontFamily);
                        }
                    });
                },
                'fontSize': function() {
                    this.on({
                        'change/fontSize': function(event, fontSize) {
                            this.setChangeOperationType('fontSizeChanged');
                            this.setStyle('fontSize', fontSize);
                        }
                    });
                },
                'italic': function() {
                    this.on({
                        'change/italic': function(event, italic) {
                            this.setStyle('italic', italic === true);
                            var changeName = 'italic:' + (
                                italic === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        },
                        'revert/italic': function(event) {
                            this.setStyle('italic', false);
                        }
                    });
                },
                'lineHeight': function() {
                    this.on({
                        'change/lineHeight': function(event, lineHeight) {
                            this.setChangeOperationType('lineHeightChanged');
                            this.setStyle('lineHeight', lineHeight);
                        }
                    });
                },
                'shadowStrength': function() {
                    this.on({
                        /**
                         * (anonymous)
                         * 
                         * @note    The ChangeHistory.clearOperationType() call
                         *          below is important to ensure that when the
                         *          shadowStrength is 0, the operation gets
                         *          registered as a removal, rather than a shadow
                         *          strength change. Otherwise the change history
                         *          would say "Drop shadow changed" when in fact it
                         *          was removed (and I believe this may create an
                         *          incorrect entry in the ChangeHistory stack for
                         *          the account).
                         */
                        'change/shadowStrength': function(event, shadowStrength) {
                            if (shadowStrength.toInt() === 0) {
                                ChangeHistory.clearOperationType();
                                this.setChangeOperationType('shadowStrength:removed');
                            } else {
                                if (
                                    this.getStyle('shadowStrength') === undefined
                                    || this.getStyle('shadowStrength').toInt() === 0
                                ) {
                                    this.setChangeOperationType('shadowStrength:added');
                                } else {
                                    this.setChangeOperationType('shadowStrength:changed');
                                }
                            }
                            this.setStyle(
                                'shadowStrength',
                                shadowStrength.toInt()
                            );
                        }
                    });
                },
                'strokeColor': function() {
                    this.on({
                        'change/strokeColor': function(event, strokeColor) {
                            var strokeAdded = this.getStyle('strokeColor') === false;
                            if (strokeAdded === true) {
                                this.setChangeOperationType('strokeColor:added');
                            } else {
                                this.setChangeOperationType('strokeColor:changed');
                            }
                            this.setStyle('strokeColor', strokeColor);
                        },
                        'clear/strokeColor': function(event) {
                            this.setChangeOperationType('strokeColor:removed');
                            this.setStyle('strokeColor', false);
                        }
                    });
                },
                'text': function() {
                    this.on({
                        'change/text': function(event, text) {
                            this.setChangeOperationType('text:changed');
                            this.setProperty('text', text);
                        }
                    });
                },
                'textColor': function() {
                    this.on({
                        'change/textColor': function(event, textColor) {
                            this.setChangeOperationType('textColorChanged');
                            this.setStyle('textColor', textColor);
                        }
                    });
                },
                'underline': function() {
                    this.on({
                        'change/underline': function(event, underline) {
                            this.setStyle('underline', underline === true);
                            var changeName = 'underline:' + (
                                underline === true ? 'added' : 'removed'
                            );
                            this.setChangeOperationType(changeName);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TextLayer')
         */
        _string: 'TextLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new TextDrawing(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ImageLayer', function() {

    /**
     * VectorImageLayer
     * 
     * @extends ImageLayer
     */
    window.VectorImageLayer = ImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, vector: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, vector: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                'fillColor': function() {
                    this.on({
                        'change/fillColor': function(event, fillColor) {
                            this.setChangeOperationType('fillColor:changed');
                            this.setStyle('fillColor', fillColor);
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorImageLayer')
         */
        _string: 'VectorImageLayer',

        /**
         * init
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            properties = this._normalizeProperties(properties);
            this._super(properties, imageDocument);
            this._drawing = new VectorImageDrawing(this);
            this._listenForGatewaySave();
            this._setupGatewaySave();
        },

        /**
         * _listenForGatewaySave
         * 
         * Listeners for a save event against a vector resource, and swaps out
         * the image key once returned if the layer has not been deleted.
         * 
         * @access  protected
         * @return  void
         */
        _listenForGatewaySave: function() {
            if (this._isResource() === true) {
                var _this = this,
                    previousyKey = this._properties.image;
                this._getResource().once({
                    'save': function(event, asset) {
                        if (_this.get('deleted') === undefined) {
                            var newKey = asset.get('key');
                            ChangeHistory.syncResourceKeyInOperations(
                                previousyKey,
                                newKey
                            );
                            _this.getImageDocument().getImage().set({
                                'resourceGatewaySave': '1'
                            });
                            _this.setProperty('image', newKey);
                        }
                    }
                });
            }
        },

        /**
         * _normalizeProperties
         * 
         * @access  protected
         * @param   Object properties
         * @return  Object
         */
        _normalizeProperties: function(properties) {
            if (properties.color === undefined) {
                properties.color = false;
            }
            if (properties.filters === undefined) {
                properties.filters = [];
            }
            return properties;
        },

        /**
         * _setupGatewaySave
         * 
         * Triggers a /save action against an icon after a globally-defined
         * delay if the layer has not been deleted. While the method <save>
         * could be called multiple times (for example, when cloning vectors),
         * it won't matter, since only one call to /save will go out at most.
         * 
         * It is important that the resource is stored as a local variable
         * before the delay, rather than be called from within there, because
         * it is possible (for example, in the case of adding an icon and
         * cloning it before it's been saved to the server) that by the time the
         * delayed-function is executed, the _getResource method points to an
         * AssetAccessor rather than a ResourceAccessor. In that case, calling
         * the save method was causing an error, since the save method on an
         * AssetAccessor is very different than on a ResourceAccessor.
         * 
         * The reason the _getResource method was pointing to the AssetAccessor
         * is because after the first icon had a /save called initiated, once
         * returned, all VectorImageLayer layers that were referencing that TNP
         * icon had their listeners triggered, and swapped out the
         * image-property for the asset. _getResource was thus pointing to an
         * AssetAccessor since it uses the _data.key property to look up the
         * accessor.
         * 
         * @access  protected
         * @return  void
         */
        _setupGatewaySave: function() {
            if (this._isResource() === true) {
                var delay = Stencil.getSaveDelay('resource'),
                    resource = this._getResource();
                (function() {
                    if (this.get('deleted') === undefined) {
                        resource.save();
                    }
                }).delay(delay, this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageLayer', function() {

    /**
     * WatermarkBitmapImageLayer
     * 
     * @extends BitmapImageLayer
     */
    window.WatermarkBitmapImageLayer = BitmapImageLayer.extend({

        /**
         * _changeHistoryKeyPrefix
         * 
         * @access  protected
         * @var     String (default: 'layer // type: image, vector: true // ')
         */
        _changeHistoryKeyPrefix: 'layer // type: image, watermark: true // ',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {

                /**
                 * Listener for when the WatermarkUploadAccessor associated with this
                 * layer is deleted from an account all together. I simply
                 * trigger a delete event against the layer. The reason I ensure
                 * that the layer has not been deleted is because otherwise,
                 * deleting a watermark could result in triggering delete-events
                 * against all previously added-and-then-removed watermark
                 * layers.
                 * 
                 * Additionally, I ensure that the ImageDocument for the layer
                 * is the same as that of the draft ImageAccessor. This is to
                 * prevent updating layers belong to older ImageDocuments. That
                 * was resulting in a bug when deleting a watermark that was
                 * previously saved, but also resulted in PATCH calls against
                 * all previously saved images, since a layer within that image
                 * had been deleted.
                 */
                'delete/watermark': function() {
                    var layer = this;
                    this.getWatermark().once({
                        'delete': function(event) {
                            if (
                                Stencil.account().draft().getImageDocument() === layer.getImageDocument()
                                && layer.get('deleted') === undefined
                            ) {
                                // var uploadKey = this.get('key');
                                // ChangeHistory.syncWatermark(uploadKey);
                                layer.triggerHandler('delete');
                            }
                        }
                    });
                },

                /**
                 * The listener-key used here is just to communicate that there
                 * is a listener on the delete event, with an intention to
                 * access the draft.
                 * 
                 * When this watermark layer is deleted, I need to ensure that
                 * the draft ImageAccessor has the most up-to-date watermarks
                 * setting value. So I manage that here.
                 */
                'delete/draft': function() {
                    this.on({
                        'delete': function(event) {
                            Stencil.account().draft().setConfiguration();
                        }
                    });
                },
                'filters/sync': function() {
                    this.on({
                        'filter/add': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/remove': function(event, obj) {
                            this.getWatermark().setFilters();
                        },
                        'filter/update': function(event, obj) {
                            this.getWatermark().setFilters();
                        }
                    });
                },
                'setStyles': function() {
                    this.on({
                        'set/style': function(event, name, value, previous) {
                            this.getWatermark().setStyles();
                        }
                    });
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkBitmapImageLayer')
         */
        _string: 'WatermarkBitmapImageLayer',

        /**
         * init
         * 
         * The below logic that checks whether the canvas that this layer
         * belongs to is the Ghost canvas was discovered when the following bug
         * happened:
         * After an initial save, the styles for the WatermarkUploadAccessor were not
         * getting saved.
         * 
         * This seemed to be happening because after a save (or download, p+s,
         * or save as template), the WatermarkUploadAccessor would reference a
         * different layer (namely, the ephemeral layer that is created for the
         * Ghost canvas). So the styles in that layer were not getting updated
         * as the user manipulated the WatermarkLayer layer.
         * 
         * Tough one to crack (level3) 
         * 
         * @access  public
         * @param   Object properties
         * @param   ImageDocument imageDocument
         * @return  void
         */
        init: function(properties, imageDocument) {
            this._super(properties, imageDocument);
            this._drawing = new WatermarkBitmapImageDrawing(this);
            if (this.getCanvas() !== Canvases.Ghost) {
                this.getWatermark().setLayer(this);
                this.getWatermark().markStylesAsSaved();
            }
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @return  WatermarkBitmapImageToolbarView
         */
        getToolbar: function() {
            return Toolbars.getToolbar('watermarkBitmapImage');
        },

        /**
         * getWatermark
         * 
         * @access  public
         * @return  WatermarkUploadAccessor
         */
        getWatermark: function() {
            return Stencil.getAccessor(this._properties.image);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * AccountModel
     * 
     * @extends Model
     */
    window.AccountModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/accounts')
         */
        _base: '/api/accounts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AccountModel')
         */
        _string: 'AccountModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Account')
         */
        _type: 'Account',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * AssetModel
     * 
     * @extends Model
     */
    window.AssetModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/assets')
         */
        _base: '/api/assets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AssetModel')
         */
        _string: 'AssetModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Asset')
         */
        _type: 'Asset',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * CategoryModel
     * 
     * @extends Model
     */
    window.CategoryModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/categories')
         */
        _base: '/api/categories',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoryModel')
         */
        _string: 'CategoryModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Category')
         */
        _type: 'Category',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * featureObjects
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @return  void
         */
        featureObjects: function(key, data) {
            var path = '/categories/' + (key) + '/featureObjects';
            Stencil.ajax({
                signature: {file: 'Model', line: 55},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        var category = Stencil.getAccessor(key),
                            index,
                            accessor;
                        for (index in data.objects) {
                            accessor = Stencil.getAccessor(data.objects[index]);
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'cM66-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * pin
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        pin: function(key, data) {
            var path = '/categories/' + (key) + '/pin';
            Stencil.ajax({
                signature: {file: 'CategoryModel', line: 85},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        var category = Stencil.getAccessor(key);
                        category.set({
                            pinKey: response.data.category.pinKey
                        });
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'cM97-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * unfeatureObjects
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @return  void
         */
        unfeatureObjects: function(key, data) {
            var path = '/categories/' + (key) + '/featureObjects';
            Stencil.ajax({
                signature: {file: 'Model', line: 55},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        var category = Stencil.getAccessor(key),
                            index,
                            accessor;
                        for (index in data.objects) {
                            accessor = Stencil.getAccessor(data.objects[index]);
                            category.syncedFeatures.remove.apply(category, [accessor]);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'cM66-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ColorModel
     * 
     * @extends Model
     */
    window.ColorModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/colors')
         */
        _base: '/api/colors',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorModel')
         */
        _string: 'ColorModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Color')
         */
        _type: 'Color',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ConnectionModel
     * 
     * @extends Model
     */
    window.ConnectionModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/connections')
         */
        _base: '/api/connections',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionModel')
         */
        _string: 'ConnectionModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Connection')
         */
        _type: 'Connection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * CouponModel
     * 
     * @extends Model
     */
    window.CouponModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/coupons')
         */
        _base: '/api/coupons',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CouponModel')
         */
        _string: 'CouponModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Coupon')
         */
        _type: 'Coupon',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * CustomerModel
     * 
     * @extends Model
     */
    window.CustomerModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/customers')
         */
        _base: '/api/customers',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomerModel')
         */
        _string: 'CustomerModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Customer')
         */
        _type: 'Customer',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FacebookModel
     * 
     * @todo!   Communicate to the user what was added, if anything:
     *          https://i.imgur.com/9SuECDv.png
     * @events  connected
     *          denied
     * @extends Model
     */
    window.FacebookModel = Model.extend({

        /**
         * _callbacks
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _callbacks: {},

        /**
         * _permissions
         * 
         * @note    Breakdown of why below permissions are required
         *          user_posts       Analytics; access shared posts
         *          user_photos      Posting; post to Timeline album
         *          publish_pages    Posting; post to page
         *          manage_pages     Posting; access pages
         *          read_insights    Analytics; access posts on pages
         *          publish_action   Posting: post to profile
         * @see     https://developers.facebook.com/docs/apps/upgrading#v22tov23
         * @access  protected
         * @var     Object
         */
        _permissions: {
            all: [
                'user_posts',
                'user_photos',
                // 'publish_pages',
                // 'manage_pages',
                // 'read_insights',
                'publish_actions'
            ],
            minimum: [
                'user_posts',
                'user_photos',
                'publish_actions'
            ]
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FacebookModel')
         */
        _string: 'FacebookModel',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _connect
         * 
         * @todo    Add in timer so that if the busy modal doesn't go away after
         *          x seconds, give option to cancel. This can be useful for
         *          popup blockers where the window is not available, or else
         *          something goes wrong and they need to bail.
         * @todo!   Look into facebooks reauthenticate parameter. Might be a
         *          simpler way to get multiple accounts on:
         *          https://i.imgur.com/GBxeX9p.jpg
         * @access  protected
         * @return  void
         */
        _connect: function() {
            var _this = this;
            Stencil.ajax({
                signature: {file: 'Facebook', line: 86},
                url: '/facebook/connect',
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        Track.event('Facebook connections added', {
                            _count: response.data.connections.length
                        });
                        if (response.data.connections.length === 0) {
                            Stencil.alert('facebook.logout');
                        } else {
                            var account = Stencil.account(),
                                collection = account.collection('connections'),
                                connections = collection.map(
                                    response.data.connections
                                );
                            _this.connected(connections);
                        }
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'f68-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * _minimum
         * 
         * @see     https://i.imgur.com/rJ4wjwX.png
         * @access  protected
         * @param   Object response
         * @return  Boolean
         */
        _minimum: function(response) {
            if (response.data === undefined) {
                return false;
            }
            if (response.data.length === 0) {
                return false;
            }
            var minimum, x, y, permission;
            for (x = 0; x < this._permissions.minimum.length; x++) {
                minimum = this._permissions.minimum[x];
                for (y = 0; y < response.data.length; ++y) {
                    permission = response.data[y];
                    if (permission.permission === minimum) {
                        if (permission.status === 'granted') {
                            break;
                        }
                        return false;
                    }
                }
            }
            return true;
        },

        /**
         * connect
         * 
         * @note    Possible responses:
         *          Object {authResponse: null, status: "not_authorized"}
         *          Object {authResponse: undefined, status: undefined}
         * @note    I do a second call to determine the permissions because the
         *          documented <return_scopes> parameter does not always work.
         *          If it did, I could simply rely on the response from Facebook
         *          to check if the minimum permissions were granted.
         * @see     https://i.imgur.com/4mXm6s2.png
         * @access  public
         * @param   Object callbacks
         * @return  void
         */
        connect: function(callbacks) {
            this._callbacks = callbacks;
            var _this = this,
                permissions = this._permissions.all,
                login = function(response) {
                    if (
                        response.authResponse !== null
                        && response.authResponse !== undefined
                    ) {
                        // var granted = response.authResponse.grantedScopes.split(',');
                        FB.api('/me/permissions', function(response) {
                            if (_this._minimum(response) === true) {
                                _this._connect();
                            } else {
                                Stencil.alert('facebook.auth.minimum');
                                _this.denied();
                            }
                        });
                    } else {
                        _this.denied();
                    }
                };
            // App.getBusy().show();
            Scripts.load('facebook', function() {
                // App.getBusy().hide();
                FB.login(
                    login,
                    {
                        auth_type: 'rerequest',
                        scope: permissions.join(','),
                        enable_profile_selector: true,
                        return_scopes: true
                    }
                );
            });
        },

        /**
         * connected
         * 
         * @access  public
         * @param   Array connections
         * @return  void
         */
        connected: function(connections) {
            if (this._callbacks.connected !== undefined) {
                this._callbacks.connected.apply(this, [connections]);
            }
            this.triggerHandler('connected');
        },

        /**
         * denied
         * 
         * @access  public
         * @return  void
         */
        denied: function() {
            if (this._callbacks.denied !== undefined) {
                this._callbacks.denied.apply(this);
            }
            this.triggerHandler('denied');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FeatureModel
     * 
     * @extends Model
     */
    window.FeatureModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/features')
         */
        _base: '/api/features',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FeatureModel')
         */
        _string: 'FeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Feature')
         */
        _type: 'Feature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FontModel
     * 
     * @extends Model
     */
    window.FontModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/fonts')
         */
        _base: '/api/fonts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontModel')
         */
        _string: 'FontModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Font')
         */
        _type: 'Font',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * create
         * 
         * @access  public
         * @param   Object data
         * @param   Function callback
         * @param   Function failed
         * @return  void
         */
        create: function(data, callback, failed) {
            var path = this._base;
            Stencil.ajax({
                signature: {file: 'Model', line: 56},
                url: path,
                type: 'POST',
                data: data || {},
                timeout: 60 * 1000,
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        if (failed !== undefined) {
                            failed(response);
                        } else {
                            var error = Stencil.extractError(response),
                                code = 'f69-' + (error.code),
                                reference = error.reference;
                            Stencil.error(code, reference);
                        }
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * FrameModel
     * 
     * @extends Model
     */
    window.FrameModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/frames')
         */
        _base: '/api/frames',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FrameModel')
         */
        _string: 'FrameModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Frame')
         */
        _type: 'Frame',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * GoogleFontModel
     * 
     * @extends Model
     */
    window.GoogleFontModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/googleFonts')
         */
        _base: '/googleFonts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontModel')
         */
        _string: 'GoogleFontModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'GoogleFont')
         */
        _type: 'GoogleFont',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * import
         * 
         * @note    Extended timeout since fonts need to be converted
         * @access  public
         * @param   GoogleFontAccessor accessor
         * @return  void
         */
        import: function(accessor) {
            var path = '/googleFonts/import';
            Stencil.ajax({
                signature: {file: 'GoogleFontModel', line: 53},
                url: path,
                type: 'POST',
                data: accessor.data(),
                timeout: 60 * 1000,
                success: function(response) {
                    if (response.success === true) {
                        accessor.triggerHandler('import', response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'gF64-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * GraphicFeatureModel
     * 
     * @extends FeatureModel
     */
    window.GraphicFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicFeatureModel')
         */
        _string: 'GraphicFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'GraphicFeature')
         */
        _type: 'GraphicFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Asset', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceModel', function() {

    /**
     * GraphicResourceModel
     * 
     * @extends ResourceModel
     */
    window.GraphicResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicResourceModel')
         */
        _string: 'GraphicResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'GraphicResource')
         */
        _type: 'GraphicResource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Resource', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ImageModel
     * 
     * @extends Model
     */
    window.ImageModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/images')
         */
        _base: '/api/images',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageModel')
         */
        _string: 'ImageModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Image')
         */
        _type: 'Image',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * draft
         * 
         * @access  public
         * @param   String key
         * @param   Function callback
         * @return  void
         */
        // draft: function(key, callback) {
        //     // var model = Stencil.getModel('Template');
        //     // model.create({
        //     //     image: key
        //     // }, callback);
        // },

        /**
         * generateShortUrl
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        generateShortUrl: function(key) {
            var path = '/images/' + (key) + '/shortUrl',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'ImageModel', line: 98},
                url: path,
                type: 'POST',
                data: {},
                success: function(response) {
                    if (response.success === true) {
                        // accessor.set({
                        //     legacyImporting: 0,
                        //     legacyImported: 1,
                        //     legacyNormalized: 1,
                        //     width: response.data.object.width,
                        //     height: response.data.object.height,
                        //     'settings.json': response.data.object.settings.json
                        // });
                        accessor.set({
                            'settings.shortUrl': response.data.object.settings.shortUrl
                        });
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'iM115-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * getImageById
         * 
         * @access  public
         * @param   Number imageId
         * @return  ImageAccessor|false
         */
        getImageById: function(imageId) {
            var accessors = Stencil.get('accessors'),
                index, accessor;
            for (index in accessors) {
                accessor = accessors[index];
                if (accessor.get('class') !== 'image') {
                    continue;
                }
                if (accessor.get('id').toInt() === imageId.toInt()) {
                    return accessor;
                }
            }
            return false;
        },

        /**
         * markAsUploaded
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        // markAsUploaded: function(key) {
        //     var path = '/images/' + (key) + '/uploaded',
        //         accessor = Stencil.getAccessor(key);
        //     Stencil.ajax({
        //         signature: {file: 'ImageModel', line: 135},
        //         url: path,
        //         type: 'POST',
        //         data: {},
        //         success: function(response) {
        //             if (response.success === true) {
        //                 // accessor.set({
        //                 //     legacyImporting: 0,
        //                 //     legacyImported: 1,
        //                 //     legacyNormalized: 1,
        //                 //     width: response.data.object.width.toInt(),
        //                 //     height: response.data.object.height.toInt(),
        //                 //     'settings.json': response.data.object.settings.json
        //                 // });
        //                 accessor.set({
        //                     'settings.shortUrl': response.data.object.settings.shortUrl
        //                 })
        //             } else {
        //                 var error = Stencil.extractError(response),
        //                     code = 'iM115-' + (error.code),
        //                     reference = error.reference;
        //                 Stencil.error(code, reference);
        //             }
        //         }
        //     });
        // },

        /**
         * normalize
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        normalize: function(key) {
            var path = '/images/' + (key) + '/normalize',
                accessor = Stencil.getAccessor(key);
            Stencil.ajax({
                signature: {file: 'ImageModel', line: 69},
                url: path,
                type: 'PATCH',
                data: {
                    json: accessor.setting('json')
                },
                success: function(response) {
                    if (response.success === true) {
                        accessor.set({
                            legacyImporting: 0,
                            legacyImported: 1,
                            legacyNormalized: 1,
                            width: response.data.object.width.toInt(),
                            height: response.data.object.height.toInt(),
                            'settings.json': response.data.object.settings.json
                        });
                        accessor.triggerHandler('normalize');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'iM78-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * template
         * 
         * @access  public
         * @param   String key
         * @param   Function callback
         * @return  void
         */
        template: function(key, callback) {
            var model = Stencil.getModel('Template');
            model.create({
                image: key
            }, callback);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * ImageFeatureModel
     * 
     * @extends FeatureModel
     */
    window.ImageFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageFeatureModel')
         */
        _string: 'ImageFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'ImageFeature')
         */
        _type: 'ImageFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Image', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Base', function() {

    /**
     * Model
     * 
     * @extends Base
     */
    window.Model = Base.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _base: '',

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'model')
         */
        _classType: 'model',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Model')
         */
        _string: 'Model',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * create
         * 
         * @access  public
         * @param   undefined|Object data (default: {})
         * @param   Function callback
         * @param   Function failed
         * @return  void
         */
        create: function(data, callback, failed) {
            data = DataUtils.getDefaultValue(data, {});
            var path = this._base;
            Stencil.ajax({
                signature: {file: 'Model', line: 64},
                url: path,
                type: 'POST',
                data: data,
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        if (failed !== undefined) {
                            failed(response);
                        } else {
                            var error = Stencil.extractError(response),
                                code = 'm76-' + (error.code),
                                reference = error.reference;
                            Stencil.error(code, reference);
                        }
                    }
                }
            });
        },

        /**
         * delete
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        delete: function(key) {
            var path = (this._base) + '/' + (key);
            Stencil.ajax({
                signature: {file: 'Model', line: 105},
                url: path,
                type: 'DELETE',
                success: function(response) {
                    if (response.success === true) {
                        var accessor = Stencil.getAccessor(key);
                        accessor.triggerHandler('model/delete');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm102-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * feature
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        feature: function(key, data, callback) {
            var pathname = this._base.replace(/^\/api/, ''),
                path = (pathname) + '/' + (key) + '/feature';
            Stencil.ajax({
                signature: {file: 'Model', line: 146},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                        var category = Stencil.getAccessor(data.category),
                            accessor = Stencil.getAccessor(key);
                        if (
                            accessor.toString() === 'ResourceAccessor'
                            || accessor.toString() === 'QuoteResourceAccessor'
                        ) {
                            accessor.triggerHandler('model/feature');
                            accessor = accessor.getAsset();
                        }
                        accessor.triggerHandler('model/feature');
                        category.syncedFeatures.add.apply(category, [accessor]);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm164-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * getBase
         * 
         * @access  public
         * @return  String
         */
        getBase: function() {
            return this._base;
        },

        /**
         * read
         * 
         * @access  public
         * @param   String key
         * @param   Function callback
         * @return  void
         */
        read: function(key, callback) {
            var path = (this._base) + '/' + encodeURIComponent(key);
            Stencil.ajax({
                signature: {file: 'Model', line: 197},
                url: path,
                type: 'GET',
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm214-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            if (data === undefined) {
                console.trace();
            }
            return Stencil.setAccessor(data.key, this._type, data);
        },

        /**
         * unfeature
         * 
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        unfeature: function(key, data, callback) {
            var pathname = this._base.replace(/^\/api/, ''),
                path = (pathname) + '/' + (key) + '/feature';
            Stencil.ajax({
                signature: {file: 'Model', line: 295},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                        var category = Stencil.getAccessor(data.category),
                            accessor = Stencil.getAccessor(key);
                        if (
                            accessor.toString() === 'ResourceAccessor'
                            || accessor.toString() === 'QuoteResourceAccessor'
                        ) {
                            accessor.triggerHandler('model/unfeature');
                            accessor = accessor.getAsset();
                        }
                        accessor.triggerHandler('model/unfeature');
                        category.syncedFeatures.remove.apply(category, [accessor]);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'm310-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * update
         * 
         * @note    The complicated callback event triggering is to faciliate
         *          events for individual settings being updated. See:
         *          https://i.imgur.com/Tr1UDre.png
         *          Goal is to have change/[name] and update/[name] match
         * @todo    Deprecate callbacks, and instead use events.
         * @todo    Passing in accessor seems redundant, since the key is already
         *          being passed. Instead, use the key to access the accessor,
         *          and fire corresponding event(s).
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Accessor accessor
         * @param   Object callbacks
         * @return  void
         */
        update: function(key, data, accessor, callbacks) {
            var path = (this._base) + '/' + (key);
            Stencil.ajax({
                signature: {file: 'Model', line: 301},
                url: path,
                type: 'PATCH',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callbacks.success.apply(accessor, [response.data]);
                        jQuery.each(data, function(index1, value1) {
                            if (typeof value1 === 'object') {
                                jQuery.each(value1, function(index2, value2) {
                                    var event = 'update/' + (index1) + '.' + (index2);
                                    accessor.triggerHandler(event, [value2]);
                                });
                            } else {
                                var event = 'update/' + (index1);
                                accessor.triggerHandler(event, [value1]);
                            }
                        });
                        accessor.triggerHandler('update', [data]);
                    } else {
                        if (callbacks.error(response) === true) {
                            var error = Stencil.extractError(response),
                                code = 'm324-' + (error.code),
                                reference = error.reference;
                            Stencil.error(code, reference);
                        }
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * PhotoFeatureModel
     * 
     * @extends FeatureModel
     */
    window.PhotoFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoFeatureModel')
         */
        _string: 'PhotoFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'PhotoFeature')
         */
        _type: 'PhotoFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Asset', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceModel', function() {

    /**
     * PhotoResourceModel
     * 
     * @extends ResourceModel
     */
    window.PhotoResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoResourceModel')
         */
        _string: 'PhotoResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'PhotoResource')
         */
        _type: 'PhotoResource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Resource', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * PromoModel
     * 
     * @extends Model
     */
    window.PromoModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/promos')
         */
        _base: '/api/promos',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoModel')
         */
        _string: 'PromoModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Promo')
         */
        _type: 'Promo',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * PromoSetModel
     * 
     * @extends Model
     */
    window.PromoSetModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/promoSets')
         */
        _base: '/api/promoSets',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoSetModel')
         */
        _string: 'PromoSetModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'PromoSet')
         */
        _type: 'PromoSet',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * QuoteFeatureModel
     * 
     * @extends FeatureModel
     */
    window.QuoteFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteFeatureModel')
         */
        _string: 'QuoteFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'QuoteFeature')
         */
        _type: 'QuoteFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Asset', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceModel', function() {

    /**
     * QuoteResourceModel
     * 
     * @extends ResourceModel
     */
    window.QuoteResourceModel = ResourceModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteResourceModel')
         */
        _string: 'QuoteResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'QuoteResource')
         */
        _type: 'QuoteResource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'QuoteResource', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ResourceModel
     * 
     * @extends Model
     */
    window.ResourceModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/resources')
         */
        _base: '/resources',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceModel')
         */
        _string: 'ResourceModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Resource')
         */
        _type: 'Resource',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * save
         * 
         * @note    This method is in the ResourceModel instead of Model, since
         *          at the moment it's always used by resources.
         * @access  public
         * @param   String key
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        save: function(key, data, callback) {
            var _this = this,
                path = '/resources/' + (key) + '/save';
            Stencil.ajax({
                signature: {file: 'Resource', line: 59},
                url: path,
                type: 'POST',
                data: data || {},
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'r68-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * S3UploadModel
     * 
     * @extends Model
     */
    window.S3UploadModel = Model.extend({

        /**
         * _bucket
         * 
         * @access  protected
         * @var     String (default: false)
         */
        _bucket: false,

        /**
         * _identityPool
         * 
         * @note    Format is region:id
         * @access  protected
         * @var     null|String (default: null)
         */
        _identityPool: null,

        /**
         * _regions
         * 
         * @access  protected
         * @var     Object
         */
        _regions: {
            cognito: null,
            s3: null
        },

        /**
         * _retries
         * 
         * @access  protected
         * @var     Number (default: 0)
         */
        _retries: 0,

        /**
         * _skewCheckPerformed
         * 
         * Tracks whether or not a check for possible skew within the clients
         * system time has occured.
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _skewCheckPerformed: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'S3UploadModel')
         */
        _string: 'S3UploadModel',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {

            // Ensure AWS has loaded
            if (typeof window.AWS === 'undefined') {
                Stencil.alert('dependency.failed');
                Stencil.kill();
            } else {

                // Config
                var aws = Config.get('aws');
                this._regions.cognito = aws.cognito.pools.primary.region;
                this._regions.s3 = aws.s3.buckets.app.stencil.region;
                this._bucket = aws.s3.buckets.app.stencil.name;
                this._identityPool = (this._regions.cognito) + ':' +
                    (aws.cognito.pools.primary.id);

                // Set up
                AWS.config.correctClockSkew = true;
                AWS.config.apiVersions = {
                    s3: '2006-03-01'
                };
                AWS.config.region = this._regions.cognito;
                AWS.config.credentials = new AWS.CognitoIdentityCredentials({
                    IdentityPoolId: this._identityPool
                });
            }
        },

        /**
         * _performSkewCheck
         * 
         * Triggers an event handler once the system time skew check has been
         * completed. If skew is found, the systemClockOffset is set to that
         * skew to ensure uploads go forward.
         * 
         * Note that I'm calling against the bucket location even though AWS
         * Support recommended doing a HEAD against the bucket, for two reasons:
         * 1. Permission for a HEAD against the bucket is called ListBucket,
         *    which grants permission to list objects (which should not be
         *    allowed for client machines).
         * 2. HEAD sends no response back, so if that fails for a reason other
         *    than RequestTimeTooSkewed, I will not know, nor will I be able to
         *    log it (since HEADs are not supposed to send any response back).
         * 
         * @access  protected
         * @param   AWS.S3 s3
         * @return  void
         */
        _performSkewCheck: function(s3) {
            if (this._skewCheckPerformed === true) {
                this.triggerHandler('skew/check/complete');
            } else {
                var _this = this;
                this._skewCheckPerformed = true;
                s3.getBucketLocation({Bucket: this._bucket}, function(err, data) {
                    if (err !== null) {
                        App.log('Skew check error', true);
                        App.log(arguments, true);
                        Stencil.alert('service.aws.skew.fail');
                        Stencil.kill();
                    } else {
                        var clientUnixTimestamp = Date.parse(
                            this.httpResponse.headers.date
                        );
                        AWS.config.systemClockOffset = clientUnixTimestamp - new Date();
                        _this.triggerHandler('skew/check/complete');
                    }
                });
            }
        },

        /**
         * performSkewCheck
         * 
         * Public version of the skew check so that it can be triggered when
         * Stencil loads up.
         * 
         * @access  public
         * @return  void
         */
        performSkewCheck: function() {
            var s3 = new AWS.S3({
                region: this._regions.s3,
                maxRetries: this._retries,
                httpOptions: {
                    // timeout: 2 * 60 * 1000
                    timeout: 4 * 60 * 1000
                }
            });
            this._performSkewCheck(s3);
        },

        /**
         * uploadData
         * 
         * @access  public
         * @param   Accessor accessor
         * @param   String name
         * @param   String data
         * @return  Object
         */
        uploadData: function(accessor, name, data) {
            var blob = DataUtils.dataUrlToBlob(data);
            return this.uploadFile(accessor, name, blob);
        },

        /**
         * uploadFile
         * 
         * @access  public
         * @param   Accessor accessor
         * @param   String name
         * @param   File|Blob file
         * @return  Object
         */
        uploadFile: function(accessor, name, file) {
            var params = {
                    Bucket: this._bucket,
                    Key: name,
                    Body: file,
                    ContentType: file.type,
                    ACL: 'public-read'
                },
                s3 = new AWS.S3({
                    region: this._regions.s3,
                    maxRetries: this._retries,
                    httpOptions: {
                        // timeout: 2 * 60 * 1000
                        timeout: 4 * 60 * 1000
                    }
                }),
                push = new AWS.S3.ManagedUpload({
                    params: params,
                    service: s3
                });//,
                // uploads = Stencil.get('s3.uploads');
            // uploads.push(push);
            if (file.size === 0) {
                return {
                    success: false,
                    failedRules: [{
                        key: 'upload.singular.filesize.zero'
                    }]
                };
            }
            push.on(
                'httpUploadProgress',
                function(event) {
                    accessor.triggerHandler(
                        'upload/progress',
                        [event.loaded, event.total]
                    );
                }
            );
            this.once({
                'skew/check/complete': function(event) {
                    push.send(
                        function(err, data) {

                            // Connection clearing
                            // jQuery.each(uploads, function(index, connection) {
                            //     if (connection === push) {
                            //         uploads.splice(index, 1);
                            //     }
                            // });

                            // Triggers
// console.log(arguments);
// console.log(this);
                            if (data) {
                                accessor.triggerHandler('upload/success', [data, this]);
                            } else {
                                if (err.code === 'RequestAbortedError') {
                                    accessor.triggerHandler('upload/abort', [err, this]);
                                } else {
                                    App.log('S3 Upload error', true);
                                    App.log(arguments, true);
                                    accessor.triggerHandler('upload/error', [err, this]);
                                }
                            }
                        }
                    );
                }
            });
            this._performSkewCheck(s3);
            return {
                success: true,
                response: {
                    managedUpload: push
                }
            };
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * ShareModel
     * 
     * @extends Model
     */
    window.ShareModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/shares')
         */
        _base: '/api/shares',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareModel')
         */
        _string: 'ShareModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Share')
         */
        _type: 'Share',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * TemplateModel
     * 
     * @extends Model
     */
    window.TemplateModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/templates')
         */
        _base: '/api/templates',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateModel')
         */
        _string: 'TemplateModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Template')
         */
        _type: 'Template',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * TemplateFeatureModel
     * 
     * @extends FeatureModel
     */
    window.TemplateFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateFeatureModel')
         */
        _string: 'TemplateFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'TemplateFeature')
         */
        _type: 'TemplateFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Template', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * TwitterModel
     * 
     * @todo!   Communicate to the user what was added, if anything:
     *          https://i.imgur.com/9SuECDv.png
     * @events  closed
     *          connected
     *          denied
     * @extends Model
     */
    window.TwitterModel = Model.extend({

        /**
         * _callbacks
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _callbacks: {},

        /**
         * _reference
         * 
         * @access  protected
         * @var     Window (default: null)
         */
        _reference: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TwitterModel')
         */
        _string: 'TwitterModel',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _listenForWindowClose
         * 
         * @access  protected
         * @return  void
         */
        _listenForWindowClose: function() {
            var interval,
                check = function() {
                    if (this._reference.closed === true) {
                        IntervalPool.clear(interval);
                        this.closed();
                    }
                };
            interval = check.interval(100, this);
        },

        /**
         * closed
         * 
         * @access  public
         * @return  void
         */
        closed: function() {
            if (this._callbacks.closed) {
                this._callbacks.closed.apply(this);
            }
            this.triggerHandler('closed');
        },

        /**
         * connect
         * 
         * @access  public
         * @param   Object callbacks
         * @return  void
         */
        connect: function(callbacks) {
            this._callbacks = callbacks;
            this._reference = window.open(
                '/twitter/redirect',
                'Twitter Connect',
                'width=640, height=420'
            );
            this._listenForWindowClose();
        },

        /**
         * connected
         * 
         * @access  public
         * @param   Object response
         * @return  void
         */
        connected: function(response) {
            var account = Stencil.account(),
                collection = account.collection('connections'),
                connections = collection.map(response.data.connections);
            if (this._callbacks.connected) {
                this._callbacks.connected.apply(this, [connections]);
            }
            Track.event('Twitter connection added');
            this.triggerHandler('connected');
        },

        /**
         * denied
         * 
         * @access  public
         * @return  void
         */
        denied: function() {
            if (this._callbacks.denied) {
                this._callbacks.denied.apply(this);
            }
            this.triggerHandler('denied');
        },

        /**
         * setup
         * 
         * @access  public
         * @return  void
         */
        setup: function() {
            var key = 'twitter.connection.connected';
            Stencil.set(key, this.connected.proxy(this));
            key = 'twitter.connection.denied';
            Stencil.set(key, this.denied.proxy(this));
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UploadModel
     * 
     * @extends Model
     */
    window.UploadModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/uploads')
         */
        _base: '/api/uploads',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadModel')
         */
        _string: 'UploadModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Upload')
         */
        _type: 'Upload',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sync
         * 
         * Calls /sync against the upload in order to have the width/height of
         * the upload stored in the database, but more importantly, initiated by
         * the server side (instead of downloading the S3-stored image to the
         * client-side, checking the width/height, and then sending that over to
         * the db).
         * 
         * The reason I switched to this approach is I didn't want the user to
         * upload a large (eg. greater than 1mb) image, just to re-download it
         * so that I could store the width/height. The front-end is so finely
         * tuned now that they'll likely never need to reference the original
         * upload, so it just seems like a waste.
         * 
         * @access  public
         * @param   String key
         * @return  void
         */
        sync: function(key) {
            var _this = this,
                path = '/uploads/' + (key) + '/sync';
            Stencil.ajax({
                signature: {file: 'Upload', line: 67},
                url: path,
                type: 'POST',
                success: function(response) {
                    if (response.success === true) {
                        var upload = Stencil.getAccessor(key);
                        upload.merge(response.data.object);
                        upload.triggerHandler(
                            'sync/complete',
                            [response.data]
                        );
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'u73-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FeatureModel', function() {

    /**
     * UploadFeatureModel
     * 
     * @extends FeatureModel
     */
    window.UploadFeatureModel = FeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadFeatureModel')
         */
        _string: 'UploadFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'UploadFeature')
         */
        _type: 'UploadFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(data) {
            return Stencil.setAccessor(data.key, 'Upload', data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UpgradeModel
     * 
     * @extends Model
     */
    window.UpgradeModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/upgrades')
         */
        _base: '/api/upgrades',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradeModel')
         */
        _string: 'UpgradeModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'Upgrade')
         */
        _type: 'Upgrade',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UserModel
     * 
     * @extends Model
     */
    window.UserModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/users')
         */
        _base: '/api/users',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserModel')
         */
        _string: 'UserModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'User')
         */
        _type: 'User',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Model', function() {

    /**
     * UserAccountModel
     * 
     * @extends Model
     */
    window.UserAccountModel = Model.extend({

        /**
         * _base
         * 
         * @access  protected
         * @var     String (default: '/api/userAccounts')
         */
        _base: '/api/userAccounts',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserAccountModel')
         */
        _string: 'UserAccountModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'UserAccount')
         */
        _type: 'UserAccount',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UploadModel', function() {

    /**
     * WatermarkModel
     * 
     * @extends UploadModel
     */
    window.WatermarkModel = UploadModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkModel')
         */
        _string: 'WatermarkModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'WatermarkUpload')
         */
        _type: 'WatermarkUpload',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UploadFeatureModel', function() {

    /**
     * WatermarkFeatureModel
     * 
     * @extends UploadFeatureModel
     */
    window.WatermarkFeatureModel = UploadFeatureModel.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkFeatureModel')
         */
        _string: 'WatermarkFeatureModel',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'WatermarkFeature')
         */
        _type: 'WatermarkFeature',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
        // ,

        /**
         * setAccessor
         * 
         * @access  public
         * @param   Object data
         * @return  Accessor
         */
        // setAccessor: function(data) {
        //     return Stencil.setAccessor(data.key, 'Upload', data);// @todo!!!! WatermarkUploadAccessor?
        // }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Base', function() {

    /**
     * Accessor
     * 
     * @events  delete     
     *          change    When a property or setting is changed (any)
     *          change/<> When a specific property or setting is changed
     *          save      When a property/setting or group of them start to be
     *                    sent to the server
     *          update    After a property/setting or group of them has been
     *                    updated on the backend (aka. patched)
     *          model/feature
     *          model/unfeature
     *          model/delete
     * @extends Base
     */
    window.Accessor = Base.extend({

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'accessor')
         */
        _classType: 'accessor',

        /**
         * _collections
         * 
         * Hash map of collections that the accessor may have attributed with
         * it. For example, an Account has frames, connections, and watermarks.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _collections: {},

        /**
         * _data
         * 
         * The public data returned for this accessor.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _data: {},

        /**
         * _model
         * 
         * Reference to the model responsible for CRUD operations on the
         * accessor.
         * 
         * @access  protected
         * @var     Model (default: null)
         */
        _model: null,

        /**
         * _references
         * 
         * Hash of other accessors attribute with this Accessor. For example,
         * AccountAccessor's have a <draft> Accessor referenced to it, which is
         * an ImageAccessor for the image they're creating.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _references: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Accessor')
         */
        _string: 'Accessor',

        /**
         * _within
         * 
         * Array of collections that the Accessor is part of. For example, a
         * WatermarkUploadAccessor is part of the WatermarksCollection. This is
         * used in the deletion process of an accessor, to ensure it's properly
         * removed from associated collections.
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _within: [],

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super();
            this._collections = {};
            this._references = {};
            this._within = [];
            this._data = data;
        },

        /**
         * collection
         * 
         * Returns the collection stored at <key> in the hash.
         * 
         * @access  public
         * @param   String key
         * @return  Collection
         */
        collection: function(key) {
            return this._collections[key];
        },

        /**
         * data
         * 
         * @access  public
         * @return  Object
         */
        data: function() {
            return this._data;
        },

        /**
         * delete
         * 
         * @note    Order below needs to be that the delete event is triggered
         *          before the accessor is removed from it's associated
         *          collections.
         * @access  public
         * @return  void
         */
        delete: function() {
            this.set({
                'deleted': true
            });
            Stencil.globalFeatures.remove(this);
            Account.favorites.remove(this);
            this._model.delete(this._data.key);
            this.triggerHandler('delete');
            this.removeAll();
            var categories = this.universalCategoriesFeaturedIn();
            if (categories.length > 0) {
                var index,
                    category;
                for (index in categories) {
                    category = categories[index];
                    category.features.remove.apply(category, [this]);
                }
            }
        },

        /**
         * deleted
         * 
         * @access  public
         * @return  Boolean
         */
        deleted: function() {
            return this._data.deleted === true;
        },

        /**
         * featuredInCategory
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        featuredInCategory: function(category) {
            var features = category.get('features');
            return ArrayUtils.contains(this._data.key, features) === true;
        },

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        get: function(key) {
            // if (this._data[key] === undefined) {
            //     throw new Error('Invalid key: ' + (key));
            // }
            return this._data[key];
        },

        /**
         * getModel
         * 
         * @access  public
         * @return  Model
         */
        getModel: function() {
            return this._model;
        },

        /**
         * globalCategoriesFeaturedIn
         * 
         * @access  public
         * @return  Array
         */
        globalCategoriesFeaturedIn: function() {
            var categories = Categories.global.all(),
                index,
                features,
                matching = [];
            for (index in categories) {
                features = categories[index].get('features');
                if (ArrayUtils.contains(this._data.key, features) === true) {
                    matching.push(categories[index]);
                }
            }
            return matching;
        },

        /**
         * globallyFeatured
         * 
         * @access  public
         * @return  Boolean
         */
        globallyFeatured: function() {
            var globalFeatures = Stencil.get('globalFeatures');
            return globalFeatures.indexOf(this._data.key) !== -1;
        },

        /**
         * merge
         * 
         * Merges passed in data with the internal <_data> hash.
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        merge: function(data) {
            this._data = jQuery.extend(true, {}, this._data, data);
        },

        /**
         * pin
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        pin: function(category) {
            var model = Stencil.getModel('Category');
            model.pin(category.get('key'), {
                objectType: this.get('class').toLowerCase(),
                objectKey:  this.get('key')
            });
            this.triggerHandler('pin', [category]);
        },

        /**
         * pinned
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        pinned: function(category) {
            return category.get('pinKey') === this.get('key');
        },

        /**
         * push
         * 
         * Performs a set and save, so long as the initial value that is being
         * set for a key is different than what's already stored in memory.
         * This is a more performant way of doing things, since it'll prevent
         * server calls if the key is already set to the value. Currently
         * being used with UserAccount settings.
         * 
         * Note that I called it key instead of column, since it could be a
         * setting (eg. settings.name) that is being pushed.
         * 
         * @todo    Update this so it can accept a hash of properties / values.
         *          Once you do that, update ImageAccessor.sync method to
         *          prevent making calls with extraneous data (eg. the frame
         *          changed, but the json didn't. In that case, no point sending
         *          the json to the server and requiring the server to check if
         *          something has changed or not).
         * @access  public
         * @param   String key
         * @param   String value
         * @return  void
         */
        push: function(key, value) {
            var current;
            if (key.indexOf('settings.') === -1) {
                current = this._data[key];
            } else {
                current = this._data.settings[key.split('settings.').pop()];
            }
            if (current !== value) {
                this.set(key, value);
                this.save([key]);
            }
        },

        /**
         * read
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        read: function(callback) {
            var _this = this;
            this._model.read(this._data.key, function(data) {
                callback.apply(_this, [data.object]);
            });
        },

        /**
         * reference
         * 
         * Returns the reference stored at <key> in the hash.
         * 
         * @access  public
         * @param   String key
         * @return  Accessor
         */
        reference: function(key) {
            return this._references[key];
        },

        /**
         * removeAll
         * 
         * Removes the accessor from it's associated collections.
         * 
         * @access  public
         * @return  void
         */
        removeAll: function() {
            var _this = this;
            jQuery.each(this._within, function(index, collection) {
                collection.remove(_this);
            });
        },

        /**
         * save
         * 
         * @example Accessor.save('column')
         *          Accessor.save(['column1', 'column2'])
         *          Accessor.save(['settings.sub'])
         *          Accessor.save(['settings.1', 'settings.2'])
         * @access  public
         * @param   Array columns
         * @param   undefined|Object callbacks
         * @return  void
         */
        save: function(columns, callbacks) {
            var _this = this,
                data = {},
                column;

            // Format callbacks
            if (callbacks === undefined) {
                callbacks = {
                    success: function(data) {},
                    error: function(response) {
                        return true;
                    }
                };
            }
            if (callbacks.success === undefined) {
                callbacks.success = function(data) {};
            }
            if (callbacks.error === undefined) {
                callbacks.error = function(response) {
                    return true;
                };
            }

            // Ensure columns are array
            if (jQuery.isArray(columns) === false) {
                columns = [columns];
            }
            jQuery.each(columns, function(index, column) {
                if (column.indexOf('settings.') === 0) {
                    data.settings = data.settings || {};
                    column = column.split('settings.').pop();
                    data.settings[column] = _this._data.settings[column];
                } else {
                    data[column] = _this._data[column];
                }
            });
            this._model.update(this._data.key, data, this, callbacks);
            this.triggerHandler('save', [columns]);
        },

        /**
         * set
         * 
         * @example Accessor.set('key', 'value')
         *          Accessor.set({key: 'value'})
         * @access  public
         * @param   String|Object key
         * @param   undefined|Number|String value
         * @return  void
         */
        set: function() {

            // Object or key/value arguments
            var args = jQuery.makeArray(arguments),
                data = args[0];
            if (typeof data === 'string') {
                data = {};
                data[args[0]] = args[1];
            }

            // Events
            var handler,
                _this = this;
            jQuery.each(data, function(key, value) {
                handler = 'change/' + (key);
                if (key.indexOf('settings.') === 0) {
                    key = key.split('settings.').pop();
                    _this._data.settings[key] = value;
                } else {
                    _this._data[key] = value;
                }
                _this.triggerHandler(handler, [value]);
            });
            this.triggerHandler('change');
        },

        /**
         * setting
         * 
         * Returns a setting value if one is found, or else throws an error.
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        setting: function(key) {
            if (this._data.settings[key] === undefined) {
                throw 'Invalid key: ' + (key);
            }
            return this._data.settings[key];
        },

        /**
         * favorited
         * 
         * @access  public
         * @return  Boolean
         */
        favorited: function() {
            var favorites = Stencil.account().get('favorites'),
                key = this._data.key;
            return favorites.indexOf(key) !== -1;
        },

        /**
         * swap
         * 
         * Swaps out the data for the accessor. Should only be called when an
         * ephemeral key was used, since the previous key will be deleted from
         * memory. At the moment, only used when creating a template, or when a
         * user logs in (which swaps out their temporary account data with
         * whatever is returned).
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        swap: function(data) {
            var all = Stencil.get('accessors'),
                previous = this._data.key;
            this._data = data;
            all[this._data.key] = this;
            delete all[previous];
        },

        /**
         * universalCategoriesFeaturedIn
         * 
         * @access  public
         * @return  Array
         */
        universalCategoriesFeaturedIn: function() {
            var categories = Categories.universal.all(),
                index,
                features,
                matching = [];
            for (index in categories) {
                features = categories[index].get('features');
                if (ArrayUtils.contains(this._data.key, features) === true) {
                    matching.push(categories[index]);
                }
            }
            return matching;
        },

        /**
         * unpin
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        unpin: function(category) {
            var model = Stencil.getModel('Category');
            model.pin(category.get('key'), {
                objectType: this.get('class').toLowerCase(),
                objectKey:  this.get('key')
            });
            this.triggerHandler('unpin', [category]);
        },

        /**
         * within
         * 
         * Stores the collection in the <within> Array, so that we can keep
         * track of where the Accessor is being used.
         * 
         * @access  public
         * @param   Collection collection
         * @return  void
         */
        within: function(collection) {
            this._within.push(collection);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'AccountModel'], function() {

    /**
     * AccountAccessor
     * 
     * @fires   draft/create
     * @extends Accessor
     */
    window.AccountAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Account'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AccountAccessor')
         */
        _string: 'AccountAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupCategories();
            this._setupColors();
            this._setupConnections();
            this._setupDraft();
            this._setupFonts();
            this._collections.fonts.map(Config.get('fonts'), true);
            this._setupFrames();
            this._collections.frames.map(Frames.all(), true);
            this._setupOrphanFrame();
            this._setupUpgrade();
            this._setupUserAccount();
            this._setupWatermarks();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @param   undefined|Array categories (default: this._data.categories)
         * @return  void
         */
        _setupCategories: function(categories) {
            categories = DataUtils.getDefaultValue(
                categories,
                this._data.categories
            );
            this._collections.categories = this._collections.categories || new CategoriesCollection();
            this._collections.categories.map(categories, true);
        },

        /**
         * _setupColors
         * 
         * @access  protected
         * @return  void
         */
        _setupColors: function() {
            var _this = this;
            this._collections.colors = this._collections.colors || new ColorsCollection();
            jQuery.each(this._data.colors, function(index, color) {
                if (_this._collections.colors.find(color.key) === false) {
                    _this._collections.colors.map(color, true);
                }
            });
        },

        /**
         * _setupConnections
         * 
         * @access  protected
         * @return  void
         */
        _setupConnections: function() {
            this._collections.connections = this._collections.connections || new ConnectionsCollection();
            this._collections.connections.map(this._data.connections, true);
        },

        /**
         * _setupCustomCategories
         * 
         * Adds categories to the area relative context menus and navs.
         * 
         * @access  protected
         * @return  void
         */
        _setupCustomCategories: function() {

            // Add custom categories to account collection
            var allAccountCategories = this._data.categories,
                customCategories = [],
                index,
                category;
            for (index in allAccountCategories) {
                category = allAccountCategories[index];
                if (category.custom.toInt() === 1) {
                    customCategories.push(category);
                }
            }
            this._setupCategories(customCategories);

            // Update area nav and context menus
            var areas = App.getEditor().getAreas(),
                area,
                nav,
                contextMenu,
                collectionResults;
            for (index in areas) {
                area = areas[index];
                if (area.canHaveCollections() === true) {
                    customCategories = Categories.account.custom(area.getType()).slice().reverse();
                    nav = area.getNav();
                    collectionResults = nav.getCollectionResults();
                    collectionResults.getCollection().add(customCategories);
                    contextMenu = area.getContextMenu();
                    collectionResults = contextMenu.getCollectionResults();
                    collectionResults.getCollection().add(customCategories);
                }
            }
        },

        /**
         * _setupDraft
         * 
         * @access  protected
         * @return  void
         */
        _setupDraft: function() {
            var model = Stencil.getModel('Image');
            this._references.draft = model.setAccessor(
                this._data.draft
            );
        },

        /**
         * _setupFonts
         * 
         * @access  protected
         * @return  void
         */
        _setupFonts: function() {
            this._collections.fonts = this._collections.fonts || new FontsCollection();
            this._collections.fonts.unbind('add');
            this._collections.fonts.on({

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @param   Number position
                 * @return  void
                 */
                'add': function(event, font, position) {
                    if (font.get('uploaded').toInt() === 1) {
                        font.drawStyleSheet();
                    }
                }
            });

            // The following will only map an account's fonts to the collection
            var _this = this;
            jQuery.each(this._data.fonts, function(index, font) {
                if (_this._collections.fonts.find(font.key) === false) {
                    _this._collections.fonts.map(font, true);
                }
            });
        },

        /**
         * _setupFrames
         * 
         * Adds any frames that aren't yet in memory to the account's
         * FramesCollection.
         * 
         * @access  protected
         * @return  void
         */
        _setupFrames: function() {
            var _this = this;
            this._collections.frames = this._collections.frames || new FramesCollection();
            jQuery.each(this._data.frames, function(index, frame) {
                if (_this._collections.frames.find(frame.key) === false) {
                    _this._collections.frames.map(frame, true);
                }
            });
        },

        /**
         * _setupOrphanFrame
         * 
         * @access  protected
         * @return  void
         */
        _setupOrphanFrame: function() {
            var model = Stencil.getModel('Frame');
            this._references.orphanFrame = model.setAccessor({
                class: 'frame',
                type: 'orphan',
                tag: 'backup',
                key: 'frm-orphan',
                label: 'Custom',
                width: 0,
                height: 0
            });
        },

        /**
         * _setupUpgrade
         * 
         * @access  protected
         * @return  void
         */
        _setupUpgrade: function() {
            if (this._data.upgrade !== false) {
                var model = Stencil.getModel('Upgrade');
                this._references.upgrade = model.setAccessor(
                    this._data.upgrade
                );
            }
            Account.once({
                'upgrade': this._setupUpgrade.proxy(this)
            });
        },

        /**
         * _setupUserAccount
         * 
         * @todo!   Look into whether the login / signup events need to be added
         *          below, since if the userAccount is found, we know they're
         *          already logged in.
         * @access  protected
         * @return  void
         */
        _setupUserAccount: function() {
            if (this._data.userAccount !== false) {
                var model = Stencil.getModel('UserAccount');
                this._references.userAccount = model.setAccessor(
                    this._data.userAccount
                );
            }
            User.once({
                'login': this._setupUserAccount.proxy(this),
                'signup': this._setupUserAccount.proxy(this)
            });
        },

        /**
         * _setupWatermarks
         * 
         * @access  protected
         * @return  void
         */
        _setupWatermarks: function() {
            this._collections.watermarks = this._collections.watermarks || new WatermarksCollection();
            this._collections.watermarks.map(this._data.watermarks, true);
        },

        /**
         * cancel
         * 
         * @access  public
         * @param   Boolean later
         * @param   Boolean disapproveLastCommission
         * @param   Function callback
         * @return  void
         */
        cancel: function(later, disapproveLastCommission, callback) {
            var _this = this,
                path = '/accounts/' + (this._data.key) + '/cancel';
            Stencil.ajax({
                signature: {file: 'Account', line: 171},
                url: path,
                type: 'POST',
                data: {
                    later: (later === true ? 1 : 0),
                    disapproveLastCommission: (
                        disapproveLastCommission === true
                        ? 1
                        : 0
                    )
                },
                success: function(response) {
                    if (response.success === true) {
                        callback && callback(response.data);
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'a172-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * coupon
         * 
         * Returns whether or not the account used a coupon during upgrading.
         * 
         * @access  public
         * @return  Boolean
         */
        coupon: function() {
            return this.upgrade() !== undefined
                && this.upgrade().get('coupon') !== false;
        },

        /**
         * createdBefore
         * 
         * @example
         *          this.createdBefore('1 day');
         *          this.createdBefore('2 weeks');
         * @access  public
         * @param   String relativeTime
         * @return  Boolean
         */
        createdBefore: function(relativeTime) {
            var period = 'seconds';
            if (relativeTime.match(/minute/) !== null) {
                period = 'minutes';
            } else if (relativeTime.match(/hour/) !== null) {
                period = 'hours';
            } else if (relativeTime.match(/day/) !== null) {
                period = 'days';
            } else if (relativeTime.match(/week/) !== null) {
                period = 'weeks';
            } else if (relativeTime.match(/month/) !== null) {
                period = 'months';
            } else if (relativeTime.match(/year/) !== null) {
                period = 'years';
            }
            var number = relativeTime.replace(/[^0-9]/, '').toInt(),
                comparisonTimestamp = moment().subtract(number, period),
                createdTimestamp = moment.unix(this._data.created);
            return createdTimestamp.isBefore(comparisonTimestamp);
        },

        /**
         * createNewDraft
         * 
         * @access  public
         * @param   ImageAccessor current
         * @return  ImageAccessor
         */
        createNewDraft: function(current) {
            var _this = this,
                model = Stencil.getModel('Image'),
                draft = model.setAccessor({
                    class: 'image',
                    key: DataUtils.getRandomString(),
                    draft: 1,
                    width: current.get('width').toInt(),
                    height: current.get('height').toInt(),
                    sourceImage: current.data(),
                    sourceImageId: current.get('id').toInt(),// careful
                    uploaded: 0,// Needed for preloading elsewhere
                    frame: current.get('frame'),
                    settings: {
                        json: current.setting('json'),
                        watermarks: current.setting('watermarks')
                    },
                    ip: Stencil.account().get('geo').ip
                });
            this._references.draft = draft;
            model.create({
                frame: draft.get('frame'),
                draft: draft.get('draft'),
                width: draft.get('width').toInt(),
                height: draft.get('height').toInt(),
                sourceImageId: draft.getSourceImage().get('id').toInt(),// careful
                settings: {
                    json: draft.setting('json'),
                    watermarks: draft.setting('watermarks')
                }
            }, function(data) {
                draft.swap(data.object);
                _this.triggerHandler('draft/create', [draft]);
            });
            return draft;
        },

        /**
         * orphanFrame
         * 
         * @access  public
         * @return  FrameAccessor
         */
        orphanFrame: function() {
            return this._references.orphanFrame;
        },

        /**
         * delinquent
         * 
         * Returns whether or not the account is in delinquent mode.
         * 
         * @access  public
         * @return  Boolean
         */
        delinquent: function() {
            return this.upgrade() !== undefined
                && this.upgrade().customer() !== undefined
                && this.upgrade().customer().get('delinquent').toInt() === 1;
        },

        /**
         * draft
         * 
         * @access  public
         * @return  ImageAccessor
         */
        draft: function() {
            return this._references.draft;
        },

        /**
         * draftIsLocked
         * 
         * @access  public
         * @return  Boolean
         */
        draftIsLocked: function() {
            return this._references.draft.isLocked();
        },

        /**
         * free
         * 
         * Returns whether or not the account is both not a guest and has not
         * been upgraded.
         * 
         * @access  public
         * @return  Boolean
         */
        free: function() {
            return this.guest() === false
                && this.upgraded() === false
                && User.admin() === false
                && User.editor() === false;
        },

        /**
         * geo
         * 
         * @access  public
         * @return  false|Object
         */
        geo: function() {
            if (
                this._data.geo.country.code === false
                || this._data.geo.country.code === ''
            ) {
                return false;
            }
            return this._data.geo;
        },

        /**
         * getDefaultFontFamily
         * 
         * @access  public
         * @return  String
         */
        getDefaultFontFamily: function() {
            return this.setting('defaultFontFamily');
            // var accountDefaultFontFamily = this.setting('defaultFontFamily'),
            //     fontsCollection = this._collections.fonts,
            //     font = fontsCollection.findByFamilyName(accountDefaultFontFamily);
            // if (font === false) {
            //     return Config.get('font');
            // }
            // return font.get('key');
        },

        /**
         * getImagesRemaining
         * 
         * @note    Can return less than 0, since users can saved a bunch of
         *          images, and then downgrade.
         * @access  public
         * @return  Number
         */
        getImagesRemaining: function() {
            var max = this._data.monthlyMaxImages.toInt(),
                saved = this._data.monthlySavedImages.toInt(),
                bonus = this._data.bonusImages.toInt();
            if (max === 0) {
                return Infinity;
            }
            var left = max - saved + bonus;
            if (left < 0) {
                return 0;
            }
            return max - saved + bonus;
        },

        /**
         * getReferralUrl
         * 
         * @access  public
         * @return  Number
         */
        getReferralUrl: function() {
            var host = Config.get('hosts').app;
            return 'https://' + (host) + '/a/ref/' + (this._data.key);
        },

        /**
         * getRefillDate
         * 
         * @note    There are 4 cases here, all of which are covered the same:
         *          - Guests
         *          - Free users
         *          - Upgraded users
         *          - Downgraded free users
         *          I use the account record created date
         * @access  public
         * @return  String
         */
        getRefillDate: function() {
            var format = 'MMMM DD, YYYY \@ h\:mm a',
                micro = this._data.refill.toInt() * 1000;
            return moment(micro).format(format);
        },

        /**
         * getSmsMessagesRemaining
         * 
         * @access  public
         * @return  Number
         */
        getSmsMessagesRemaining: function() {
            var max = this._data.monthlyMaxSmsMessages.toInt(),
                sent = this._data.monthlySentSmsMessages.toInt();
            if (max === 0) {
                return Infinity;
            }
            var left = max - sent;
            if (left < 0) {
                return 0;
            }
            return max - sent;
        },

        /**
         * getFavoritesRemaining
         * 
         * @note    Can return less than 0, since users can favorite a bunch of
         *          objects, and then downgrade.
         * @access  public
         * @return  Number
         */
        getFavoritesRemaining: function() {
            var max = this._data.maxFavorites.toInt();
            if (max === 0) {
                return Infinity;
            }
            return max - this._data.favorites.length;
        },

        /**
         * getUpgradedPath
         * 
         * Returns the path the user should be sent to after an upgrade,
         * depending on what plan and interval they chose. This is abstracted
         * here to lookup the plan and interval, but also because it's used in a
         * conventional checkout flow as well as through a redemption flow. Note
         * also that while the parameters being passed are not currently (at the
         * time of documentation) being used within the application-logic, but
         * are being used by Google Analytics for goal-conversion-tracking.
         * 
         * @access  public
         * @return  String
         */
        getUpgradedPath: function() {
            var plan = this.upgrade().get('plan'),
                interval = this.upgrade().get('interval'),
                gateway = this.upgrade().get('gateway'),
                path = '/app/upgraded/' + (plan) +
                    '?clean=1' +
                    '&interval=' + (interval) +
                    '&gateway=' + (gateway);
            return path;
        },

        /**
         * guest
         * 
         * Returns whether or not the account is a guest.
         * 
         * @access  public
         * @return  Boolean
         */
        guest: function() {
            return this._data.guest.toInt() === 1;
        },

        /**
         * max
         * 
         * @access  public
         * @return  Object
         */
        max: {

            /**
             * bonus
             * 
             * Returns whether or not the account has received the max number of
             * bonus images.
             * 
             * @access  public
             * @return  Boolean
             */
            bonus: function() {
                if (this._data.followBonus.toInt() === 0) {
                    return false;
                }
                if (this._data.tweetBonus.toInt() === 0) {
                    return false;
                }
                if (this._data.shareBonus.toInt() === 0) {
                    return false;
                }
                return true;
            },

            /**
             * favorites
             * 
             * Returns whether or not the account has favorited the maximum
             * number of favorites allowable. Does the check using <= (instead of
             * checking if it equals 0) since when a user is downgraded, it's
             * possible for the number remaining to be less than 0 (eg. if they
             * favorited 20, then downgraded).
             * 
             * @access  public
             * @return  Boolean
             */
            favorites: function() {
                var remaining = this.getFavoritesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            },

            /**
             * images
             * 
             * Returns whether or not the account has saved the maximum number
             * of images (for the month). Does the check using <= (instead of
             * checking if it equals 0) since when a user is downgraded, it's
             * possible for the number remaining to be less than 0 (eg. if they
             * created 20 one month, then downgraded).
             * 
             * @access  public
             * @return  Boolean
             */
            images: function() {
                var remaining = this.getImagesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            },

            /**
             * sms
             * 
             * @access  public
             * @return  Boolean
             */
            sms: function() {
                var remaining = this.getSmsMessagesRemaining();
                if (remaining === Infinity) {
                    return false;
                }
                return remaining <= 0;
            }
        },

        /**
         * plan
         * 
         * Returns whether or not the account is on the passed in plan. Does not
         * check whether they are active on that plan. Use <paying> for that.
         * 
         * @access  public
         * @param   String plan
         * @return  Boolean
         */
        plan: function(plan) {
            if (this.guest() === true) {
                return false;
            }
            if (this.upgrade() === undefined) {
                if (plan === 'free') {
                    return true;
                }
                return false;
            }
            return this.reference('upgrade').get('plan') === plan;
        },

        /**
         * promo
         * 
         * Returns whether or not the account was upgraded via a promo code.
         * 
         * @access  public
         * @return  Boolean
         */
        promo: function() {
            return this.upgrade() !== undefined
                && this.upgrade().customer() !== undefined
                && this.upgrade().customer().get('type') === 'promo';
        },

        /**
         * reload
         * 
         * @access  public
         * @return  void
         */
        reload: function() {
            this._setupCustomCategories();
            this._setupConnections();
            this._setupFonts();
            this._collections.fonts.loadUploadedNormal();
            this._collections.fonts.each(function(index, font) {
                if (font.get('uploaded').toInt() === 1) {
                    Toolbars.getToolbar('text').getFontsDropdown().addFont(font, false);
                }
            });
            this._setupFrames();
            this._setupColors();
            // this._setupDraft();
            this._setupUpgrade();
            this._setupWatermarks();
        },

        /**
         * showTermsAgreeInput
         * 
         * @access  public
         * @return  Boolean
         */
        showTermsAgreeInput: function() {
            var countries = ['au', 'ca', 'us', 'usa'],
                country = this.get('geo').country.code.toLowerCase();
            return ArrayUtils.contains(country, countries) === false;
        },

        /**
         * swapCategories
         * 
         * @note    Important to note the soft does-not-equal below. This is to
         *          prevent any issues with 1 !== '1'.
         * @access  public
         * @return  void
         */
        swapCategories: function() {

            /**
             * matches
             * 
             * @access  private
             * @param   CategoryAccessor first
             * @param   array second
             * @return  Boolean
             */
            var matches = function(first, second) {
                var properties = [
                        'photos',
                        'graphics',
                        'templates',
                        'quotes',
                        'uploads',
                        'watermarks',
                        'images',
                        'fonts',
                        'featured',
                        'global',
                        'all',
                        'favorites',
                        'custom'
                    ],
                    index;
                for (index in properties) {
                    if (first.get(properties[index]) != second[properties[index]]) {
                        return false;
                    }
                }
                return true;
            };
            this._collections.categories.each(function(index, accessor) {
                var categories = Stencil.account().get('categories'),
                    index;
                for (index in categories) {
                    if (matches(accessor, categories[index]) === true) {
                        accessor.swap(categories[index]);
                        accessor.set({
                            'count': categories[index].count
                        });
                    }
                }
            });
        },

        /**
         * syncFavorites
         * 
         * @access  public
         * @return  void
         */
        syncFavorites: function() {
            var areas = [
                    'photos',
                    'graphics',
                    'templates',
                    'quotes',
                    'uploads',
                    'images'
                ],
                index,
                collections, area;
            for (index in areas) {
                collections = [];
                area = App.getEditor().getArea(areas[index]);
                jQuery.each(
                    area.getChild('categories').getChildren(),
                    function(index, resultsView) {
                        collections.push(resultsView.getCollection());
                    }
                );
                jQuery.each(collections, function(index, collection) {
                    collection.each(function(index, accessor) {
                        if (accessor.favorited() === true) {
                            accessor.triggerHandler('favorite/ui');
                        }
                    });
                });
                if (area.getChild('queries') !== undefined) {
                    collections = [];
                    jQuery.each(
                        area.getChild('queries').getChildren(),
                        function(index, resultsView) {
                            collections.push(resultsView.getCollection());
                        }
                    );
                    jQuery.each(collections, function(index, collection) {
                        collection.each(function(index, accessor) {
                            if (accessor.favorited() === true) {
                                accessor.triggerHandler('favorite/ui');
                            }
                        });
                    });
                }
            }
        },

        /**
         * syncRefillData
         * 
         * This method exists for cases whereby a user's quotas reset, but they
         * are using the app at the same time. What was happening was a user
         * went from 50 images down to 3, then their quota reset, and the next
         * time they saved an image, a value of 2 was pushed to their account
         * record, overwriting what was just reset.
         * 
         * So this method ensures that before certain quota-setting requests,
         * the data is first retrieved, and if it's been reset, quota's are
         * set to their new values.
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        syncRefillData: function(callback) {
            this.read(function(data) {
                if (this.get('refill').toInt() !== data.refill.toInt()) {
                    this.set({
                        monthlySavedImages: data.monthlySavedImages.toInt(),
                        monthlySentSmsMessages: data.monthlySentSmsMessages.toInt(),
                        bonusImages: data.monthlySavedImages.toInt(),
                        refill: data.refill.toInt()
                    });
                    callback.apply(this, [true]);
                } else {
                    callback.apply(this, [false]);
                }
            });
        },

        /**
         * upgrade
         * 
         * Returns the UpgradeAccessor reference for the account, or else
         * undefined if no reference found.
         * 
         * @access  public
         * @return  UpgradeAccessor|undefined
         */
        upgrade: function() {
            return this._references.upgrade;
        },

        /**
         * upgraded
         * 
         * Returns whether or not the account has been upgraded. This is
         * independent of how they upgraded (eg. conventional, or through for
         * example an AppSumo deal).
         * 
         * @access  public
         * @return  Boolean
         */
        upgraded: function() {
            var upgrade = this.upgrade();
            if (upgrade === undefined) {
                return false;
            }
            return upgrade.get('active').toInt() === 1;
        },

        /**
         * upgradeToPlan
         * 
         * @access  public
         * @param   String plan
         * @return  void
         */
        upgradeToPlan: function(plan) {
            var _this = this,
                path = '/accounts/' + (this._data.key) + '/upgrade';
            Stencil.ajax({
                data: {
                    plan: plan
                },
                signature: {file: 'Account', line: 881},
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'a424-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                },
                type: 'POST',
                url: path
            });
        },

        /**
         * userAccount
         * 
         * @access  public
         * @return  UserAccountAccessor|undefined
         */
        userAccount: function() {
            return this._references.userAccount;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'AssetModel'], function() {

    /**
     * AssetAccessor
     * 
     * @extends MediaAccessor
     */
    window.AssetAccessor = MediaAccessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Asset'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AssetAccessor')
         */
        _string: 'AssetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupResource();
            this.on({
                'feature': function(event, category) {
                    Track.event('Asset featured', {
                        _key: this._data.key
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Asset unfeatured', {
                        _key: this._data.key
                    });
                }
            });
            this.on({
                'select': function(event, method, locked, options) {
                    if (this._data.resourceType === 'TheNounProject') {
                        this._addVectorLayer(locked, this._data.color.toInt() === 1);
                    } else if (this._data.resourceType === 'Icons8') {
                        this._addVectorLayer(locked, this._data.color.toInt() === 1);
                    } else if (this._data.resourceType === 'VectorSearch') {
                        this._addVectorLayer(locked, this._data.color.toInt() === 1);
                    } else if (this._data.resourceType === 'Pixabay') {
                        if (options.destination === 'foreground') {
                            Account.onboard('foregroundSelected');
                            this.addForegroundBitmapImageLayer(locked);
                        } else {
                            Account.onboard('backgroundSelected');
                            if (options.autoSelect !== undefined) {
                                this.setBackgroundBitmapImageLayer(locked, {
                                    autoSelect: options.autoSelect
                                });
                            } else {
                                this.setBackgroundBitmapImageLayer(locked);
                            }
                        }
                    } else if (this._data.resourceType === 'Pexels') {
                        if (options.destination === 'foreground') {
                            Account.onboard('foregroundSelected');
                            this.addForegroundBitmapImageLayer(locked);
                        } else {
                            Account.onboard('backgroundSelected');
                            if (options.autoSelect !== undefined) {
                                this.setBackgroundBitmapImageLayer(locked, {
                                    autoSelect: options.autoSelect
                                });
                            } else {
                                this.setBackgroundBitmapImageLayer(locked);
                            }
                        }
                    } else if (this._data.resourceType === 'Unsplash') {
                        if (options.destination === 'foreground') {
                            Account.onboard('foregroundSelected');
                            this.addForegroundBitmapImageLayer(locked);
                        } else {
                            Account.onboard('backgroundSelected');
                            if (options.autoSelect !== undefined) {
                                this.setBackgroundBitmapImageLayer(locked, {
                                    autoSelect: options.autoSelect
                                });
                            } else {
                                this.setBackgroundBitmapImageLayer(locked);
                            }
                        }
                    } else if (this._data.resourceType === 'AlgoliaQuote') {
                        this._addQuoteTextLayers();
                    }
                }
            });
        },

        /**
         * _addQuoteTextLayers
         * 
         * @access  protected
         * @return  void
         */
        _addQuoteTextLayers: function() {
            if (JSONUtils.valid(this._data.settings.raw) === true) {
                var raw = JSON.parse(this._data.settings.raw),
                    quotation = raw.quotation,
                    author = raw.author,
                    canvas = Canvases.Preview,
                    layers = {
                        author: canvas.addTextLayer({
                            align: 'center',
                            fontFamily: 'Leckerli One',
                            fontSize: 35,
                            text: author,
                            top: 70,
                            width: 90
                        }),
                        quotation: canvas.addTextLayer({
                            align: 'center',
                            fontFamily: Stencil.account().getDefaultFontFamily(),
                            fontSize: 50,
                            text: quotation,
                            top: 45,
                            width: 90
                        })
                    },
                    drawings = {
                        author: layers.author.getDrawing(),
                        quotation: layers.quotation.getDrawing()
                    };
                layers.author.setChangeOperationType('quote:added');
                drawings.author.once({
                    'draw': function(event) {
                        this.trim();
                        this.repositionRelativeTo(drawings.quotation);
                        this.animate();
                        drawings.quotation.animate();
                        drawings.quotation.select();
                        // this._cotton.trigger('changed');
                        layers.author.triggerHandler('refresh/dimensions');
                    }
                });
                drawings.quotation.once({
                    'draw': function(event) {
                        drawings.author.draw();
                    }
                });
                drawings.quotation.draw();
            } else {
                StencilBooter.log('JSON parse error (A:_aQTL)');
            }
        },

        /**
         * _addVectorLayer
         * 
         * @note    I don't call <sync> against The Noun Project assets since
         *          they're all vectors, and the only thing I want to know about
         *          them is their filesize (which I already collect on the
         *          backend).
         * @access  protected
         * @param   Boolean locked
         * @param   Boolean color
         * @return  void
         */
        _addVectorLayer: function(locked, color) {
            var canvas = Canvases.Preview,
                layer = canvas.addVectorImageLayer({
                    image: this._data.key
                }, color),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw(true);
        },

        /**
         * _setupResource
         * 
         * @access  protected
         * @return  void
         */
        _setupResource: function() {
            var model = Stencil.getModel('Resource');
            if (this._data.resourceType === 'AlgoliaQuote') {
                model = Stencil.getModel('QuoteResource');
            }
            this._references.resource = model.setAccessor({
                class: 'resource',
                key: this.getHash(),
                platform: this._data.resourceType,
                id: this._data.resourceId
            });
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @note    Defaults to auto selecting the drawing
         * @note    Defaults to auto animating the drawing
         * @access  public
         * @param   Boolean locked
         * @param   Object options (optional)
         * @return  ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(locked, options) {
            options = options || {};
            var canvas = Canvases.Preview,
                layer = canvas.addForegroundBitmapImageLayer({
                    image: this._data.key
                }),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    if (options.autoSelect !== false) {
                        this.select();
                    }
                    if (options.animate !== false) {
                        drawing.animate();
                    }
                }
            });
            drawing.draw();
            return layer;
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = Categories.account.favorites(areaType);
            this.feature(category, performDataRequest);
        },

        /**
         * favorited
         * 
         * @access  public
         * @return  Boolean
         */
        favorited: function() {
            var favorites = Stencil.account().get('favorites'),
                hash = this.getHash();
            return favorites.indexOf(hash) !== -1;
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            var area = 'photos';
            if (category.get('graphics').toInt() === 1) {
                area = 'graphics';
            } else if (category.get('quotes').toInt() === 1) {
                area = 'quotes';
            }
            if (ArrayUtils.contains(category, Categories.global.all()) === true) {
                Stencil.globalFeatures.add(this);
            }
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.feature(
                    this._data.key,
                    {
                        category: category.get('key')
                    },
                    (function(data) {
                        this.triggerHandler('feature/complete');
                    }).proxy(this)
                );
            }
            this.triggerHandler('feature', [category]);
            this._references.resource.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * featuredInCategory
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        featuredInCategory: function(category) {
            var features = category.get('features');
            return ArrayUtils.contains(this.getHash(), features) === true;
        },

        /**
         * getDisplayableQuotation
         * 
         * @see     http://stackoverflow.com/questions/784539/how-do-i-replace-all-line-breaks-in-a-string-with-br-tags
         * @access  public
         * @return  String
         */
        getDisplayableQuotation: function() {
            if (JSONUtils.valid(this._data.settings.raw) === true) {
                var raw = JSON.parse(this._data.settings.raw);
                return raw.quotation.trimToLength(200).replace(
                    /(?:\r\n|\r|\n)/g,
                    '<br />'
                );
            }
            StencilBooter.log('JSON parse error (A:gDQ)');
            return 'error #A:gDQ';
        },

        /**
         * getHash
         * 
         * Returns a hash (as a string) of the resource type and id. Useful for
         * comparing resource keys to assets, to see if an asset is actually
         * just a saved version of a resource.
         * 
         * @access  public
         * @return  String
         */
        getHash: function() {
            return (this._data.resourceType) + ':' + (this._data.resourceId);
        },

        /**
         * getPlacementDestination
         * 
         * @access  public
         * @return  String
         */
        getPlacementDestination: function() {
            if (
                this.get('resourceType') === 'TheNounProject'
                || this.get('resourceType') === 'Icons8'
                || this.get('resourceType') === 'VectorSearch'
            ) {
                return 'foreground';
            }
            return 'background';
        },

        /**
         * globalCategoriesFeaturedIn
         * 
         * @access  public
         * @return  Array
         */
        globalCategoriesFeaturedIn: function() {
            var categories = Categories.global.all(),
                index,
                features,
                matching = [];
            for (index in categories) {
                features = categories[index].get('features');
                if (ArrayUtils.contains(this.getHash(), features) === true) {
                    matching.push(categories[index]);
                }
            }
            return matching;
        },

        /**
         * globallyFeatured
         * 
         * @access  public
         * @return  Boolean
         */
        globallyFeatured: function() {
            var globalFeatures = Stencil.get('globalFeatures'),
                hash = this.getHash();
            return globalFeatures.indexOf(hash) !== -1;
        },

        /**
         * owned
         * 
         * @access  public
         * @return  false
         */
        owned: function() {
            return false;
        },

        /**
         * preload
         * 
         * Contains two different flows for preloading resized resources based
         * on whether the asset is a bitmap (eg. Pixabay) or vector (eg. The
         * Noun Project). When it's a vector, for now, I'm booting in the
         * original asset, because with TNP, it's a relatively small 84x84 pixel
         * bitmap.
         * 
         * @access  public
         * @param   Function success
         * @param   Function error
         * @return  void
         */
        preload: function(success, error) {
            if (this._data.resourceType === 'AlgoliaQuote') {
                success = success || function(){};
                success.apply(this);
            } else {

                // Bitmaps
                var urls = [];
                if (this._data.bitmap.toInt() === 1) {
                    urls.push(this.url('thumb'));
                }
                // Vectors
                else {
                    urls.push(this.url('original'));
                }

                // Load
                success = success || function(){};
                error = error || function(){};
                Images.preload(urls, success.proxy(this), error.proxy(this));
            }
        },

        /**
         * setBackgroundBitmapImageLayer
         * 
         * @note    Defaults to not auto selecting the drawing
         * @access  public
         * @param   Boolean locked
         * @param   undefined|Object options (optional)
         * @return  BackgroundBitmapImageLayer
         */
        setBackgroundBitmapImageLayer: function(locked, options) {
            options = options || {};
            var canvas = Canvases.Preview,
                layer = canvas.getBackgroundBitmapImageLayer(),
                drawing = layer.getDrawing(),
                key = this._data.key;
            layer.setChangeOperationType('image:changed');
            layer.setImage(key);
            layer.setProperty('locked', locked);
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access  private
                 * @return  void
                 */
                'refresh': function(event) {
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                    if (options.autoSelect === true) {
                        this.select();
                    }
                }
            });
            drawing.reload();
            return layer;
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = Categories.account.favorites(areaType);
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @note    Since it's possible that the features collection actually
         *          contains the ResourceAccessor for this AssetAccessor, I
         *          try and remove that as well, incase that's the one that's
         *          being stored in the collection.
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            var area = 'photos';
            if (category.get('graphics').toInt() === 1) {
                area = 'graphics';
            } else if (category.get('quotes').toInt() === 1) {
                area = 'quotes';
            }
            if (ArrayUtils.contains(category, Categories.global.all()) === true) {
                if (this.globalCategoriesFeaturedIn().length === 1) {
                    Stencil.globalFeatures.remove(this);
                }
            }
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.unfeature(
                    this._data.key,
                    {
                        category: category.get('key')
                    }
                );
            }
            this.triggerHandler('unfeature', [category]);
            this._references.resource.triggerHandler('unfeature', [category]);
            features.remove(this);
            features.remove(this._references.resource);
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with The Noun Project icons for the
         *   preview thumbnail
         * - Thumb image url, at the moment used for Pixabay resources that have
         *   been saved as assets
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options
         * @return  String|false
         */
        url: function(type, options) {
            if (type === 'original') {
                return Images.thumb(this._data.key, {
                    type: 'original'
                })
            } else if (type === 'thumb') {
                return Images.thumb(this._data.key, {
                    type: 'thumb'
                });
            }
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'CategoryModel'], function() {

    /**
     * CategoryAccessor
     * 
     * @extends Accessor
     */
    window.CategoryAccessor = Accessor.extend({

        /**
         * _paths
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _paths: {},

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Category'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoryAccessor')
         */
        _string: 'CategoryAccessor',

        /**
         * _syncedFeatures
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _syncedFeatures: [],

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._paths = {};
            this._syncedFeatures = [];
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Category deleted');
                }
            });
        },

        /**
         * _getQuoteCategoryPinUrl
         * 
         * @access  protected
         * @return  String
         */
        _getQuoteCategoryPinUrl: function() {
            var role = Config.getRole();
            if (role === 'local' || role === 'dev') {
                // return (window.STATIC) + '/app/static/images/logos/favicon.152x152.png';
            }
            var assetMap = {
                'Business': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstb956f154',
                'Friendship': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst244496ca',
                'Happiness': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst66eb379a',
                'Hope': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst8e3540fb',
                'Humor': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst5d6b5956',
                'Inspirational': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst3b331092',
                'Leadership': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst9a4d03a0',
                'Love': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asste7917584',
                'Nature': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst0dba3038',
                'Philosophy': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstcb54b664',
                'Relationships': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstae0dfc7b',
                'Religion': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst1879c88a',
                'Spirituality': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asstc9881e10',
                'Success': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst0eeda03b',
                'Wisdom': 'https://d3mnhso4gv2l51.cloudfront.net/full-fit-in/304x212/filters:quality(80)/asst7fffad4b',
            }
            if (assetMap[this._data.name] !== undefined) {
                return assetMap[this._data.name];
            }
            return (window.STATIC) + '/app/static/images/logos/favicon.152x152.png';
        },

        /**
         * belongsToAccount
         * 
         * @access  public
         * @return  Boolean
         */
        belongsToAccount: function() {
            return this._data.accountId.toInt() !== 0;
        },

        /**
         * featureObjects
         * 
         * @access  public
         * @param   Array keys
         * @return  void
         */
        featureObjects: function(keys) {
            this._model.featureObjects(this._data.key, {
                objects: keys
            });
        },

        /**
         * features
         * 
         * @access  public
         * @var     Object
         */
        features: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                var features = this._data.features,
                    key = accessor.get('key');
                if (accessor.toString() === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                features.push(key);
                this.set('count', this._data.count.toInt() + 1);
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var features = this._data.features,
                    key = accessor.get('key'),
                    index;
                if (accessor.toString() === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = features.indexOf(key);
                if (index !== -1) {
                    features.splice(index, 1);
                    this.set('count', this._data.count.toInt() - 1);
                }
            }
        },

        /**
         * getAreaString
         * 
         * @throws Error
         * @access  public
         * @return  String
         */
        getAreaString: function() {
            if (this._data.photos.toInt() === 1) {
                return 'Photos';
            }
            if (this._data.graphics.toInt() === 1) {
                return 'Graphics';
            }
            if (this._data.templates.toInt() === 1) {
                return 'Templates';
            }
            if (this._data.quotes.toInt() === 1) {
                return 'Quotes';
            }
            if (this._data.uploads.toInt() === 1) {
                return 'Uploads';
            }
            if (this._data.watermarks.toInt() === 1) {
                return 'Watermarks';
            }
            if (this._data.images.toInt() === 1) {
                return 'Images';
            }
            throw new Error('Invalid type for getAreaString');
        },

        /**
         * getLabelName
         * 
         * Returns the name for the filter label, rather than the name for
         * within the dropdown.
         * 
         * @note    The ss to sss regular expression change is to accommodate for
         *          cases like the term Business being converted to Businesss.
         * @throws  Error
         * @access  public
         * @return  String
         */
        getLabelName: function() {
            if (this._data.all.toInt() === 1) {
                if (this._data.images.toInt() === 1) {
                    return 'All Saved Images';
                }
                if (this._data.templates.toInt() === 1) {
                    return 'My Templates';
                }
                if (this._data.uploads.toInt() === 1) {
                    return 'All Uploads';
                }
                if (this._data.watermarks.toInt() === 1) {
                    return 'Logo / Watermark Uploads';
                }
                throw new Error('Invalid type (all)');
            }
            if (this._data.favorites.toInt() === 1) {
                if (this._data.images.toInt() === 1) {
                    return 'Favorite Saved Images';
                }
                if (this._data.graphics.toInt() === 1) {
                    return 'Favorite Icons';
                }
                if (this._data.photos.toInt() === 1) {
                    return 'Favorite Photos';
                }
                if (this._data.quotes.toInt() === 1) {
                    return 'Favorite Quotes';
                }
                if (this._data.templates.toInt() === 1) {
                    return 'Favorite Templates';
                }
                if (this._data.uploads.toInt() === 1) {
                    return 'Favorite Uploads';
                }
                throw new Error('Invalid type (favorites)');
            }
            if (this._data.featured.toInt() === 1) {
                if (this._data.graphics.toInt() === 1) {
                    return 'Featured Icons';
                }
                if (this._data.photos.toInt() === 1) {
                    return 'Featured Photos';
                }
                if (this._data.quotes.toInt() === 1) {
                    return 'Featured Quotes';
                }
                if (this._data.templates.toInt() === 1) {
                    return 'Featured Templates';
                }
                throw new Error('Invalid type (featured)');
            }
            if (this._data.global.toInt() === 1) {
                if (this._data.graphics.toInt() === 1) {
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Icons');
                }
                if (this._data.photos.toInt() === 1) {
                    if (this._data.name === 'Patterns') {
                        return 'Patterns';
                    }
                    if (this._data.name === 'Textures') {
                        return 'Textures';
                    }
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Photos');
                }
                if (this._data.quotes.toInt() === 1) {
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Quotes');
                }
                if (this._data.templates.toInt() === 1) {
                    return this._data.name.replace(/ss$/, 'sss').replace(/[s]?$/, ' Templates');
                }
            }
            return this._data.name;
        },

        /**
         * getPath
         * 
         * @note    Reroutes any custom categories that have a slug that
         *          conflicts with a slug from the respective area to the
         *          /collections/$slug path. This is to allow for collections
         *          that have the same name as global categories, while
         *          maintaining a clean URI structure. A bit unconventional, but
         *          allows for users to name their collections anything without
         *          causing an issue, and for us to be able to create new
         *          global categories without worrying about existing custom
         *          categories being overridden.
         * @throws  Error
         * @access  public
         * @param   undefined|Boolean excludeLeadingSlash (default: false)
         * @return  String
         */
        getPath: function(excludeLeadingSlash) {
            excludeLeadingSlash = DataUtils.getDefaultValue(
                excludeLeadingSlash,
                false
            );

            // Formatting
            var _this = this,
                type = _this.getType(),
                __format = function(path) {
                    var __formatOutput = function(path) {
                        if (excludeLeadingSlash === true) {
                            return path.replace(/^\//, '');
                        }
                        return path;
                    };
                    var __formatForUniqueness = function(path) {
                        if (_this._data.custom.toInt() === 1) {
                            var index,
                                categories = Categories.global.type(type);
                            categories.push(
                                Categories.account.favorites(type)
                            );
                            if (type === 'templates') {
                                categories.push(
                                    Categories.account.list(type)
                                );
                            }
                            if (_this._data.slug !== 'featured') {
                                for (index in categories) {
                                    if (categories[index].get('slug') === _this._data.slug) {
                                        return path.replace(/([^/]+)$/, 'collections/$1');
                                    }
                                }
                            }
                        }
                        return path;
                    };
                    return __formatOutput(
                        __formatForUniqueness(
                            path
                        )
                    );
                };

            // Path determination
            var slug = this._data.slug;
            if (this._data.graphics.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app/icons');
                }
                return __format('/app/icons/' + (slug));
            }
            if (this._data.images.toInt() === 1) {
                if (this._data.all.toInt() === 1) {
                    return __format('/app/saved');
                }
                return __format('/app/saved/' + (slug));
            }
            if (this._data.photos.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app');
                }
                return __format('/app/photos/' + (slug));
            }
            if (this._data.quotes.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app/quotes');
                }
                return __format('/app/quotes/' + (slug));
            }
            if (this._data.templates.toInt() === 1) {
                if (this._data.featured.toInt() === 1) {
                    return __format('/app/templates');
                }
                return __format('/app/templates/' + (slug));
            }
            if (this._data.uploads.toInt() === 1) {
                if (this._data.all.toInt() === 1) {
                    return __format('/app/uploads');
                }
                return __format('/app/uploads/' + (slug));
            }
            if (this._data.watermarks.toInt() === 1) {
                if (this._data.all.toInt() === 1) {
                    return __format('/app/logos');
                }
                throw new Error('Invalid slug');
            }
            throw new Error('Invalid type');
        },

        /**
         * getType
         * 
         * @throws Error
         * @access  public
         * @return  String
         */
        getType: function() {
            if (this._data.graphics.toInt() === 1) {
                return 'graphics';
            }
            if (this._data.images.toInt() === 1) {
                return 'images';
            }
            if (this._data.photos.toInt() === 1) {
                return 'photos';
            }
            if (this._data.quotes.toInt() === 1) {
                return 'quotes';
            }
            if (this._data.templates.toInt() === 1) {
                return 'templates';
            }
            if (this._data.uploads.toInt() === 1) {
                return 'uploads';
            }
            if (this._data.watermarks.toInt() === 1) {
                return 'watermarks';
            }
            throw new Error('Invalid data type');
        },

        /**
         * getPinUrl
         * 
         * @note    /w_0.5,c_crop,g_auto/
         * @see     http://cloudinary.com/documentation/image_transformations#automatic_cropping
         * @see     https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/if_ar_gt_1.0,h_212,c_scale/if_else,w_304,c_scale/s3.dev/asstda430352
         * @access  public
         * @return  String
         */
        getPinUrl: function() {
            if (this._data.quotes.toInt() === 1) {
                return this._getQuoteCategoryPinUrl();
            }
            if (this._data.pinKey !== false) {
                if (this._data.graphics.toInt() === 1) {
                    return Images.thumb(this._data.pinKey, {
                        type: 'original'
                    });
                }
                var url = Images.thumb(this._data.pinKey, {
                    type: 'thumb'
                });
                return url;
                // return Stencil.getAccessor(this._data.pin).url('thumb');
            }
            return (window.STATIC) + '/app/static/images/logos/favicon.152x152.png';
        },

        /**
         * pin
         * 
         * @access  public
         * @param   Accessor accessor
         * @return  void
         */
        pin: function(accessor) {
            this._model.pin(this._data.key, {
                objectType: accessor.get('class').toLowerCase(),
                objectKey:  accessor.get('key')
            });
            accessor.triggerHandler('pin');
        },

        /**
         * syncedFeatures
         * 
         * Helper methods to keep track of which objects have successfully had a
         * feature-record created (which is needed for sorting and deleting to
         * ensure no race-conditions).
         * 
         * @access  public
         * @var     Object
         */
        syncedFeatures: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                if (this.syncedFeatures.contains.apply(this, [accessor]) === false) {
                    this._syncedFeatures.push(accessor);
                    this.triggerHandler('syncedFeatures/add');
                }
            },

            /**
             * contains
             * 
             * @access  public
             * @param   Array|String|Accessor obj
             * @return  Boolean
             */
            contains: function(obj) {
                if (jQuery.isArray(obj) === true) {
                    if (obj.length === 0) {
                        return true;
                    }
                    var contains = this.syncedFeatures.contains.apply(
                        this, [obj[0]]
                    );
                    if (contains === false) {
                        return false;
                    }
                    return this.syncedFeatures.contains.apply(
                        this,
                        [obj.slice(1)]
                    );
                }
                if (jQuery.type(obj) === 'string') {
                    var index, accessor;
                    for (index in this._syncedFeatures) {
                        accessor = this._syncedFeatures[index];
                        if (accessor.get('key') === obj) {
                            return true;
                        }
                    }
                    return false;
                }
                return ArrayUtils.contains(obj, this._syncedFeatures) === true;
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var index = this._syncedFeatures.indexOf(accessor);
                if (index !== -1) {
                    this._syncedFeatures.splice(index, 1);
                    this.triggerHandler('syncedFeatures/remove');
                }
            }
        },

        /**
         * unfeatureObjects
         * 
         * @access  public
         * @param   Array keys
         * @return  void
         */
        unfeatureObjects: function(keys) {
            this._model.unfeatureObjects(this._data.key, {
                objects: keys
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'ColorModel'], function() {

    /**
     * ColorAccessor
     * 
     * @extends Accessor
     */
    window.ColorAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Color'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorAccessor')
         */
        _string: 'ColorAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Color deleted');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'ConnectionModel'], function() {

    /**
     * ConnectionAccessor
     * 
     * @extends Accessor
     */
    window.ConnectionAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Connection'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionAccessor')
         */
        _string: 'ConnectionAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Connection deleted');
                }
            });
        },

        /**
         * getLabel
         * 
         * @access  public
         * @return  String
         */
        getLabel: function() {
            var type = this._data.type;
            if (type === 'account') {
                return 'Page';
            }
            return 'Profile';
        },

        /**
         * getImageSrc
         * 
         * @access  public
         * @return  String
         */
        getImageSrc: function() {
            if (this._data.network === 'twitter') {
                return this._data.image;
            }
            return this._data.image.replace(
                'graph.facebook.com/',
                'graph.facebook.com/v2.9/'
            );
        },

        /**
         * getPath
         * 
         * @throws Error
         * @access  public
         * @return  String
         */
        getPath: function() {
            var id = this._data.networkResourceId,
                label = this._data.label;
            switch (this._data.network) {
                case 'facebook':
                    return 'https://facebook.com/' + (id);
                case 'twitter':
                    return 'https://twitter.com/' + (label);
            }
            throw new Error('Invalid network');
        },

        /**
         * getRaw
         * 
         * @access  public
         * @return  Object
         */
        getRaw: function() {
            return JSON.parse(this._data.raw);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'CouponModel'], function() {

    /**
     * CouponAccessor
     * 
     * @extends Accessor
     */
    window.CouponAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Coupon'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CouponAccessor')
         */
        _string: 'CouponAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Coupon deleted');
                }
            });
        },

        /**
         * trial
         * 
         * @access  public
         * @return  Boolean
         */
        trial: function() {
            return this._data.trial.toInt() !== 0;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'CustomerModel'], function() {

    /**
     * CustomerAccessor
     * 
     * @extends Accessor
     */
    window.CustomerAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Customer'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomerAccessor')
         */
        _string: 'CustomerAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * stripe
         * 
         * @access  public
         * @return  String
         */
        stripe: function() {
            var link = 'https://dashboard.stripe.com/';
            if (Config.getRole() !== 'prod') {
                link += 'test/';
            }
            link += 'customers/' + (this._data.gatewayKey);
            return link;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'FeatureModel'], function() {

    /**
     * FeatureAccessor
     * 
     * @extends Accessor
     */
    window.FeatureAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Feature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FeatureAccessor')
         */
        _string: 'FeatureAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'FontModel'], function() {

    /**
     * FontAccessor
     * 
     * @see     https://speakerdeck.com/bramstein/web-fonts-performance
     * @events  load/full
     * @extends Accessor
     */
    window.FontAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Font'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontAccessor')
         */
        _string: 'FontAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupUpload();
        },

        /**
         * _setupUpload
         * 
         * @access  protected
         * @return  void
         */
        _setupUpload: function() {
            var model = Stencil.getModel('Upload');
            this._references.upload = model.setAccessor(this._data.upload);
        },

        /**
         * delete
         * 
         * I'm overriding the Accessor delete method, because with fonts, they
         * never actually deleted. Rather they get marked as inactive, to ensure
         * the data can still be loaded later on (eg. for deleted fonts in saved
         * images, or featured templates that use uploaded or imported fonts).
         * 
         * @access  public
         * @return  void
         */
        delete: function() {
            this.set({
                'deleted': true
            });
            this.push('active', 0);
            this.triggerHandler('delete');
            this.removeAll();
        },

        /**
         * drawStyleSheet
         * 
         * @access  public
         * @return  void
         */
        drawStyleSheet: function() {
            var type = 'woff';
            if (UserAgent.supports.woff2() === true) {
                type = 'woff2';
            }
            var style = '@font-face {' +
                'font-family:"' + (this.get('familyName')) + '";' +
                'src:url("' + (this.getUrl(type)) + '") ' +
                'format("' + (type) + '");' +
            '}';
            $('head').append('<style type="text/css">' + (style) + '</style>');
        },

        /**
         * getUrl
         * 
         * @access  public
         * @param   String type
         * @return  String
         */
        getUrl: function(type) {
            var key = this._references.upload.get('key');
            if (type === 'woff') {
                key += '.woff';
                return Images.cloudFront(key);
            }
            if (type === 'woff2') {
                key += '.woff2';
                return Images.cloudFront(key);
            }
            if (type === 'otf') {
                key += '.otf';
                return Images.cloudFront(key);
            }
            if (type === 'ttf') {
                key += '.ttf';
                return Images.cloudFront(key);
            }
            throw new Error('Invalid type for getUrl of font');
        },

        /**
         * loadFull
         * 
         * Fully loads specific font (including any available styles such as
         * bold, italic and bold + italic).
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        loadFull: function(callback) {

            // Determine what should be loaded
            var familyName = this.get('familyName'),
                loadableVersions = [];
            loadableVersions.push((familyName) + ':n4');
            if (this.get('bold').toInt() === 1) {
                loadableVersions.push((familyName) + ':n7');
            }
            if (this.get('italic').toInt() === 1) {
                loadableVersions.push((familyName) + ':i4');
            }
            if (this.get('boldItalic').toInt() === 1) {
                loadableVersions.push((familyName) + ':i7');
            }

            // Determine what font versions (if any) should be loaded
            var collection = Stencil.account().collection('fonts'),
                loadedFontFamilies = collection.getLoaded(),
                fontsAlreadyLoaded = _.intersection(
                    loadedFontFamilies,
                    loadableVersions
                ),
                fontVersionToLoad = _.difference(
                    loadableVersions,
                    fontsAlreadyLoaded
                );

            // If there's nothing to load, we're good
            if (fontVersionToLoad.length === 0) {
                callback && callback();
            }
            // If it's a native font
            else if (this.get('native').toInt() === 1) {
                callback && callback();
            }
            // Otherwise let's go ahead with this
            else {

                // If the font is already being loaded
                var loadingFontFamilies = collection.getLoading(),
                    fontBeingLoaded = _.indexOf(
                        loadingFontFamilies,
                        fontVersionToLoad[0]
                    ) !== -1;
                if (callback !== undefined) {
                    this.once({
                        'load/full/success load/full/failed': callback
                    });
                }

                // Font hasn't yet been loaded
                if (fontBeingLoaded === false) {

                    // Track what's being loaded
                    loadingFontFamilies.push.apply(
                        loadingFontFamilies,
                        fontVersionToLoad
                    );

                    /**
                     * There's a strange bug with the WebFont library, in
                     * that when only a custom font is requested, the
                     * library will error out with "No fonts to load!"
                     * 
                     * This is because it does not seem to be accounting
                     * for a single custom font being loaded along with an
                     * empty array of Google fonts.
                     * 
                     * To deal with this, I make the call to the load method
                     * by passing in the webFontConfigObject, which only
                     * adds the google fonts if the array has at least one
                     * entry.
                     */
                    var webFontConfigObject = {
                        classes: false,
                        fontactive: (function(familyName, fvd) {
                            var formattedFamilyName = (familyName) + ':' + (fvd),
                                loadingArrayIndex = _.indexOf(
                                    loadingFontFamilies,
                                    formattedFamilyName
                                );
                            loadedFontFamilies.push(formattedFamilyName);
                            loadingFontFamilies.splice(loadingArrayIndex, 1);
                            if (loadingFontFamilies.length === 0) {
                                this.triggerHandler('load/full/success');
                            }
                        }).proxy(this),
                        /** 
                         * There was an issue with IE11 whereby a font
                         * would fail to load. To accommodate this, for
                         * now, trigger a failed alert, which is the
                         * same as the loaded event.
                         * 
                         * This will ensure the callback gets triggered
                         * (even if it is wrong for now).
                         */
                        fontinactive: (function(familyName, fvd) {
                            var formattedFamilyName = (familyName) + ':' + (fvd),
                                loadingArrayIndex = _.indexOf(
                                    loadingFontFamilies,
                                    formattedFamilyName
                                );
                            loadingFontFamilies.splice(loadingArrayIndex, 1);
                            if (loadingFontFamilies.length === 0) {
                                this.triggerHandler('load/full/failed');
                            }
                        }).proxy(this),
                        timeout: 5000
                    };

                    // Determine which kind of font is being loaded
                    if (this.get('uploaded').toInt() === 0) {
                        webFontConfigObject.google = {
                            families: DataUtils.convertGoogleFontNames(fontVersionToLoad)
                        };
                    } else {
                        webFontConfigObject.custom = {
                            families: DataUtils.convertGoogleFontNames(fontVersionToLoad)
                        };
                    }

                    // Initiate the load
                    WebFont.load(webFontConfigObject);
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'FrameModel'], function() {

    /**
     * FrameAccessor
     * 
     * @extends Accessor
     */
    window.FrameAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Frame'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FrameAccessor')
         */
        _string: 'FrameAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Frame deleted');
                }
            });
        },

        /**
         * getIcon
         * 
         * @access  public
         * @return  string
         */
        getIcon: function() {
            switch (this._data.tag) {
                case 'email':
                    return 'fa-envelope-o';
                case 'facebook':
                    return 'fa-facebook';
                case 'googlePlus':
                    return 'fa-google-plus';
                case 'instagram':
                    return 'fa-instagram';
                case 'linkedin':
                    return 'fa-linkedin';
                case 'eBookCover':
                    return 'fa-book';
                case 'pinterest':
                    return 'fa-pinterest-p';
                case 'twitter':
                    return 'fa-twitter';
                case 'youtube':
                    return 'fa-youtube';
                default:
                    return 'fa-circle';
            }
        },

        /**
         * getRatio
         * 
         * @access  public
         * @return  Number
         */
        getRatio: function() {
            return this._data.width / this._data.height;
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            window.Frame = this;
            var draft = Stencil.account().draft();
            draft.set({
                frame: Frame.get('key'),
                width: Frame.get('width').toInt(),
                height: Frame.get('height').toInt()
            });
        },

        /**
         * setToPreviewCanvas
         * 
         * @access  public
         * @return  void
         */
        setToPreviewCanvas: function() {
            var content = App.getStage().getContent(),
                framer = content.getFramer(),
                canvas = Canvases.Preview;
            this.updateMessaging();
            canvas.once({
                'refresh': function(event) {
                    var layer = canvas.getBackgroundBitmapImageLayer();
                    layer.getCotton().trigger('lock');
                    canvas.render();
                }
            });
            canvas.refreshLayers();
        },

        /**
         * updateMessaging
         * 
         * @access  public
         * @return  void
         */
        updateMessaging: function() {
            var content = App.getStage().getContent(),
                framer = content.getFramer();
            content.updateReframer();
            framer.updateSelected();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'GoogleFontModel'], function() {

    /**
     * GoogleFontAccessor
     * 
     * @extends Accessor
     */
    window.GoogleFontAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GoogleFont'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontAccessor')
         */
        _string: 'GoogleFontAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * alreadyImported
         * 
         * @access  public
         * @return  Boolean
         */
        alreadyImported: function() {
            var uploadedFonts = Stencil.account().collection('fonts').getUploaded(),
                index,
                upload;
            for (index in uploadedFonts) {
                upload = uploadedFonts[index].reference('upload');
                if (this._data.file.indexOf(upload.get('name')) !== -1) {
                    return true;
                }
            }
            return false;
        },

        /**
         * drawStyleSheet
         * 
         * @access  public
         * @return  void
         */
        drawStyleSheet: function() {
            var fontFamily = this.get('id'),
                style = '@font-face {' +
                    'font-family:"' + (fontFamily) + '";' +
                    'src:url("' + (this.get('file')) + '")'  +
                '}';
            $('head').append('<style type="text/css">' + (style) + '</style>');
        },

        /**
         * getExtendedSubsets
         * 
         * @access  public
         * @return  Array
         */
        getExtendedSubsets: function() {
            var standardSubsets = ['latin', 'latin-ext'],
                extendedSubsets = [],
                index,
                subset;
            for (index in this._data.subsets) {
                subset = this._data.subsets[index];
                if (ArrayUtils.contains(subset, standardSubsets) === false) {
                    extendedSubsets.push(subset);
                }
            }
            return extendedSubsets;
        },

        /**
         * getExtendedSubsetsTooltip
         * 
         * @access  public
         * @return  String
         */
        getExtendedSubsetsTooltip: function() {
            var extendedSubsets = this.getExtendedSubsets(),
                index;
            for (index in extendedSubsets) {
                extendedSubsets[index] = extendedSubsets[index].ucfirst();
            }
            return 'Supports: <br> - ' + extendedSubsets.join('<br> - ');
        },

        /**
         * getVariant
         * 
         * @note    The following is the breakdown of strength to english
         *          adjective:
         *          - 100: Thin
         *          - 200: Extra-Light
         *          - 300: Light
         *          - 400: Regular
         *          - 500: Medium
         *          - 600: Semi-Bold
         *          - 700: Bold
         *          - 800: Extra-Bold
         *          - 900: Black
         * @access  public
         * @return  String
         */
        getVariant: function() {

            // Map the weights to the english equivalent
            var weightMap = {
                    100: 'Thin',
                    200: 'Extra-Light',
                    300: 'Light',
                    400: 'Regular',
                    500: 'Medium',
                    600: 'Semi-Bold',
                    700: 'Bold',
                    800: 'Extra-Bold',
                    900: 'Black'
                },
                useWeightMap = true;

            // No italics
            if (this._data.variant.match(/italic/) === null) {
                if (useWeightMap === true) {
                    return weightMap[this._data.variant];
                }
                return this._data.variant;
            }

            // Italics
            if (useWeightMap === true) {
                var weight = this._data.variant.match(/^[0-9]+/)[0];
                return (weightMap[weight]) + ' + Italic';
            }

            // Keep weight
            return this._data.variant.replace(/^([0-9]+)italic$/, '$1 + Italic');
        },

        /**
         * hasExtendedSubsetSupport
         * 
         * @access  public
         * @return  Boolean
         */
        hasExtendedSubsetSupport: function() {
            return this.getExtendedSubsets().length > 0;
        },

        /**
         * import
         * 
         * @access  public
         * @return  void
         */
        import: function() {
            this._model.import(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'ImageModel'], function() {

    /**
     * ImageAccessor
     * 
     * @fires   download
     *          normalize
     *          preload
     *          select
     *          favorite
     *          template
     *          unfavorite
     *          upload/abort
     *          upload/error
     *          upload/progress
     *          upload/success
     * @extends MediaAccessor
     */
    window.ImageAccessor = MediaAccessor.extend({

        /**
         * _imageDocument
         * 
         * @access  protected
         * @var     ImageDocument (default: false)
         */
        _imageDocument: false,

        /**
         * _lastSavedConfigurationString
         * 
         * Reference to the last JSON string that was saved for this image. Used
         * to prevent PATCH calls on an image when it's underlying JSON hasn't
         * changed.
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastSavedConfigurationString: '',

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Image'),

        /**
         * _saveConfigurationTimeout
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _saveConfigurationTimeout: null,

        /**
         * _srcs
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _srcs: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageAccessor')
         */
        _string: 'ImageAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.set({
                'resourceGatewaySave': '0'
            });
            this._setupSourceImage();
            this.markConfigurationAsSaved();
            this.on({
                'change/settings.locked': function(event, value) {
                    var $lock = App.getStage().getContent().find('div.sandbox a.lock');
                    $lock.addClass('hidden');
                    if (value.toInt() === 1) {
                        $lock.removeClass('hidden');
                    }
                },
                'delete': function(event) {
                    Track.event('Image deleted', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'download': function(event) {
                    Track.event('Image downloaded', {
                        _url: this.url('original')
                    });
                },
                'feature': function(event) {
                    Track.event('Image featured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'preload': function(event) {
                    this.set({
                        'preloaded': 1
                    });
                },
                'select': function(event, method, locked, options) {
                    if (
                        this._data.legacy.toInt() === 1
                        && this._data.legacyNormalized.toInt() === 0
                    ) {
                        this.normalize();
                    } else {

                        // If they don't own it
                        if (ChangeHistory.persistWatermarksForFeaturedTemplates() === true) {
                            Stencil.set('smartToggleWatermarks', true);
                            if (this.owned() === false) {
                                Stencil.set('smartToggleWatermarks', false);
                            }
                        }

                        // 
                        // this._confirmImageChange().on({
                        //     'yes': function(event) {
                                var canvas = Canvases.Preview;
                                if (canvas.get('drawing') === true) {
                                    var key = 'image.select.pending',
                                        msg = Stencil.getMessage(key);
                                    App.getBusy().show(msg);
                                    var start = new Date();
                                    canvas.once({
                                        'render': function(event, content) {
                                            var busy = App.getBusy();
                                            busy.hide.minDelay(
                                                start,
                                                1750,
                                                busy
                                            );
                                        }
                                    });
                                } else {
                                    // Footer.disable.save.apply(Footer);
                                    this._setToPreviewCanvas(
                                        method, locked, options
                                    );
                                }
                            // }
                        // });
                    }
                },
                'unfeature': function(event, category) {
                    Track.event('Image unfeatured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                }
            });
            if (this._data.uploaded.toInt() === 1) {
                this.set({
                    'preloaded': 1
                });
            }
        },

        /**
         * _confirmImageChange
         * 
         * @access  protected
         * @return  ConfirmModalView
         */
        _confirmImageChange: function() {
            var _this = this,
                h1 = 'This will swap out all your images and text.',
                h2 = 'Are you sure?',
                modal = Modals.showConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function(event) {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        },

        /**
         * _download
         * 
         * This internal method is as complicated as it is because in Safari,
         * triggering a location change kills any running ajax calls. So I wait
         * for all active remote connections to finish before triggering the
         * location change.
         * 
         * After that, I check for a cookie (set on the server side which
         * communicates to the front end that the image download has begun), to
         * hide the busy modal.
         * 
         * Note that it be worthwhile flow for Safari, since it is the only
         * outlier.
         * 
         * @access  protected
         * @param   false|String mime
         * @param   false|String filename
         * @param   Boolean scaleForRetina
         * @param   false|Number maxBytes
         * @param   false|String mediaType
         * @return  void
         */
        _download: function(mime, filename, scaleForRetina, maxBytes, mediaType) {
            var path = this._getDownloadPath(mime, filename, scaleForRetina, maxBytes, mediaType),
                intervals = {},
                checks = {
                    cookie: function() {
                        if (
                            Cookies.get('image.download.started') !== undefined
                        ) {
                            IntervalPool.clear(intervals.cookie);
                            Stencil.cookies.remove('image.download.started');
                            App.getBusy().hide();
                            this.triggerHandler('download');
                            Stencil.set('redirecting', false);
                            Stencil.triggerHandler('redirect/complete');
                        }
                    },
                    connections: function() {
                        // if (UserAgent.is.safari() === false || XHRPool.length() === 0) {
                        if (XHRPool.length() === 0) {
                            IntervalPool.clear(intervals.connections);
                            Stencil.triggerHandler('redirect/start');
                            Stencil.set('redirecting', true);
                            if (
                                (
                                    UserAgent.extension() === true
                                    && UserAgent.hasCSP() === true
                                )
                                // || UserAgent.is.ipad() === true
                            ) {
                                window.open(path);
                            } else {
                                window.location.assign(path);
                            }
                            intervals.cookie = checks.cookie.interval(50, this);
                        }
                    }
                };
            intervals.connections = checks.connections.interval(50, this);
        },

        /**
         * _getDownloadPath
         * 
         * @access  protected
         * @param   false|String mime
         * @param   false|String filename
         * @param   Boolean scaleForRetina
         * @param   false|Number maxBytes
         * @param   false|String mediaType
         * @return  String
         */
        _getDownloadPath: function(mime, filename, scaleForRetina, maxBytes, mediaType) {
            var path = '/images/' + (this._data.key) + '/download',
                params = {};
            if (mime !== false) {
                if (mime === 'image/jpeg') {
                    params.m = '1';
                } else if (mime === 'image/png') {
                    params.m = '2';
                } else if (mime === 'application/octet-stream') {
                    params.m = '3';
                }
            }
            if (filename !== false) {
                params.filename = filename;
            }
            if (scaleForRetina === true) {
                params.pushRaw = 1;
            }
            if (maxBytes !== false) {
                params.maxBytes = maxBytes.toInt();
            }
            if (mediaType !== false) {
                params.mediaType = mediaType;
            }
            return (path) + '?' + jQuery.param(params);
        },

        /**
         * _setSourceImage
         * 
         * @access  protected
         * @param   ImageAccessor sourceImage
         * @return  void
         */
        _setSourceImage: function(sourceImage) {
            this._references.sourceImage = sourceImage;
        },

        /**
         * _setToPreviewCanvas
         * 
         * Method to draw the image represented in the current ImageAccessor to
         * the preview canvas. Does this by deleting any existing layers,
         * setting the account draft to this ImageAccessor (which simply copies
         * over relevant data, such as the frame, width, height, source image
         * id, and json), setting the frame to the new size, and preparing /
         * drawing the canvas.
         * 
         * The check within the render event is intended to check if the image
         * being loaded into the preview canvas is owned by the user (regardless
         * of whether it's a template or image). If it is, I set the image (in
         * the footer, of all places, haha) to ensure that the user can download
         * and P+S, since the image is not yet different.
         * 
         * @access  protected
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        _setToPreviewCanvas: function(method, locked, options) {
            var _this = this,
                account = Stencil.account(),
                draft = account.draft(),
                orphan = account.orphanFrame(),
                frame,
                document,
                imageDocument,
                canvas = Canvases.Preview;
            draft.getImageDocument().deleteAllLayers();
            draft.setToImage(this, method, locked, options);
            App.setSelectedFrame();

            // // Ensure proper draft is set
            // frame = draft.get('frame');
            // frame = Stencil.getAccessor(frame);
            // if (frame === false || frame === orphan) {
            //     frame = orphan;
            //     orphan.set({
            //         width: draft.get('width'),
            //         height: draft.get('height').toInt()
            //     });
            // } else {
            //     if (
            //         frame.get('width').toInt() !== draft.get('width').toInt()
            //         || frame.get('height').toInt() !== draft.get('height').toInt()
            //     ) {
            //         frame = orphan;
            //         orphan.set({
            //             width: draft.get('width'),
            //             height: draft.get('height').toInt()
            //         });
            //     }
            // }
            // frame.select();
            // frame.updateMessaging();

            // Draw
            document = draft.json();
            imageDocument = new ImageDocument(document, draft, canvas);
            draft.setImageDocument(imageDocument);
            canvas.once({
                'render': function(event) {
                    if (_this.owned() === true) {
                        // console.log('owned');

                        /**
                         * The following prevents the same image from being set
                         * in the Footer when it's just a redo or undo operation
                         * being completed.
                         */
                        if (draft !== _this) {
                            Footer.setLastSavedImage(_this);
                        } else {
                            var sourceImage = _this.getSourceImage();
                            if (sourceImage === false) {
                                Footer.setLastSavedImage(false);
                            } else if (sourceImage === undefined) {
                                Footer.setLastSavedImage(false);
                            } else {
                                if (sourceImage.deleted() === false) {
                                    if (sourceImage.owned() === true) {
                                        Footer.setLastSavedImage(sourceImage);
                                    }
                                }
                            }
                        }
                    }

                    /**
                     * Need to call the Footer.reset here because otherwise if
                     * there are layers with filters on them, it's possible that
                     * the Footer will show the wrong button-states.
                     * 
                     * This happens because the filters can take some time to
                     * run (especially the more complicated ones), and because
                     * of a race-condition whereby the fabric renderAll event is
                     * triggered after we need it to (specically, the fabric
                     * after:render event fires after we need it to), this bug
                     * exists.
                     */
                    Footer.reset();
                    _this.triggerHandler('set/previewCanvas/finish');
                }
            });

            /**
             * Same goes here: I'm only showing the busy modal over top of the
             * preview canvas if it's not the draft itself that's being set,
             * which if it is, it's just a redo or undo operation being
             * completed.
             */
            var showBusyModal = true;
            if (draft === this) {
                showBusyModal = false;
            }
            canvas.draw(showBusyModal);
            draft.setConfiguration();
        },

        /**
         * _setupSourceImage
         * 
         * The first check against the property being undefined is because when
         * an image-record's public data is retrieved, no sourceImage property
         * is passed down unless it's a deep-public-data retrieval.
         * 
         * In the case that it is, it's possible that there is no sourceImage
         * (for example, legacy images). For those, false is passed down, thus
         * the second check.
         * 
         * @access  protected
         * @return  void
         */
        _setupSourceImage: function() {
            if (this._data.sourceImage !== undefined) {
                if (this._data.sourceImage !== false) {
                    var model = Stencil.getModel('Image');
                    this._references.sourceImage = model.setAccessor(
                        this._data.sourceImage
                    );
                }
            }
        },

        /**
         * _syncedToAnyCategory
         * 
         * @access  protected
         * @return  Boolean
         */
        _syncedToAnyCategory: function() {
            var categories = Categories.account.all({
                    images: 1
                }),
                index;
            for (index in categories) {
                if (this._syncedToCategory(categories[index]) === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _syncedToCategory
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        _syncedToCategory: function(category) {
            return category.syncedFeatures.contains.apply(category, [this]) === true;
        },

        /**
         * _syncedToListCategory
         * 
         * @access  protected
         * @return  Boolean
         */
        _syncedToListCategory: function() {
            var category = Categories.account.list('images');
            return this._syncedToCategory(category);
        },

        /**
         * clearSaveConfigurationTimeout
         * 
         * @access  public
         * @return  void
         */
        clearSaveConfigurationTimeout: function() {
            TimeoutPool.clear(this._saveConfigurationTimeout);
        },

        /**
         * delete
         * 
         * @access  public
         * @param   Boolean autoHideBusyModal (default: true) Used to prevent
         *          busy modal from hiding when called by through multi-delete
         *          flow
         * @return  void
         */
        delete: function(autoHideBusyModal) {
            autoHideBusyModal = DataUtils.getDefaultValue(
                autoHideBusyModal,
                true
            );
            if (this._data.uploaded.toInt() === 1) {
                if (autoHideBusyModal === true) {
                    App.getBusy().hide();
                }
                if (Stencil.account().draft().getSourceImage() === this) {
                    var previousSourceImageId = Stencil.account().draft().get('sourceImageId').toInt();
                    Stencil.account().draft().removeSourceImage();
                    Footer.setLastSavedImage(false);
                    Footer.reset();
                    ChangeHistory.syncSourceImageId(previousSourceImageId, 0);
                }
                this._super();
            } else {
                var msg = Stencil.getMessage('image.delete.pending');
                App.getBusy().show(msg);
                this.once({
                    'model/feature': this.delete.proxy(this)
                });
            }
        },

        /**
         * download
         * 
         * @todo    Look into whether this may be a problem for popup blockers.
         *          If so, for those browsers, show messaging in the busy modal
         *          that we're saving the image, and once complete, show an
         *          alert prompting them to try downloading again.
         * @access  public
         * @param   false|String mime
         * @param   false|String filename
         * @param   Boolean scaleForRetina
         * @param   false|Number maxBytes
         * @param   false|String mediaType
         * @param   Boolean showBusyModal
         * @return  void
         */
        download: function(mime, filename, scaleForRetina, maxBytes, mediaType, showBusyModal) {
            if (Account.delinquent() === true) {
                Stencil.navigate('/app/delinquent?clean=1');
            } else {
                if (this._data.uploaded.toInt() === 1) {
                    if (showBusyModal === true) {
                        var msg = Stencil.getMessage('image.download.pending.direct');
                        App.getBusy().show(msg);
                    }
                    this._download.apply(this, [
                        mime,
                        filename,
                        scaleForRetina,
                        maxBytes,
                        mediaType
                    ]);
                } else {
                    if (showBusyModal === true) {
                        var msg = Stencil.getMessage('image.download.pending');
                        App.getBusy().show(msg);
                    }
                    this.once({
                        'change/uploaded': this._download.proxy(
                            this,
                            [mime, filename, scaleForRetina, maxBytes, mediaType]
                        )
                    });
                }
            }
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = Categories.account.favorites('images');
            this.feature(category, performDataRequest);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('images').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelFeatureCall = function() {
                    this._model.feature(
                        this._data.key,
                        {
                            category: category.get('key')
                        },
                        (function(data) {
                            this.triggerHandler('feature/complete');
                        }).proxy(this)
                    );
                };
                if (this._syncedToAnyCategory() === true) {
                    modelFeatureCall.apply(this);
                } else {
                    this.once({
                        'update/uploaded': function(event) {
                            modelFeatureCall.apply(this);
                        }
                    });
                }
            }
            this.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * generateShortUrl
         * 
         * @access  public
         * @return  void
         */
        generateShortUrl: function() {
            if (this._data.uploaded.toInt() === 1) {
                this._model.generateShortUrl(this._data.key);
            } else {
                this.once({
                    'update/uploaded': this.generateShortUrl.proxy(this)
                });
            }
        },

        /**
         * getConfiguration
         * 
         * Returns the unique "recipe" for this image, including the frame (if
         * any, otherwise an empty string), the width and height (traditionally
         * set through a Frame, but now set explictly if the Frame has since
         * been deleted or else does not exist) and the settings, including the
         * json (which defines the layout of all the layers) and watermarks
         * (which helps determine whether the image is unique relative to other
         * watermarks being turned on and off).
         * 
         * @access  public
         * @return  Object
         */
        getConfiguration: function() {
            // var json = this._imageDocument.json(false),
            //     watermarks = this._imageDocument.getWatermarkLayersJson(),
            var configuration = {
                frame: this._data.frame,
                width: this._data.width.toInt(),
                height: this._data.height.toInt(),
                sourceImageId: 0,
                settings: {
                    json: this.setting('json'),
                    watermarks: this.setting('watermarks')
                }
            };
            if (this._imageDocument !== false) {
                var imageDocument = this._imageDocument;
            // if (this === Stencil.account().draft()) {
                configuration.settings = {
                    json: JSON.stringify(imageDocument.json(false)),
                    watermarks: JSON.stringify(
                        imageDocument.getWatermarkLayersJson()
                    )
                };
                if (this._imageDocument.getCanvas() === Canvases.Preview) {
                    configuration.frame = Frame.get('key');
                }
            }
            if (
                this.getSourceImage() !== undefined
                && this.getSourceImage() !== false
            ) {
                configuration.sourceImageId = this.getSourceImage().get('id').toInt();
            }
            return configuration;
        },

        /**
         * getDefaultFilename
         * 
         * @access  public
         * @return  String
         */
        getDefaultFilename: function() {
            var mime = this.getRecommendedExportMime(),
                extension = 'png';
            if (mime === 'image/jpeg') {
                extension = 'jpg';
            }
            if (Frame.get('key') === 'frm-orphan') {
                return 'stencil.' + (extension);
            }
            if (Frame.get('key').match(/frm0/) !== null) {
                var frame = Stencil.getAccessor(Frame.get('key'));
                if (frame === false) {
                    return 'stencil.' + (extension);
                }
                if (frame.get('label').trim() === '') {
                    return 'stencil.' + (extension);
                }
                return 'stencil.' + StringUtils.slugify(frame.get('label'), 48) + '.' + (extension);
            }
            var frames = Frames.all(),
                frame;
            for (var index in frames) {
                frame = frames[index];
                if (Frame.get('key') === frame.key) {
                    return 'stencil.' + StringUtils.slugify(Frame.get('label'), 48) + '.' + (extension);
                }
            }
            return 'stencil.' + (extension);
        },

        /**
         * getFrame
         * 
         * @note    Needed for download modal of previously saved image
         * @access  public
         * @return  FrameAccessor
         */
        getFrame: function() {
        },

        /**
         * getImageDocument
         * 
         * @access  public
         * @return  ImageDocument
         */
        getImageDocument: function() {
            return this._imageDocument;
        },

        /**
         * getRecommendedExportMime
         * 
         * @todo    The first check below against the background bitmap image
         *          layer ought to check filters to see if there is an opacity
         *          filter set, and if so, return image/png. The reason it
         *          doesn't matter at the moment is because the opacity filter
         *          doesn't act as it should, since the background rectangle is
         *          set to white, which negates any useful opacity.
         * @access  public
         * @return  String
         */
        getRecommendedExportMime: function() {

            // Mime already defined (previously uploaded)
            // if (this._data.mime !== '') {
            //     return this._data.mime;
            // }

            // Background image set
            var backgroundBitmapImageLayer = Canvases.Preview.getBackgroundBitmapImageLayer();
            if (backgroundBitmapImageLayer.getProperty('image') !== false) {
                return 'image/jpeg';
            }

            // Background rectangle has transparency
            var backgroundRectangleLayer = Canvases.Preview.getBackgroundRectangleLayer();
            if (backgroundRectangleLayer.hasTransparency() === true) {
                return 'image/png';
            }

            // Solid color background + foreground bitmap image layers
            var foregroundBitmapImageLayers = Canvases.Preview.getForegroundBitmapImageLayers();
            if (foregroundBitmapImageLayers.length > 0) {
                return 'image/jpeg';
            }

            // Solid color background + watermark bitmap image layers
            var watermarkBitmapImageLayers = Canvases.Preview.getWatermarkLayers();
            if (watermarkBitmapImageLayers.length > 0) {
                return 'image/jpeg';
            }

            // Otherwise, basic image (including vectors which are basic)
            return 'image/png';
        },

        /**
         * getSentPath
         * 
         * @access  public
         * @return  String
         */
        getSentPath: function() {
            var path = '/app/images/';
            path += this._data.key;
            path += '/sent?clean=1';
            return path;
        },

        /**
         * getSharePath
         * 
         * @access  public
         * @param   String network
         * @return  String
         */
        getSharePath: function(network) {
            var path = '/app/images/';
            path += this._data.key;
            path += '/share/' + (network);
            return path;
        },

        /**
         * getSnippet
         * 
         * I am checking if it is a legacy image here because I want to prevent
         * looping over the json-setting for them. This is simply because most
         * of the time for legacy images, the json-setting will not have been
         * normalized at the start.
         * 
         * In this case, I still return the placeholder text below, because if
         * I do not, Buffer fails to pull in the image itself.
         * 
         * @access  public
         * @param   Number|false limit
         * @return  Object
         */
        getSnippet: function(limit) {
            if (this._data.legacy.toInt() === 1) {
                return {
                    default: true,
                    snippet: 'Enter your own message here'
                };
            }
            if (JSONUtils.valid(this._data.settings.json) === true) {
                var layers = JSON.parse(this._data.settings.json).layers,
                    text = [];
                jQuery.each(layers, function(index, layer) {
                    if (layer.type === 'text') {
                        text.push(layer.text.trim());
                    }
                });
                if (text.length === 0) {
                    return {
                        default: true,
                        snippet: 'Enter your own message here'
                    };
                }

                // Limit check
                if (limit === false) {
                    return {
                        default: false,
                        snippet: text.join(' / ')
                    };
                }
                text = text.join(' / ');
                if (text.length > limit) {
                    return {
                        default: false,
                        snippet: text.substring(0, limit - 3) + '...'
                    };
                }
                return {
                    default: false,
                    snippet: text
                };
            }
            StencilBooter.log('JSON parse error (I:gS)');
            return {
                default: true,
                snippet: 'Enter your own message here'
            };
        },

        /**
         * getSourceImage
         * 
         * @access  public
         * @return  ImageAccessor|undefined
         */
        getSourceImage: function() {
            return this._references.sourceImage;
        },

        /**
         * getSrc
         * 
         * Function intended to be used with views to output some image, even if
         * it's not yet fully uploaded to S3.
         * 
         * Returns the raw canvas data if the image hasn't yet finished
         * uploading. If it has, it checks to see if a width is defined. If none
         * is defined (eg. cases with legacy saved images), a url with a scaled
         * width of 800 pixels is returned. Or else, a url with the proper
         * scaled width is returned.
         * 
         * @see     https://stackoverflow.com/questions/23481210/resize-the-canvas-output-image-to-a-specific-size-width-height
         * @note    For these updates to work, have to test retina/non-retina in
         *          multiple browsers to ensure webp support, and detect proper
         *          default type (png/jpeg) for optimization.
         *          Also, ideal to cache the data so that Preview+Share isn't
         *          executing multiple toDataURL calls.
         * @access  public
         * @param   undefined|Object options
         * @return  String
         */
        getSrc: function(options) {
            if (
                this._data.uploaded.toInt() === 0
                || this.preloaded() === false
            ) {
                options = options || {};
                var srcs = this.get('srcs') || {},
                    key = JSON.stringify(options),
                    mime = this.getRecommendedExportMime(),
                    dataURL;
                if (srcs[key] !== undefined) {
                    return srcs[key];
                }
                if (Modernizr.webp !== false) {
                    mime = 'image/webp';
                }
                var canvas = Canvases.Preview.getElement()[0];
                if (options.clip === true) {
                    dataURL = canvas.centerAndClip(
                        options.dimensions.width,
                        options.dimensions.height
                    ).toDataURL(mime);
                } else {
                    dataURL = canvas.toDataURL(mime);
                }
                srcs[key] = dataURL;
                this.set('srcs', srcs);
                return dataURL;
            }
            var width = this._data.width.toInt();
            if (width === 0) {
                return this.url('scale', {
                    width: 800
                });
            }
            return this.url('scale', {
                width: width
            });
        },

        /**
         * getTheNounProjectIcons
         * 
         * @access  public
         * @return  Array
         */
        getTheNounProjectIcons: function() {
            var layers = this._imageDocument.getTheNounProjectVectorImageLayers(),
                icons = [],
                index;
            for (index in layers) {
                icons.push(layers[index].getProperty('image'));
            }
            return icons;
        },

        /**
         * isLocked
         * 
         * @access  public
         * @return  Boolean
         */
        isLocked: function() {
            return this._data.settings.locked.toInt() === 1;
        },

        /**
         * isVerifoneFrame
         * 
         * @access  public
         * @return  Boolean
         */
        isVerifoneFrame: function() {
            var frameKey = this._data.frame,
                verifoneFrameKeys = [
                    'frm-partner.verifone-carbon8',
                    'frm-partner.verifone-vx'
                ];
            return ArrayUtils.contains(frameKey, verifoneFrameKeys) === true;
        },

        /**
         * json
         * 
         * Returns a default canvas JSON object (based on guest/user status), or
         * else the JSON object for the image object if it's <json> value is not
         * an empty string.
         * 
         * @access  public
         * @return  Object
         */
        json: function() {
            if (this._data.settings.json === '') {
                if (User.exists() === false) {
                    return Config.default('canvases').guest;
                }
                return Config.default('canvases').user;
            }
            if (JSONUtils.valid(this._data.settings.json) === false) {
                this._data.settings.json = '';
                return this.json();
            }
            var parsed = JSON.parse(this._data.settings.json);
            if (parsed.layers === undefined) {
                this._data.settings.json = '';
                return this.json();
            }
            if (parsed.layers.length === 0) {
                this._data.settings.json = '';
                return this.json();
            }
            return parsed;
        },

        /**
         * loadDependentFonts
         * 
         * Loads any fonts that are dependents of this image. The reason they
         * might not already be loaded is because they might have been deleted
         * by the user, or else they were used in a featured template.
         * 
         * It's important that I set the hasRegularAccess property to 0 so that
         * the rest of the font flow knows that this font is not traditionally
         * accessible by the account.
         * 
         * Also, I set the label to the parsedFamilyName property, incase the
         * user who originally uploaded or imported the font changed it's name
         * at one point. It makes more sense to use whatever was parsed at the
         * time of conversion / upload / importing, rather than whatever they
         * might have changed it to.
         * 
         * @access  public
         * @return  void
         */
        loadDependentFonts: function() {
            var fontObjects = this._data.fonts,
                index, fontObject,
                collection = Stencil.account().collection('fonts'),
                model = Stencil.getModel('Font'),
                accessors;
            for (index in fontObjects) {
                fontObject = fontObjects[index];
                if (collection.find(fontObject.key) !== false) {
                    continue;
                }
                fontObject.hasRegularAccess = 0;
                fontObject.label = fontObject.parsedFamilyName;
                accessors = collection.map([fontObject]);
                Toolbars.getToolbar('text').getFontsDropdown().addFont(accessors[0], true);
            }
        },

        /**
         * markAsUploaded
         * 
         * @access  public
         * @return  void
         */
        // markAsUploaded: function() {
        //     this._model.markAsUploaded(this._data.key);
        // },

        /**
         * markConfigurationAsSaved
         * 
         * Calling this method converts the configuration for the image to json,
         * and stores it locally. The intention of calling this method should be
         * to prevent any future PATCH calls against the record from being
         * triggered by setting the last-saved configuration local varaible to
         * exactly what is set for the image.
         * 
         * @access  public
         * @return  void
         */
        markConfigurationAsSaved: function() {
            var configuration = this.getConfiguration();
            this._lastSavedConfigurationString = JSON.stringify(configuration);
        },

        /**
         * normalize
         * 
         * @access  public
         * @return  void
         */
        normalize: function() {
//             Stencil.alert('import.normalize.disabled');
// return;
            var path = '/app/images/' + (this._data.key) + '/normalize?clean',
                normalized = Normalizer.image(this.setting('json'));
            Stencil.navigate(path);
            this.set('settings.json', normalized);
            this._model.normalize(this._data.key);
        },

        /**
         * owned
         * 
         * Checks whether the logged in account owns the image, which is used in
         * determining whether a saved-draft should have the save button enabled
         * upon app-init. This is because it's possible for a user to load a
         * template, but not save or interact with it. In that case, the save
         * button should be available to the user.
         * 
         * @access  public
         * @return  Boolean
         */
        owned: function() {
            return this._data.accountId.toInt() === Stencil.account().get('id').toInt();
        },

        /**
         * preload
         * 
         * Contains preloading logic for images that either don't have their
         * width defined (eg. legacy images), or else do, and should have the
         * exact scaled-width version preloaded.
         * 
         * @access  public
         * @param   Function success
         * @param   Function error
         * @return  void
         */
        preload: function(success, error) {
            var urls = [
                this.url('thumb')
            ];

            /**
             * Assumes that if no width is defined, something went wrong with
             * syncing call. In that case, the 800px wide image will likely be
             * used in the getSrc call above. So preload that resource.
             */
            if (this._data.width.toInt() === 0) {
                urls.push(this.url('scale', {
                    width: 800
                }));
            }
            /**
             * Scale image to the exact width, which via Cloudinary, will also
             * (conveniently) take care of compression.
             */
            else {
                urls.push(this.url('scale', {
                    width: this._data.width.toInt()
                }));
            }

            // Function context scoping and calls
            success = success || function(){};
            error = error || function(){};
            Images.preload(urls, success.proxy(this), error.proxy(this));
        },

        /**
         * preloaded
         * 
         * @access  public
         * @return  Boolean
         */
        preloaded: function() {
            if (this._data.preloaded === undefined) {
                return false;
            }
            return this._data.preloaded.toInt() === 1;
        },

        /**
         * removeSourceImage
         * 
         * @access  public
         * @return  void
         */
        removeSourceImage: function() {
            this.push('sourceImageId', 0);
            // delete this._data.sourceImageId;
            delete this._references.sourceImage;
        },

        /**
         * saveConfiguration
         * 
         * Note that the deleted check here is because if the image has been
         * deleted in the database, any PATCH calls against it will naturally
         * fail. Not sure at the moment how or when this might happen, but
         * likely can't hurt.
         * 
         * Just (2017-08-03) thought of how this could happen. A user adds a
         * vector resource (not asset) to the canvas, and save action happens.
         * Because it's a vector, we don't need to wait for a high resolution
         * asset to be loaded (eg. for bitmaps), so we can create the image
         * right away. If the user then deletes the image, before the vector
         * resource has been properly imported via the /api/resource:id/save
         * call, and then the request comes back, a this.saveConfiguration call
         * would be made (since the image property for the layer would have been
         * changed). So.. good call, previous-Oliver ;-)
         * 
         * @access  public
         * @return  void
         */
        saveConfiguration: function() {
            if (this.deleted() === false) {
                var configuration = this.getConfiguration(),
                    configurationString = JSON.stringify(configuration);
                if (
                    configurationString !== this._lastSavedConfigurationString
                ) {
                    var columns = [
                        'frame',
                        'resourceGatewaySave',
                        'sourceImageId',
                        'width',
                        'height',
                        'settings.json',
                        'settings.watermarks'
                    ];
                    this.save(columns, {
                        error: function(response) {
                            var error = Stencil.extractError(response);
                            if (error.validator[1] === 'notUploaded') {
                                Stencil.alert('image.uploaded.already');
                                Stencil.kill();
                                return false;
                            }
                            if (error.validator[1] === 'validRecordByKey') {
                                Stencil.alert('image.uploaded.deleted');
                                Stencil.kill();
                                return false;
                            }
                            return true;
                        }
                    });
                    this.set({
                        'resourceGatewaySave': '0'
                    });
                    this.markConfigurationAsSaved();
                }
            }
        },

        /**
         * select
         * 
         * @note    There is an exception whereby if the image (or template)
         *          being selected is a legacy image that has not yet been
         *          normalized, the user first see's the LegacyImageNormalize
         *          modal. After confirming the modal, the image is then
         *          loaded into the canvas. Unfortunately, the four params are
         *          lost in this process (because they're not being sent along
         *          to the LegacyImageNormalize modal, partially because the flow
         *          for this is a bit cumbersome, including a controller action
         *          and Router route). See LegacyImageNormalize.js to see the
         *          default values being passed into this method in that case.
         * @access  public
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        select: function(method, locked, options) {
            ChangeHistory.setOperationType('image // loaded');
            this.loadDependentFonts();
            this._super(method, locked, options);
        },

        /**
         * setConfiguration
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the configuration associated with the image. A delay is set here to
         * prevent too-many PATCH calls against the record, since this method is
         * called frequently.
         * 
         * This method is also responsible for registering objects within the
         * change history architecture. The delay value for how often objects
         * are registered there is different than the saveDelay used to prevent
         * excessive PATCH calls.
         * 
         * @access  public
         * @return  void
         */
        setConfiguration: function() {
            var configuration = this.getConfiguration(),
                delay = Stencil.getSaveDelay('image');
            this.set({
                'frame': configuration.frame,
                'sourceImageId': configuration.sourceImageId.toInt(),
                'width': configuration.width.toInt(),
                'height': configuration.height.toInt(),
                'settings.json': configuration.settings.json,
                'settings.watermarks': configuration.settings.watermarks
            });
            this.clearSaveConfigurationTimeout();
            this._saveConfigurationTimeout = this.saveConfiguration.delay(
                delay,
                this
            );
        },

        /**
         * setImageDocument
         * 
         * @access  public
         * @param   ImageDocument imageDocument
         * @return  void
         */
        setImageDocument: function(imageDocument) {
            this._imageDocument = imageDocument;
        },

        /**
         * setToImage
         * 
         * Swaps out the frame and settings.json values, and triggers a sync to
         * ensure that after the delay, a call is made to save the image.
         * 
         * @access  public
         * @param   ImageAccessor image
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        setToImage: function(image, method, locked, options) {

            /**
             * Precaution for redo / undo
             * 
             * Only set the source image if the image being set and the current
             * one are not the same.
             * 
             * @todo!!! Maybe the property should just be exempted, rather than
             *          set to 0? Seems a bit funky to set this to 0...
             */
            var sourceImageId = this.get('id').toInt();
            if (method === 'redo' || method === 'undo') {
                sourceImageId = image.get('sourceImageId').toInt();
            }

            // 
            this.set({
                'frame': image.get('frame'),
                'width': image.get('width').toInt(),
                'height': image.get('height').toInt(),
                'sourceImageId': sourceImageId.toInt(),
                'settings.json': image.setting('json'),
                'settings.watermarks': image.setting('watermarks')
            });

            /**
             * Precaution for redo / undo
             * 
             * Only set the source image if the image that being set is _not_
             * the same one, since redo / undo functionality uses this approach.
             * When the source image is set to itself, it causes issues with
             * the Footer view, since it thinks an image is available to be
             * downloaded (since that's determined by checking the source
             * image).
             */
            if (method === 'redo' || method === 'undo') {
                this._setSourceImage(image.getSourceImage());
            } else {
                this._setSourceImage(image);
            }
            // this.set({
            //     'settings.json': image.setting('json'),
            //     'frame': Frame.get('key')
            // });
            // this.save(['frame', 'settings.json']);
        },

        /**
         * share
         * 
         * Redirects the user to the share page / experience, based on the user
         * account's shareNetwork setting, which tracks the last network they
         * tried sharing to.
         * 
         * The exception here is that if the frame for the image is a Verifone
         * frame _always_ go to that tab. If it's not, but the Verifone tab was
         * the one last selected, default back to Facebook.
         * 
         * @access  public
         * @return  void
         */
        share: function() {
            if (Account.delinquent() === true) {
                Stencil.navigate('/app/delinquent?clean=1');
            } else {
                var network = Stencil.account().userAccount().setting(
                        'shareNetwork'
                    ),
                    path = this.getSharePath(network);
                if (this.isVerifoneFrame() === true) {
                    path = this.getSharePath('verifone');
                }
                Stencil.navigate(path);
                // this.triggerHandler('share');
            }
        },

        /**
         * template
         * 
         * @note    Notice how I'm removing the template and then re-adding right
         *          after the data has been swapped. This is to ensure the
         *          correct key is being stored (since before it's a temporary
         *          key, and after it's the permanent one).
         * @access  public
         * @return  void
         */
        template: function() {
            var category = Categories.account.list('templates'),
                key = category.get('key'),
                collection = App.getEditor().getArea('templates').getChild('categories').getChild(key).getCollection(),
                templates = collection.map({
                    class: 'template',
                    key: 'ctgX' + DataUtils.getRandomString(8).toLowerCase(),
                    image: this._data
                }, false);
            category.features.add.apply(category, [templates[0]]);
            this._model.template(this._data.key, function(data) {
                category.features.remove.apply(category, [templates[0]]);
                templates[0].swap(data.object);
                category.features.add.apply(category, [templates[0]]);
            });
            this.triggerHandler('template');
            this.once({
                'update/uploaded': function(event) {
                    var category = Categories.account.list('templates');
                    templates[0].getModel().feature(
                        templates[0].get('key'),
                        {
                            category: category.get('key')
                        }
                    );
                }
            });
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = Categories.account.favorites('images');
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('images').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelUnfeatureCall = function() {
                    this._model.unfeature(
                        this._data.key,
                        {
                            category: category.get('key')
                        }
                    );
                };
                if (this._syncedToAnyCategory() === true
                ) {
                    modelUnfeatureCall.apply(this);
                } else {
                    this.once({
                        'update/uploaded': function(event) {
                            modelUnfeatureCall.apply(this);
                        }
                    });
                }
            }
            this.triggerHandler('unfeature', [category]);
            features.remove(this);
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with Buffer + Pinterest sharing
         * - Scaled image url, used in Share modal to show a maximum resolution
         *   image (since the full dimension is a waste of bandwidth)
         * - Thumb image url, used in images and templates tab
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options
         * @return  String|false
         */
        url: function(type, options) {
            var key, proxy = 'stencil';
            if (type === 'original') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'shareAsImage';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                return Images.thumb(key, {
                    proxy: proxy,
                    type: 'original'
                });
            } else if (type === 'scale') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'shareAsImage';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                return Images.thumb(key, {
                    proxy: proxy,
                    type: 'scale',
                    width: options.width
                });
            } else if (type === 'thumb') {
                key = this._data.key;
                if (
                    this._data.legacy.toInt() === 1
                    && this._data.legacyImported.toInt() === 0
                ) {
                    key = this._data.legacyFilename;
                    proxy = 'shareAsImage';
                    if (this._data.legacyHasHighDef.toInt() === 1) {
                        key = 'hd.' + (key);
                    }
                }
                // if (
                //     this._data.legacy.toInt() === 1
                //     && this._data.legacyImported.toInt() === 1
                // ) {
                //     key = '0.' + (key);
                // }
                return Images.thumb(key, {
                    proxy: proxy,
                    type: 'thumb'
                });
            }
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor'], function() {

    /**
     * MediaAccessor
     * 
     * @extends Accessor
     */
    window.MediaAccessor = Accessor.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'MediaAccessor')
         */
        _string: 'MediaAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * getFrameUrl
         * 
         * Returns the frame-specific url. Used in preloading so that when an
         * image is uploaded, it'll be available as soon as it's been processed.
         * Not perfect, since the getFrameUrl method in Images assumes a lot.
         * See that class / function for more documentation.
         * 
         * @access  public
         * @param   CanvasView canvas
         * @return  String
         */
        getFrameUrl: function(canvas) {
            return Images.getFrameUrl(this._data.key, canvas);
        },

        /**
         * select
         * 
         * @access  public
         * @param   String method Possible values:
         *          - click
         *          - drop
         *          - undo
         *          - redo
         * @param   Boolean locked Used to lock certain assets for free users
         * @param   Object options Used to pass along x/y coordinates for a drag
         *          and in some cases the destination for a MediaAccessor object
         *          (eg. foreground or background).
         * @return  void
         */
        select: function(method, locked, options) {
            this.triggerHandler(
                'select',
                [method, locked === true, options]
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'PromoModel'], function() {

    /**
     * PromoAccessor
     * 
     * @extends Accessor
     */
    window.PromoAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Promo'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoAccessor')
         */
        _string: 'PromoAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupPromoSet();
        },

        /**
         * _setupPromoSet
         * 
         * @access  protected
         * @return  void
         */
        _setupPromoSet: function() {
            var model = Stencil.getModel('PromoSet');
            this._references.promoSet = model.setAccessor(this._data.promoSet);
        },

        /**
         * promoSet
         * 
         * @access  public
         * @return  PromoSetAccessor
         */
        promoSet: function() {
            return this._references.promoSet;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'PromoSetModel'], function() {

    /**
     * PromoSetAccessor
     * 
     * @extends Accessor
     */
    window.PromoSetAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PromoSet'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoSetAccessor')
         */
        _string: 'PromoSetAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourceAccessor'], function() {

    /**
     * QuoteResourceAccessor
     * 
     * @extends ResourceAccessor
     */
    window.QuoteResourceAccessor = ResourceAccessor.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteResourceAccessor')
         */
        _string: 'QuoteResourceAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        },

        /**
         * _addQuoteTextLayers
         * 
         * @access  protected
         * @return  void
         */
        _addQuoteTextLayers: function() {
            var quotation = this._data.quotation,
                author = this._data.author,
                canvas = Canvases.Preview,
                layers = {
                    author: canvas.addTextLayer({
                        align: 'center',
                        fontFamily: 'Leckerli One',
                        fontSize: 35,
                        text: author,
                        top: 70,
                        width: 90
                    }),
                    quotation: canvas.addTextLayer({
                        align: 'center',
                        fontFamily: Stencil.account().getDefaultFontFamily(),
                        fontSize: 50,
                        text: quotation,
                        top: 45,
                        width: 90
                    })
                },
                drawings = {
                    author: layers.author.getDrawing(),
                    quotation: layers.quotation.getDrawing()
                };
            layers.author.setChangeOperationType('quote:added');
            drawings.author.once({
                'draw': function(event) {
                    this.trim();
                    this.repositionRelativeTo(drawings.quotation);
                    this.animate();
                    drawings.quotation.animate();
                    drawings.quotation.select();
                    // this._cotton.trigger('changed');
                    layers.author.triggerHandler('refresh/dimensions');
                }
            });
            drawings.quotation.once({
                'draw': function(event) {
                    drawings.author.draw();
                }
            });
            drawings.quotation.draw();
        },

        /**
         * getDisplayableQuotation
         * 
         * @see     http://stackoverflow.com/questions/784539/how-do-i-replace-all-line-breaks-in-a-string-with-br-tags
         * @access  public
         * @return  String
         */
        getDisplayableQuotation: function() {
            return this._data.quotation.trimToLength(200).replace(
                /(?:\r\n|\r|\n)/g,
                '<br />'
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'ResourceModel'], function() {

    /**
     * ResourceAccessor
     * 
     * @extends MediaAccessor
     */
    window.ResourceAccessor = MediaAccessor.extend({

        /**
         * _asset
         * 
         * Possible reference to the asset that the resource was saved to.
         * 
         * @access  protected
         * @var     AssetAccessor (default: false)
         */
        _asset: false,

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Resource'),

        /**
         * _saved
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _saved: false,

        /**
         * _saving
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _saving: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceAccessor')
         */
        _string: 'ResourceAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'feature': function(event, category) {
                    // if (this._asset === false) {
                        Track.event('Resource featured', {
                            _key: this._data.key
                        });
                    // }
                },
                'unfeature': function(event, category) {
                    // if (this._asset === false) {
                        Track.event('Resource unfeatured', {
                            _key: this._data.key
                        });
                    // }
                }
            });
            this.on({
                'select': function(event, method, locked, options) {
                    // if (this._data.filesize <= 20 * 1024 * 1024) {
                        if (this._data.platform === 'TheNounProject') {
                            this._addVectorLayer(locked, this._data.color.toInt() === 1);
                        } else if (this._data.platform === 'Icons8') {
                            this._addVectorLayer(locked, this._data.color.toInt() === 1);
                        } else if (this._data.platform === 'VectorSearch') {
                            this._addVectorLayer(locked, this._data.color.toInt() === 1);
                        } else if (this._data.platform === 'Pixabay') {
                            if (options.destination === 'foreground') {
                                Account.onboard('foregroundSelected');
                                this.addForegroundBitmapImageLayer(locked);
                            } else {
                                Account.onboard('backgroundSelected');
                                if (options.autoSelect !== undefined) {
                                    this.setBackgroundBitmapImageLayer(locked, {
                                        autoSelect: options.autoSelect
                                    });
                                } else {
                                    this.setBackgroundBitmapImageLayer(locked);
                                }
                            }
                        } else if (this._data.platform === 'Pexels') {
                            if (options.destination === 'foreground') {
                                Account.onboard('foregroundSelected');
                                this.addForegroundBitmapImageLayer(locked);
                            } else {
                                Account.onboard('backgroundSelected');
                                if (options.autoSelect !== undefined) {
                                    this.setBackgroundBitmapImageLayer(locked, {
                                        autoSelect: options.autoSelect
                                    });
                                } else {
                                    this.setBackgroundBitmapImageLayer(locked);
                                }
                            }
                        } else if (this._data.platform === 'Unsplash') {
                            if (options.destination === 'foreground') {
                                Account.onboard('foregroundSelected');
                                this.addForegroundBitmapImageLayer(locked);
                            } else {
                                Account.onboard('backgroundSelected');
                                if (options.autoSelect !== undefined) {
                                    this.setBackgroundBitmapImageLayer(locked, {
                                        autoSelect: options.autoSelect
                                    });
                                } else {
                                    this.setBackgroundBitmapImageLayer(locked);
                                }
                            }
                        } else if (this._data.platform === 'AlgoliaQuote') {
                            this._addQuoteTextLayers();
                        }
                    // } else {
                    //     Stencil.alert('resource.filesize.excessive');
                    // }
                }
            });
        },

        /**
         * _addVectorLayer
         * 
         * @todo    After saving is complete, preload the asset at the new url
         *          via a crossDomain ajax call to have the preflight request
         *          fire as well
         * @access  protected
         * @param   Boolean locked
         * @param   Boolean color
         * @return  void
         */
        _addVectorLayer: function(locked, color) {
            var canvas = Canvases.Preview,
                layer = canvas.addVectorImageLayer({
                    image: this._data.key
                }, color),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw(true);
        },

        /**
         * _incrementResourceOperations
         * 
         * Helper method to increment the general and specific
         * operation-counters to ensure that once the maximum is reached, the
         * user is blocked until previous operations finish.
         * 
         * This helper was required because of how the save method works.
         * Namely, it allows multiple calls to it, such that when the resource
         * has already been saved, the save-listener is triggered right away.
         * 
         * While that was the initial intention, it is nice having this in one
         * place regardless.
         * 
         * @access  protected
         * @param   String type
         * @return  void
         */
        _incrementResourceOperations: function(type) {
            var lookup = {
                    feature: 'parallelResourceFeatures',
                    save: 'parallelResourceSaves'
                },
                parallelResourceOperations = Stencil.get('parallelResourceOperations'),
                parallelResourceOperationsByType = Stencil.get(lookup[type]);
            ++parallelResourceOperations;
            Stencil.set('parallelResourceOperations', parallelResourceOperations);
            ++parallelResourceOperationsByType;
            Stencil.set(lookup[type], parallelResourceOperationsByType);
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @note    The reason adding a foreground bitmap image layer doesn't
         *          require setting up or listening for a gateway save is because
         *          those calls are initiated in the constructor for the layer.
         *          Since calling this method will *always* result in a new
         *          ForegroundBitmapImageLayer layer being created, nothing needs
         *          to be done right after.
         *          This contrasts the setBackgroundBitmapImageLayer method,
         *          since that method doesn't actually create a new
         *          BackgroundBitmapImageLayer. Rather, it sets the image to it,
         *          since that layer always exists. Because of this, multiple
         *          images should be able to trigger a gateway save, since a user
         *          could hypothetically choose an image, wait 30 seconds, and
         *          then change it. When they do that, because of the how the
         *          events are structured (namely, using the <once> event
         *          listener), a second call needs to be made to ensure the
         *          listeners are ready.
         * @note    Defaults to auto selecting the drawing
         * @note    Defaults to auto animating the drawing
         * @access  public
         * @param   Boolean locked
         * @param   Object options (optional)
         * @return  ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(locked, options) {
            options = options || {};
            var canvas = Canvases.Preview,
                layer = canvas.addForegroundBitmapImageLayer({
                    image: this._data.key
                }),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    if (options.autoSelect !== false) {
                        this.select();
                    }
                    if (options.animate !== false) {
                        drawing.animate();
                    }
                }
            });
            drawing.draw();
            return layer;
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = Categories.account.favorites(areaType);
            this.feature(category);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        feature: function(category) {
            var check = this.validate.feature.apply(this, [category]);
            if (check.valid === false) {
                check.callback();
            } else {
                this._incrementResourceOperations('feature');
                var area = 'photos';
                if (category.get('graphics').toInt() === 1) {
                    area = 'graphics';
                } else if (category.get('quotes').toInt() === 1) {
                    area = 'quotes';
                }
                if (ArrayUtils.contains(category, Categories.global.all()) === true) {
                    Stencil.globalFeatures.add(this);
                }
                category.features.add.apply(category, [this]);
                var key = category.get('key'),
                    features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection(),
                    _this = this;
                this._model.feature(
                    this._data.key,
                    {
                        category: category.get('key'),
                        collections: this._data.collections || [],
                        color: this._data.color.toInt() === 1 ? 1 : 0,
                        package: this._data.package,
                        tags: this._data.tags,
                        uploader: this._data.uploader || {},
                        urls: this._data.urls
                    },
                    /**
                     * (anonymous)
                     * 
                     * Passes in a data object representing an asset record.
                     * 
                     * @access  private
                     * @param   Object data
                     * @return  void
                     */
                    function(data) {
                        if (data.object.uploaded.toInt() === 0) {
                            var code = 'r262',
                                reference = 'resource';
                            Stencil.error(code, reference);
                        } else {
                            var model = Stencil.getModel('Asset'),
                                accessor = model.setAccessor(data.object);
                            _this._asset = accessor;
                            _this._saved = true;
                            accessor.preload();
                            // accessor.preload(function() {
                            //     accessor.triggerHandler('preload');
                            // });
                            Stencil.triggerHandler('resource/feature/complete', [accessor]);
                            Stencil.triggerHandler('resource/operation/complete', ['feature', accessor]);
                        }
                    }
                );
                this.triggerHandler('feature', [category]);
                var asset = this.getAsset();
                if (asset !== false) {
                    asset.triggerHandler('feature', [category]);
                }
                features.add(this, false);
            }
        },

        /**
         * getAsset
         * 
         * @access  public
         * @return  false|AssetAccessor
         */
        getAsset: function() {
            var accessors = Stencil.get('accessors'),
                index;
            for (index in accessors) {
                if (accessors[index].reference('resource') === this) {
                    return accessors[index];
                }
            }
            return false;
        },

        /**
         * getPlacementDestination
         * 
         * @access  public
         * @return  String
         */
        getPlacementDestination: function() {
            if (
                this.get('platform') === 'TheNounProject'
                || this.get('platform') === 'Icons8'
                || this.get('platform') === 'VectorSearch'
            ) {
                return 'foreground';
            }
            return 'background';
        },

        /**
         * owned
         * 
         * @access  public
         * @return  false
         */
        owned: function() {
            return false;
        },

        /**
         * save
         * 
         * @todo!   Look into removing save-event and having listeners within the
         *          app look to resource/save/complete event.
         * @todo    This is a bad name; can get confused with saving and
         *          accessor's data (but maybe, that's okay, since it's a
         *          resource and it doesn't have any data other than the binary
         *          image itself?)
         * @note    Sometimes in the console it'll seem like there's a lag
         *          between when the /save ajax call returns, and when the
         *          callback is fired. This is because the newly saved resource
         *          is preloaded before the callback is fired.
         * @note    I cannot recall, but I believe I delayed things until after
         *          preload because when a save happens, it is often within the
         *          context of swapping out an image in the canvas. So I wanted
         *          to only swap it out once a preload action has occured (to
         *          prevent any flickering while the resource is requested).
         * @access  public
         * @return  void
         */
        save: function() {
            var check = this.validate.save.apply(this);
            if (check.valid === false) {
                check.callback();
            } else {
                if (this._saving === false) {
                    if (this._saved === true) {
                        this.triggerHandler('save', [this._asset]);
                    } else {
                        this._incrementResourceOperations('save');
                        var _this = this;
                        this._saving = true;
                        this._model.save(
                            this._data.key,
                            {
                                collections: this._data.collections || [],
                                color: this._data.color.toInt() === 1 ? 1 : 0,
                                // tags: this._data.tags || [],
                                tags: this._data.tags,
                                uploader: this._data.uploader || {},
                                urls: this._data.urls
                            },
                            /**
                             * (anonymous)
                             * 
                             * Passes in a data object representing an asset record.
                             * 
                             * @access  private
                             * @param   Object data
                             * @return  void
                             */
                            function(data) {
                                if (data.object.uploaded.toInt() === 0) {
                                    var code = 'r314',
                                        reference = 'resource';
                                    Stencil.error(code, reference);
                                } else {
                                    var model = Stencil.getModel('Asset'),
                                        accessor = model.setAccessor(data.object);
                                    _this._asset = accessor;
                                    accessor.preload(function() {
                                        _this._saved = true;
                                        _this._saving = false;
                                        _this.triggerHandler('save', [accessor]);
                                        // _this.triggerHandler('preload');
                                        Stencil.triggerHandler('resource/save/complete', [accessor]);
                                        Stencil.triggerHandler('resource/operation/complete', ['save', accessor]);
                                    });
                                }
                            }
                        );
                    }
                }
            }
        },

        /**
         * saved
         * 
         * @access  public
         * @return  Boolean
         */
        saved: function() {
            return this._saved;
        },

        /**
         * setBackgroundBitmapImageLayer
         * 
         * @note    Defaults to not auto selecting the drawing
         * @access  public
         * @param   Boolean locked
         * @param   undefined|Object options (optional)
         * @return  BackgroundBitmapImageLayer
         */
        setBackgroundBitmapImageLayer: function(locked, options) {
            options = options || {};
            var canvas = Canvases.Preview,
                layer = canvas.getBackgroundBitmapImageLayer(),
                drawing = layer.getDrawing(),
                key = this._data.key;
            layer.setChangeOperationType('image:changed');
            layer.setImage(key);
            layer.setProperty('locked', locked);
            layer.listenForGatewaySave();
            layer.setupGatewaySave();
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access  private
                 * @return  void
                 */
                'refresh': function(event) {
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                    if (options.autoSelect === true) {
                        this.select();
                    }
                }
            });
            drawing.reload();
            return layer;
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @note    Since it's possible that the features collection actually
         *          contains the AssetAccessor for this ResourceAccessor, I
         *          try and remove that as well, incase that's the one that's
         *          being stored in the collection.
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        unfeature: function(category) {
            var area = 'photos';
            if (category.get('graphics').toInt() === 1) {
                area = 'graphics';
            } else if (category.get('quotes').toInt() === 1) {
                area = 'quotes';
            }
            if (ArrayUtils.contains(category, Categories.global.all()) === true) {
                if (this.globalCategoriesFeaturedIn().length === 1) {
                    Stencil.globalFeatures.remove(this);
                }
            }
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea(area).getChild('categories').getChild(key).getCollection();
            this._model.unfeature(
                this._data.key,
                {
                    category: category.get('key')
                },
                /**
                 * (anonymous)
                 * 
                 * Passes in a data object representing an asset record. This is
                 * important because I want to ensure that after an unfeature
                 * response comes back, I can properly remove the associated
                 * AssetAccessor from the associated CategoryAccessor's
                 * syncedFeatures array.
                 * 
                 * So to do that, I set the accessor here (which ought always to
                 * be an asset-record), to ensure it's available by the time
                 * model.unfeature gets around to needing it.
                 * 
                 * The syncedFeatures array needs to be kept in sync to ensure
                 * sorting works properly for categories.
                 * 
                 * @access  private
                 * @param   Object data
                 * @return  void
                 */
                function(data) {
                    var model = Stencil.getModel('Asset'),
                        accessor = model.setAccessor(data.object);
                }
            );
            this.triggerHandler('unfeature', [category]);
            var asset = this.getAsset();
            if (asset !== false) {
                asset.triggerHandler('unfeature', [category]);
            }
            features.remove(this);
            if (asset !== false) {
                features.remove(asset);
            }
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = Categories.account.favorites(areaType);
            this.unfeature(category);
        },

        /**
         * url
         * 
         * Provides URLs (not through Cloudinary) for resources to match the
         * following cases:
         * - SVG image url (eg. The Noun Project)
         * - Preview image url, used to show both Pixabay and The Noun Project
         *   thumbs
         * - Small image urls, currently only used to draw Pixabay resources
         *   into the canvas so that the resolution is good enough until the
         *   image gets fully downloaded and a higher-resolution is swapped in
         * 
         * @access  public
         * @param   String type
         * @return  String|false
         */
        url: function(type) {
            if (type === 'svg') {
                return this._data.urls.svg;
            }
            if (type === 'thumb') {
                return this._data.urls.preview;
            }
            if (type === 'small') {
                return this._data.urls.small;
            }
            return false;
        },

        /**
         * validate
         * 
         * @access  public
         * @var     Object
         */
        validate: {

            /**
             * feature
             * 
             * @access  public
             * @param   CategoryAccessor category
             * @return  Object
             */
            feature: function(category) {
                var check = this.validate.operation.apply(this, ['feature', [category]]);
                if (check.valid === false) {
                    return check;
                }
                var parallelResourceFeatures = Stencil.get('parallelResourceFeatures'),
                    max = Config.default('maxParallelResourceFeatures'),
                    reattemptMinDelay = 2000;
                if (parallelResourceFeatures === undefined) {
                    parallelResourceFeatures = 0;
                    Stencil.set('parallelResourceFeatures', parallelResourceFeatures);
                }
                if (parallelResourceFeatures >= max) {
                    var _this = this;
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('resource.features.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/feature/complete': function(event, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this.feature(category);
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * operation
             * 
             * @access  public
             * @param   String type This is the type of operation that is being
             *          validated (eg. feature or save). It is important that
             *          this variable is different than the second argument in
             *          the resource/operation/complete-event. It caused a bug
             *          whereby the completed-operation was getting reattempted
             *          because the type-param was named "operation" as well.
             *          Yikes.
             * @param   Array args
             * @return  Object
             */
            operation: function(type, args) {
                var parallelResourceOperations = Stencil.get('parallelResourceOperations'),
                    max = Config.default('maxParallelResourceOperations'),
                    _this = this,
                    reattemptMinDelay = 2000;
                if (parallelResourceOperations === undefined) {
                    parallelResourceOperations = 0;
                    Stencil.set('parallelResourceOperations', parallelResourceOperations);
                }
                if (parallelResourceOperations >= max) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('resource.operations.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/operation/complete': function(event, operation, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this[type].apply(_this, args);
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * save
             * 
             * @access  public
             * @return  Object
             */
            save: function() {
                var check = this.validate.operation.apply(this, ['save', []]);
                if (check.valid === false) {
                    return check;
                }
                var parallelResourceSaves = Stencil.get('parallelResourceSaves'),
                    max = Config.default('maxParallelResourceSaves'),
                    reattemptMinDelay = 2000;
                if (parallelResourceSaves === undefined) {
                    parallelResourceSaves = 0;
                    Stencil.set('parallelResourceSaves', parallelResourceSaves);
                }
                if (parallelResourceSaves >= max) {
                    var _this = this;
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('resource.saves.max'),
                                start = new Date();
                            App.getBusy().show(msg);
                            Stencil.once({
                                'resource/save/complete': function(event, asset) {
                                    (function() {
                                        App.getBusy().hide();
                                        _this.save();
                                    }).minDelay(start, reattemptMinDelay);
                                }
                            });
                        }
                    };
                }
                return {
                    valid: true
                };
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'ShareModel'], function() {

    /**
     * ShareAccessor
     * 
     * @extends Accessor
     */
    window.ShareAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Share'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareAccessor')
         */
        _string: 'ShareAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupConnection();
            this._setupImage();
        },

        /**
         * _setupConnection
         * 
         * @access  protected
         * @return  void
         */
        _setupConnection: function() {
            var model = Stencil.getModel('Connection');
            this._references.connection = model.setAccessor(
                this._data.connection
            );
        },

        /**
         * _setupImage
         * 
         * @access  protected
         * @return  void
         */
        _setupImage: function() {
            var model = Stencil.getModel('Image');
            this._references.image = model.setAccessor(this._data.image);
        },

        /**
         * connection
         * 
         * @access  public
         * @return  ConnectionAccessor
         */
        connection: function() {
            return this._references.connection;
        },

        /**
         * getPath
         * 
         * Returns the path the user should be sent to after a successful share.
         * Note that while the network-parameter being passed is not currently
         * (at the time of documentation) being used within the
         * application-logic, it is being used by Google Analytics for
         * goal-conversion-tracking.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var network = this.connection().get('network'),
                path = '/app/shares/' + (this._data.key) +  '/success' +
                    '?clean=1' +
                    '&network=' + (network);
            return path;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'TemplateModel'], function() {

    /**
     * TemplateAccessor
     * 
     * @extends Accessor
     */
    window.TemplateAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Template'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateAccessor')
         */
        _string: 'TemplateAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupImage();
            this.on({
                'delete': function(event) {
                    Track.event('Template deleted', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                },
                'feature': function(event, category) {
                    Track.event('Template featured', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Template unfeatured', {
                        _key: this._data.key,
                        _url: this._references.image.url('original')
                    });
                }
            });
        },

        /**
         * _setupImage
         * 
         * @access  protected
         * @return  void
         */
        _setupImage: function() {
            var model = Stencil.getModel('Image');
            this._references.image = model.setAccessor(this._data.image);
            this._references.image.set({template: true});
        },

        /**
         * _syncedToAnyCategory
         * 
         * @access  protected
         * @return  Boolean
         */
        _syncedToAnyCategory: function() {
            var categories = Categories.account.all({
                    templates: 1
                }),
                index;
            for (index in categories) {
                if (this._syncedToCategory(categories[index]) === true) {
                    return true;
                }
            }
            categories = Categories.global.all({
                templates: 1
            });
            for (index in categories) {
                if (this._syncedToCategory(categories[index]) === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _syncedToCategory
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        _syncedToCategory: function(category) {
            return category.syncedFeatures.contains.apply(category, [this]) === true;
        },

        /**
         * _syncedToFavoritesCategory
         * 
         * @todo!!!!This doesn't seem like it's being used. Why?
         * @access  protected
         * @return  Boolean
         */
        _syncedToFavoritesCategory: function() {
            var category = Categories.account.favorites('templates');
            return this._syncedToCategory(category);
        },

        /**
         * _syncedToGlobalCategory
         * 
         * @todo!!!!This doesn't seem like it's being used. Why?
         * @access  protected
         * @return  Boolean
         */
        _syncedToGlobalCategory: function() {
            var categories = Categories.global.type('templates'),
                index,
                category;
            for (index in categories) {
                category = categories[index];
                if (this._syncedToCategory(category) === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _syncedToListCategory
         * 
         * @todo!!!!This doesn't seem like it's being used. Why?
         * @access  protected
         * @return  Boolean
         */
        _syncedToListCategory: function() {
            var category = Categories.account.list('templates');
            return this._syncedToCategory(category);
        },

        /**
         * delete
         * 
         * @access  public
         * @param   Boolean autoHideBusyModal (default: true) Used to prevent
         *          busy modal from hiding when called by through multi-delete
         *          flow
         * @return  void
         */
        delete: function(autoHideBusyModal) {
            autoHideBusyModal = DataUtils.getDefaultValue(
                autoHideBusyModal,
                true
            );
            var image = this._references.image;
            if (image.get('uploaded').toInt() === 1) {
                if (autoHideBusyModal === true) {
                    App.getBusy().hide();
                }
                if (Stencil.account().draft().getSourceImage() === image) {
                    var previousSourceImageId = Stencil.account().draft().get('sourceImageId').toInt();
                    Stencil.account().draft().removeSourceImage();
                    Footer.setLastSavedImage(false);
                    Footer.reset();
                    ChangeHistory.syncSourceImageId(previousSourceImageId, 0);
                }
                this._super();
            } else {
                var msg = Stencil.getMessage('template.delete.pending');
                App.getBusy().show(msg);
                this.once({
                    'model/feature': this.delete.proxy(this)
                });
            }
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = Categories.account.favorites('templates');
            this.feature(category, performDataRequest);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            if (ArrayUtils.contains(category, Categories.global.all()) === true) {
                Stencil.globalFeatures.add(this);
            }
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('templates').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelFeatureCall = function() {
                    this._model.feature(
                        this._data.key,
                        {
                            category: category.get('key')
                        },
                        (function(data) {
                            this.triggerHandler('feature/complete');
                        }).proxy(this)
                    );
                };
                if (this._syncedToAnyCategory() === true) {
                    modelFeatureCall.apply(this);
                } else {
                    var _this = this;
                    this._references.image.once({
                        'update/uploaded': function(event) {
                            modelFeatureCall.apply(_this);
                        }
                    });
                }
            }
            this.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * getPreviewThumbImageUrl
         * 
         * @access  public
         * @return  String
         */
        getPreviewThumbImageUrl: function() {
            var url = this._references.image.url('scale', {
                width: 800
            });
            return url;
        },

        /**
         * owned
         * 
         * @access  public
         * @return  Boolean
         */
        owned: function() {
            return this._references.image.owned();
        },

        /**
         * pinned
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  Boolean
         */
        pinned: function(category) {
            return category.get('pinKey') === this._references.image.get('key');
        },

        /**
         * select
         * 
         * Triggers a template select unless the user isn't a Pro / admin user.
         * At the moment the below logic to hide the spinner is a big hack. Will
         * probably need to deal with this post-launch.
         * 
         * @todo!   Clean up: spinner removal should not be happening here.
         * @access  public
         * @param   String method
         * @param   Boolean locked
         * @param   Object options
         * @return  void
         */
        select: function(method, locked, options) {
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                ChangeHistory.setOperationType('template // loaded');
                this._references.image.select(method, locked, options);
            } else {
                // Stencil.navigate('/app/upgrade/pro/templates?clean=1');
                var path = '/app/templates/' +
                    this._data.key +
                    '/preview' +
                    '?clean=1'
                Stencil.navigate(path);
                (function() {
                    App.getElement().find('div.spinning div.spinner').remove();
                    App.getElement().find('div.spinning').removeClass('spinning');
                }).delay(10);
            }
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = Categories.account.favorites('templates');
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            if (ArrayUtils.contains(category, Categories.global.all()) === true) {
                Stencil.globalFeatures.remove(this);
            }
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('templates').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                var modelUnfeatureCall = function() {
                    this._model.unfeature(
                        this._data.key,
                        {
                            category: category.get('key')
                        }
                    );
                };
                if (this._syncedToAnyCategory() === true) {
                    modelUnfeatureCall.apply(this);
                } else {
                    var _this = this;
                    this._references.image.once({
                        'update/uploaded': function(event) {
                            modelUnfeatureCall.apply(_this);
                        }
                    });
                }
            }
            this.triggerHandler('unfeature', [category]);
            features.remove(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['MediaAccessor', 'UploadModel'], function() {

    /**
     * UploadAccessor
     * 
     * @events  upload/success
     *          upload/progress
     *          upload/error
     * @extends MediaAccessor
     */
    window.UploadAccessor = MediaAccessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Upload'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadAccessor')
         */
        _string: 'UploadAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this.on({
                'delete': function(event) {
                    Track.event('Upload deleted', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'feature': function(event, category) {
                    Track.event('Upload featured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                },
                'unfeature': function(event, category) {
                    Track.event('Upload unfeatured', {
                        _key: this._data.key,
                        _url: this.url('original')
                    });
                }
            });
            this.on({
                'select': function(event, method, locked, options) {
                    this.syncDimensions();
                    if (options.destination === 'foreground') {
                        Account.onboard('foregroundSelected');
                        this.addForegroundBitmapImageLayer(locked);
                    } else {
                        Account.onboard('backgroundSelected');
                        if (options.autoSelect !== undefined) {
                            this.setBackgroundBitmapImageLayer(locked, {
                                autoSelect: options.autoSelect
                            });
                        } else {
                            this.setBackgroundBitmapImageLayer(locked);
                        }
                    }
                }
            });
        },

        /**
         * _download
         * 
         * @access  protected
         * @return  void
         */
        _download: function() {
            var path = '/uploads/' + (this._data.key) + '/download',
                intervals = {},
                checks = {
                    cookie: function() {
                        if (
                            Cookies.get('upload.download.started') !== undefined
                        ) {
                            IntervalPool.clear(intervals.cookie);
                            Stencil.cookies.remove('upload.download.started');
                            App.getBusy().hide();
                            this.triggerHandler('download');
                            Stencil.set('redirecting', false);
                            Stencil.triggerHandler('redirect/complete');
                        }
                    },
                    connections: function() {
                        // if (UserAgent.is.safari() === false || XHRPool.length() === 0) {
                        if (XHRPool.length() === 0) {
                            IntervalPool.clear(intervals.connections);
                            Stencil.triggerHandler('redirect/start');
                            Stencil.set('redirecting', true);
                            if (
                                (
                                    UserAgent.extension() === true
                                    && UserAgent.hasCSP() === true
                                )
                                // || UserAgent.is.ipad() === true
                            ) {
                                window.open(path);
                            } else {
                                window.location.assign(path);
                            }
                            intervals.cookie = checks.cookie.interval(50, this);
                        }
                    }
                };
            intervals.connections = checks.connections.interval(50, this);
        },

        /**
         * _getResolution
         * 
         * @access  protected
         * @return  false|Number
         */
        _getResolution: function() {
            var width = this.get('width'),
                height = this.get('height');
            if (width.constructor !== Number && width.constructor !== String) {
                return false;
            }
            if (height.constructor !== Number && height.constructor !== String) {
                return false;
            }
            width = width.toInt();
            height = height.toInt();
            return width * height;
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @note    Defaults to auto selecting the drawing
         * @note    Defaults to auto animating the drawing
         * @access  public
         * @param   Boolean locked
         * @param   Object options (optional)
         * @return  ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(locked, options) {
            options = options || {};
            var canvas = Canvases.Preview,
                layer = canvas.addForegroundBitmapImageLayer({
                    image: this._data.key
                }),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            layer.setProperty('locked', locked);
            drawing.once({
                'draw': function(event) {
                    if (options.autoSelect !== false) {
                        this.select();
                    }
                    if (options.animate !== false) {
                        drawing.animate();
                    }
                }
            });
            drawing.draw();
            return layer;
        },

        /**
         * download
         * 
         * @access  public
         * @param   Boolean showBusyModal
         * @return  void
         */
        download: function(showBusyModal) {
            if (showBusyModal === true) {
                var msg = Stencil.getMessage('upload.download.pending');
                App.getBusy().show(msg);
            }
            this._download.apply(this);
        },

        /**
         * favorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        favorite: function(areaType, performDataRequest) {
            Account.favorites.add(this);
            var category = Categories.account.favorites('uploads');
            this.feature(category, performDataRequest);
        },

        /**
         * feature
         * 
         * @note    Handler needs to be fired before accessor is added to the
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        feature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.add.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('uploads').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.feature(
                    this._data.key,
                    {
                        category: category.get('key')
                    },
                    (function(data) {
                        this.triggerHandler('feature/complete');
                    }).proxy(this)
                );
            }
            this.triggerHandler('feature', [category]);
            features.add(this, false);
        },

        /**
         * getPlacementDestination
         * 
         * @access  public
         * @return  String
         */
        getPlacementDestination: function() {
            return 'foreground';
        },

        /**
         * owned
         * 
         * @access  public
         * @return  Boolean
         */
        owned: function() {
            return this._data.accountId.toInt() === Stencil.account().get('id').toInt();
        },

        /**
         * preload
         * 
         * Preloads alternate resource sizes, including:
         * - The original image, routed through Cloudinary
         * - Preview size, based on the platform wide thumbnail dimensions
         * - 800px wide resource, used for background image setting
         * - 150px wide resource, used in the graphics tab
         * - 160px wide resource, used in the watermarks tab
         * 
         * @todo    Optimize this so only the sizes used for each upload type
                    (eg. graphic, photo, watermark) is preloaded
         * @todo    Optimize this so for graphic and watermark uploads, the size
         *          that would be added to the canvas is preloaded (eg. at the
         *          moment, that size is 15% of the canvas).
         * @access  public
         * @param   Function success
         * @param   Function error
         * @return  void
         */
        preload: function(success, error) {
            // Determine urls
            var urls = [
                this.url('thumb')
            ];
            if (this._data.type === 'watermark') {
                // urls.push(this.url('scale', {width: 160}));
                // urls.push(this.url('thumb'));
            }

            // Run preload with callback functions
            success = success || function(){};
            error = error || function(){};
            Images.preload(urls, success.proxy(this), error.proxy(this));
        },

        /**
         * setBackgroundBitmapImageLayer
         * 
         * @note    Defaults to not auto selecting the drawing
         * @access  public
         * @param   Boolean locked
         * @param   undefined|Object options (optional)
         * @return  BackgroundBitmapImageLayer
         */
        setBackgroundBitmapImageLayer: function(locked, options) {
            options = options || {};
            var canvas = Canvases.Preview,
                layer = canvas.getBackgroundBitmapImageLayer(),
                drawing = layer.getDrawing(),
                key = this._data.key;
            layer.setChangeOperationType('image:changed');
            layer.setImage(key);
            layer.setProperty('locked', locked);
            drawing.once({

                /**
                 * (anonymous)
                 * 
                 * I clear the background after the <refresh> event has fired to
                 * prevent a flickering. If it were before, the background color
                 * would be removed, the user would see white, and then the
                 * image would be shown :/
                 * 
                 * @access  private
                 * @return  void
                 */
                'refresh': function(event) {
                    canvas.resetBackgroundRectangleLayer();
                    ChangeHistory.syncBackgroundImageSet();
                    canvas.render();
                    if (options.autoSelect === true) {
                        this.select();
                    }
                }
            });
            drawing.reload();
            return layer;
        },

        /**
         * sync
         * 
         * @access  public
         * @return  void
         */
        sync: function() {
            this._model.sync(this._data.key);
            this.triggerHandler('sync/start');
        },

        /**
         * syncDimensions
         * 
         * Syncs the width/height of the upload if it's not yet stored in the
         * object. Will only be used via legacy image uploads being selected,
         * since all new ones are routed through /sync against the upload record
         * to have the server pull the width/height in.
         * 
         * @access  public
         * @return  void
         */
        syncDimensions: function() {
            if (
                this._data.width.toInt() === 0
                || this._data.height.toInt() === 0
            ) {
                var _this = this,
                    image = new Image();
                image.onload = function() {
                    _this.set({
                        'width': image.width.toInt(),
                        'height': image.height.toInt()
                    });
                    _this.save(['width', 'height']);
                };
                image.src = this.url('original');
            }
        },

        /**
         * unfavorite
         * 
         * @access  public
         * @param   String areaType
         * @param   Boolean performDataRequest
         * @return  void
         */
        unfavorite: function(areaType, performDataRequest) {
            Account.favorites.remove(this);
            var category = Categories.account.favorites('uploads');
            this.unfeature(category, performDataRequest);
        },

        /**
         * unfeature
         * 
         * @note    Handler needs to be fired before accessor is removed from
         *          collection
         * @access  public
         * @param   CategoryAccessor category
         * @param   undefined|Boolean performDataRequest (default: true)
         * @return  void
         */
        unfeature: function(category, performDataRequest) {
            performDataRequest = DataUtils.getDefaultValue(
                performDataRequest,
                true
            );
            category.features.remove.apply(category, [this]);
            var key = category.get('key'),
                features = App.getEditor().getArea('uploads').getChild('categories').getChild(key).getCollection();
            if (performDataRequest === true) {
                this._model.unfeature(
                    this._data.key,
                    {
                        category: category.get('key')
                    }
                );
            }
            this.triggerHandler('unfeature', [category]);
            features.remove(this);
        },

        /**
         * url
         * 
         * Provides a proxy for Cloudinary for the following cases:
         * - Original image url, used with legacy upload dimension syncing
         * - Scaled image url, used for thumbnails for watermarks and graphics
         * - Thumb image url, used for within Photos and Graphics for upload
         *   thumbs
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options
         * @return  String|false
         */
        url: function(type, options) {
            if (type === 'original') {
                return Images.thumb(this._data.key, {
                    type: 'original'
                });
            } else if (type === 'scale') {
                return Images.thumb(this._data.key, {
                    type: 'scale',
                    width: options.width
                });
            } else if (type === 'thumb') {
                return Images.thumb(this._data.key, {
                    type: 'thumb'
                });
            }
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'UpgradeModel'], function() {

    /**
     * UpgradeAccessor
     * 
     * @extends Accessor
     */
    window.UpgradeAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Upgrade'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradeAccessor')
         */
        _string: 'UpgradeAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupCoupon();
            this._setupCustomer();
            this._setupPromo();
        },

        /**
         * _setupCoupon
         * 
         * @access  protected
         * @return  void
         */
        _setupCoupon: function() {
            if (this._data.coupon !== false) {
                var model = Stencil.getModel('Coupon');
                this._references.coupon = model.setAccessor(
                    this._data.coupon
                );
            }
        },

        /**
         * _setupCustomer
         * 
         * @access  protected
         * @return  void
         */
        _setupCustomer: function() {
            if (this._data.customer !== false) {
                var model = Stencil.getModel('Customer');
                this._references.customer = model.setAccessor(
                    this._data.customer
                );
            }
        },

        /**
         * _setupPromo
         * 
         * @access  protected
         * @return  void
         */
        _setupPromo: function() {
            if (this._data.promo !== false) {
                var model = Stencil.getModel('Promo');
                this._references.promo = model.setAccessor(this._data.promo);
            }
        },

        /**
         * coupon
         * 
         * Returns the CouponAccessor reference for the upgrade.
         * 
         * @access  public
         * @return  undefined|CouponAccessor
         */
        coupon: function() {
            return this._references.coupon;
        },

        /**
         * customer
         * 
         * Returns the CustomerAccessor reference for the upgrade.
         * 
         * @access  public
         * @return  CustomerAccessor
         */
        customer: function() {
            return this._references.customer;
        },

        /**
         * getCentsPaid
         * 
         * Returns the number of cents that was processed against the Upgrade
         * record, based on the plan and interval.
         * 
         * @access  public
         * @return  Number
         */
        // getCentsPaid: function() {
        //     var interval = this._data.interval,
        //         plan = this._data.plan.ucfirst(),
        //         column = (interval) + (plan) + 'Rate';
        //     return this._data[column];
        // },

        /**
         * getShareASaleCommissionTypeIdentifier
         * 
         * @access  public
         * @return  String
         */
        getShareASaleCommissionTypeIdentifier: function() {
            var plan = this._data.plan,
                interval = this._data.interval;
            return (plan) + '-' + (interval);
        },

        /**
         * getTapfiliateCommissionTypeIdentifier
         * 
         * @access  public
         * @return  String
         */
        getTapfiliateCommissionTypeIdentifier: function() {
            var plan = this._data.plan,
                interval = this._data.interval;
            return (plan) + '-' + (interval);
        },

        /**
         * promo
         * 
         * @access  public
         * @return  PromoAccessor
         */
        promo: function() {
            return this._references.promo;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'UserModel'], function() {

    /**
     * UserAccessor
     * 
     * @extends Accessor
     */
    window.UserAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('User'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserAccessor')
         */
        _string: 'UserAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
            this._setupActive();
            this._setupCustomers();
            this._setupRavenEmailChangeListener();
        },

        /**
         * _setupActive
         * 
         * @note    The problem with this method is it'll overwrite the
         *          already-loaded account, but with less data (since the
         *          server-side call doesn't go deep into the AccountAccessor
         *          reference).
         * @note    I don't think above is true; the data is merged via the
         *          jQuery extend method, which is non-destructive
         * @access  protected
         * @return  void
         */
        _setupActive: function() {
            var model = Stencil.getModel('Account');
            this._references.active = model.setAccessor(
                this._data.active
            );
        },

        /**
         * _setupCustomers
         * 
         * @access  protected
         * @return  void
         */
        _setupCustomers: function() {
            this._collections.customers = this._collections.customers || new CustomersCollection();
            this._collections.customers.map(this._data.customers, true);
            Account.once({
                'upgrade': this._setupCustomers.proxy(this)
            });
        },

        /**
         * _setupRavenEmailChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _setupRavenEmailChangeListener: function() {
            this.on({
                'change/email': function(event, newValue) {
                    if ('Raven.setUserContext'.validMethod() === true) {
                        Raven.setUserContext({
                            email: this.get('email'),
                            id: this.get('id')
                        });
                    }
                }
            });
        },

        /**
         * active
         * 
         * Returns the active AccountAccessor for the user. Currently only being
         * used in admin area and analytics below.
         * 
         * @access  public
         * @return  AccountAccessor
         */
        active: function() {
            return this._references.active;
            // return Stencil.account();
        },

        /**
         * admin
         * 
         * @access  public
         * @return  Boolean
         */
        admin: function() {
            return this.setting('admin').toInt() === 1;
        },

        /**
         * customer
         * 
         * Returns whether or not the account has a customer record.
         * 
         * @access  public
         * @return  Boolean
         */
        // customer: function() {
        //     return this._collections.customers.all().length !== 0;
        // },

        /**
         * customers
         * 
         * @access  public
         * @param   undefined|Function filter
         * @return  Array
         */
        customers: function(filter) {
            if (filter === undefined) {
                return this._collections.customers;
            }
            return this._collections.customers.filter(filter);
        },

        /**
         * editor
         * 
         * @access  public
         * @return  Boolean
         */
        editor: function() {
            return this.setting('editor').toInt() === 1;
        },

        /**
         * getInterval
         * 
         * @access  public
         * @return  String
         */
        getInterval: function() {
            if (this.active().upgraded() === true) {
                return this.active().upgrade().get('interval');
            }
            return '';
        },

        /**
         * getPartner
         * 
         * @access  public
         * @return  String
         */
        getPartner: function() {
            if (this.active().promo() === true) {
                return this.active().upgrade().customer().get('gateway');
            }
            return '';
        },

        /**
         * getPlan
         * 
         * @access  public
         * @return  String
         */
        getPlan: function() {
            if (this.active().upgraded() === true) {
                return this.active().upgrade().get('plan');
            }
            return 'free';
        },

        /**
         * getTraits
         * 
         * @todo    Ensure all properties below (eg. frames connections, uploads,
         *          favorites) properly sync to Segment when their values change.
         * @note    Properties here need to be set in Segment:
         *          https://i.imgur.com/oonHgPN.png
         *          If they're not set, they own't be received. A way around this
         *          was to have all traits be set as super properties. The
         *          problem with that was properties would be passed along to
         *          events as well.
         * @access  public
         * @return  Object
         */
        getTraits: function() {
            return {

                // Basics
                _akey: this.active().get('key'),
                _secret: this._data.secret,
                _legacy: this._data.legacy,
                _email: this._data.email,
                _name: this._data.name,
                _plan: this.getPlan(),
                _partner: this.getPartner(),
                _interval: this.getInterval(),
                _promotions: this._data.notification.promotions,
                _resources: this._data.notification.resources,
                _blog: this._data.notification.blog,
                _account: this._data.notification.account,
                _product: this._data.notification.product,

                // Connections
                _connections: this.active().collection('connections').all().length,
                _facebookConnections: this.active().collection('connections').facebook().length,
                _twitterConnections: this.active().collection('connections').twitter().length,

                // Frames
                _frames: this.active().collection('frames').custom().length,

                // Extras
                _stars: this.active().get('favorites').length,
                _monthlyMaxImages: this.active().get('monthlyMaxImages'),
                _monthlySavedImages: this.active().get('monthlySavedImages'),
                _totalSavedImages: this.active().get('totalSavedImages'),
                _bonusImages: this.active().get('bonusImages'),
                _tweetBonus: this.active().get('tweetBonus'),
                _shareBonus: this.active().get('shareBonus'),
                _followBonus: this.active().get('followBonus')
            };
        },

        /**
         * showLegacyWelcome
         * 
         * @access  public
         * @return  void
         */
        showLegacyWelcome: function() {
            if (
                this._data.legacy.toInt() === 1
                && this._data.settings.legacyWelcomed.toInt() === 0
                && Modals.getOpen().length === 0
            ) {
                this.set({
                    'settings.legacyWelcomed': 1
                });
                this.save(['settings.legacyWelcomed']);
                Stencil.navigate('/app/legacy?clean=1');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Accessor', 'UserAccountModel'], function() {

    /**
     * UserAccountAccessor
     * 
     * @extends Accessor
     */
    window.UserAccountAccessor = Accessor.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('UserAccount'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UserAccountAccessor')
         */
        _string: 'UserAccountAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            this._super(data);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['UploadAccessor', 'WatermarkModel'], function() {

    /**
     * WatermarkUploadAccessor
     * 
     * @extends UploadAccessor
     */
    window.WatermarkUploadAccessor = UploadAccessor.extend({

        /**
         * _lastSavedFiltersString
         * 
         * Reference to the last filter-based JSON string that was saved for
         * this watermark. Used to prevent PATCH calls on an upload when it's
         * underlying filters have not changed.
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastSavedFiltersString: '',

        /**
         * _lastSavedStylesString
         * 
         * Reference to the last style-based JSON string that was saved for this
         * watermark. Used to prevent PATCH calls on an upload when it's
         * underlying styles have not changed.
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastSavedStylesString: '',

        /**
         * _layer
         * 
         * @access  protected
         * @var     false|Layer (default: false)
         */
        _layer: false,

        /**
         * _model
         * 
         * @access  protected
         * @var     WatermarkModel
         */
        _model: Stencil.getModel('Watermark'),

        /**
         * _saveFiltersTimeout
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _saveFiltersTimeout: null,

        /**
         * _saveStylesTimeout
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _saveStylesTimeout: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkUploadAccessor')
         */
        _string: 'WatermarkUploadAccessor',

        /**
         * init
         * 
         * @access  public
         * @param   Object data
         * @return  void
         */
        init: function(data) {
            if (data.settings.filters === '') {
                // var filters = [];
                // data.settings.filters = JSON.stringify(filters);
// window.t = this;
// StencilBooter.log(this.toString());
// StencilBooter.log(JSON.stringify(filters));
//                 this.set({
//                     'settings.filters': JSON.stringify(filters)
//                 });
            }
            this._super(data);
        },

        /**
         * _getDefaultStyles
         * 
         * @access  protected
         * @return  Object
         */
        _getDefaultStyles: function() {
            return {
                angle: 0,
                flipX: false,
                flipY: false,
                left: 50,
                stretchX: 1,
                stretchY: 1,
                top: 50,
                width: 30
            };
        },

        /**
         * _getLayerFilters
         * 
         * @note    Slicing array here to clone it
         * @see     http://stackoverflow.com/questions/3775480/is-there-a-method-to-clone-an-array-in-jquery
         * @access  protected
         * @return  Object
         */
        _getLayerFilters: function() {
            return this._layer.getProperty('filters').slice();
        },

        /**
         * _getLayerStyles
         * 
         * @access  protected
         * @return  Object
         */
        _getLayerStyles: function() {
            var styles = this._layer.getStyles(),
                cloned = jQuery.extend(true, {}, styles);
            delete cloned.order;
            return cloned;
        },

        /**
         * addToCanvas
         * 
         * At the moment, the only time <focus> is set to false is when this
         * method is called from the User.login routine. The intention is to
         * prevent any watermarks from being focused on when they're simply
         * turned on via logging in.
         * 
         * @access  public
         * @param   Boolean focus
         * @return  void
         */
        addToCanvas: function(focus) {
            if (
                JSONUtils.valid(this._data.settings.filters) === true
                && JSONUtils.valid(this._data.settings.styles) === true
            ) {
                var filters = JSON.parse(this._data.settings.filters),
                    styles = JSON.parse(this._data.settings.styles),
                    canvas = Canvases.Preview,
                    layer = canvas.addWatermarkBitmapImageLayer({
                        filters: filters,
                        image: this._data.key,
                        styles: styles,
                        type: 'image',
                        watermark: true
                    }),
                    drawing = layer.getDrawing();
                layer.setChangeOperationType('added');
                drawing.once({
                    'draw': function(event) {
                        focus && this.select();
                        canvas.render();
                        drawing.animate();
                    }
                });
                drawing.draw();
            } else {
                StencilBooter.log('JSON parse error (W:aTC)');
            }
        },

        /**
         * clearSaveFiltersTimeout
         * 
         * @access  public
         * @return  void
         */
        clearSaveFiltersTimeout: function() {
            TimeoutPool.clear(this._saveFiltersTimeout);
        },

        /**
         * clearSaveStylesTimeout
         * 
         * @access  public
         * @return  void
         */
        clearSaveStylesTimeout: function() {
            TimeoutPool.clear(this._saveStylesTimeout);
        },

        /**
         * delete
         * 
         * @access  public
         * @return  void
         */
        delete: function() {
            this.push('usable', 0);
            Account.favorites.remove(this);
            this.triggerHandler('delete');
            jQuery.each(this._within, function(index, collection) {
                collection.triggerHandler('update');
            });
            // this.removeAll();
        },

        /**
         * markFiltersAsSaved
         * 
         * @access  public
         * @return  void
         */
        markFiltersAsSaved: function() {
            var filters = this._getLayerFilters();
            this._lastSavedFiltersString = JSON.stringify(filters);
        },

        /**
         * markStylesAsSaved
         * 
         * @access  public
         * @return  void
         */
        markStylesAsSaved: function() {
            var styles = this._getLayerStyles();
            this._lastSavedStylesString = JSON.stringify(styles);
        },

        /**
         * preloadDrawingImage
         * 
         * @access  public
         * @return  void
         */
        preloadDrawingImage: function() {
            if (JSONUtils.valid(this._data.settings.styles) === true) {
                var styles = JSON.parse(this._data.settings.styles),
                    dimensions = Canvases.Preview.getRenderedDimensions(),
                    percentage = styles.width.toFloat() / 100,
                    pixels = (dimensions.width * percentage).round(4);
                pixels = pixels.round(0);
                var ratio = window.devicePixelRatio || 1,
                    key = this._data.key;
                pixels *= ratio;
                var url = Images.thumb(key, {
                    type: 'scale',
                    width: pixels.round(0)
                });
                var preloadKey = 'watermark' +
                        '.preloadDrawingImage' +
                        '.' + (url);
                    preloaded = Stencil.get(preloadKey);
                if (preloaded === undefined) {
                    Stencil.set(preloadKey, true);
                    new Image().src = url;
                }
            } else {
                StencilBooter.log('JSON parse error (W:pDI)q');
            }
        },

        /**
         * removeFromCanvas
         * 
         * @access  public
         * @return  void
         */
        removeFromCanvas: function() {
            this._layer.triggerHandler('delete');
        },

        /**
         * saveFilters
         * 
         * Note that the deleted check here is against the accessor and not the
         * layer. This is because if the layer has been deleted in the database,
         * any PATCH calls against it will naturally fail.
         * 
         * @access  public
         * @return  void
         */
        saveFilters: function() {
            if (this.deleted() === false) {
                var filters = this._getLayerFilters(),
                    filtersString = JSON.stringify(filters);
                if (filtersString !== this._lastSavedFiltersString) {
                    this.save(['settings.filters']);
                    this.markFiltersAsSaved();
                }
            }
        },

        /**
         * saveStyles
         * 
         * Note that the deleted check here is against the accessor and not the
         * layer. This is because if the layer has been deleted in the database,
         * any PATCH calls against it will naturally fail.
         * 
         * @access  public
         * @return  void
         */
        saveStyles: function() {
            if (this.deleted() === false) {
                var styles = this._getLayerStyles(),
                    stylesString = JSON.stringify(styles);
                if (stylesString !== this._lastSavedStylesString) {
                    this.save(['settings.styles']);
                    this.markStylesAsSaved();
                }
            }
        },

        /**
         * setDefaultSettings
         * 
         * @todo!   Handle case where watermark is really tall
         * @access  public
         * @return  void
         */
        setDefaultSettings: function() {
            var styles = this._getDefaultStyles();
            this.set({
                'settings.filters': JSON.stringify([]),
                'settings.styles': JSON.stringify(styles)
            });
            this.save(['settings.filters', 'settings.styles']);
        },

        /**
         * setFilters
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the styles associated with the watermark (excluding the
         * position-style, which is removed via the helper <_getLayerFilters>
         * method).
         * 
         * Also triggers a setConfiguration call against the draft to ensure
         * that the draft has the most up-to-date watermarks-setting.
         * 
         * @access  public
         * @return  void
         */
        setFilters: function() {
            var filters = this._getLayerFilters(),
                delay = Stencil.getSaveDelay('watermark');
            this.set({
                'settings.filters': JSON.stringify(filters)
            });
            Stencil.account().draft().setConfiguration();
            this.clearSaveFiltersTimeout();
            this._saveFiltersTimeout = this.saveFilters.delay(delay, this);
        },

        /**
         * setLayer
         * 
         * @access  public
         * @param   WatermarkBitmapLayer layer
         * @return  void
         */
        setLayer: function(layer) {
            this._layer = layer;
        },

        /**
         * setStyles
         * 
         * Delays a call to the server (and clears any previous delays) to save
         * the styles associated with the watermark (excluding the
         * position-style, which is removed via the helper <_getLayerStyles>
         * method).
         * 
         * Also triggers a setConfiguration call against the draft to ensure
         * that the draft has the most up-to-date watermarks-setting.
         * 
         * @access  public
         * @return  void
         */
        setStyles: function() {
            var styles = this._getLayerStyles(),
                delay = Stencil.getSaveDelay('watermark');
            this.set({
                'settings.styles': JSON.stringify(styles)
            });
            Stencil.account().draft().setConfiguration();
            this.clearSaveStylesTimeout();
            this._saveStylesTimeout = this.saveStyles.delay(delay, this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'CategoryModel'], function() {

    /**
     * CategoriesCollection
     * 
     * @extends Collection
     */
    window.CategoriesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Category'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoriesCollection')
         */
        _string: 'CategoriesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @return  void
         */
        sort: function() {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = '/categories/sort';
            Stencil.ajax({
                signature: {file: 'Categories', line: 53},
                url: path,
                type: 'POST',
                data: {
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'c63-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Base', function() {

    /**
     * Collection
     * 
     * @events  add
     *          remove
     *          update
     *          list
     * @extends Base
     */
    window.Collection = Base.extend({

        /**
         * _accessors
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _accessors: [],

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'collection')
         */
        _classType: 'collection',

        /**
         * _model
         * 
         * @access  protected
         * @var     Model (default: null)
         */
        _model: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Collection')
         */
        _string: 'Collection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
            this._accessors = [];
        },

        /**
         * add
         * 
         * @example Collection.add(Accessor)
         *          Collection.add([Accessor])
         * @note    <within> call below ensures Accessor knows which collections
         *          it's part of, so that it can properly remove itself from
         *          them when it's deleted.
         * @note    <add> event triggered passes in the position within the
         *          collection so that the UI drawn is appropriate (eg. at the
         *          beginning or at the end).
         * @access  public
         * @param   Array|Accessor accessors
         * @param   Boolean push Whether the object(s) should be pushed or
         *          unshifted against the array
         * @return  void
         */
        add: function(accessors, push) {
            var _this = this,
                added = 0;
            if (jQuery.isArray(accessors) === false) {
                accessors = [accessors];
            }
            jQuery.each(accessors, function(index, accessor) {
                ++added;
                if (push === true) {
                    _this._accessors.push(accessor);
                } else {
                    _this._accessors.unshift(accessor);
                }
                accessor.within(_this);
                _this.triggerHandler('add',
                    [accessor, _this._accessors.indexOf(accessor)]
                );
            });
            if (added > 0) {
                this.triggerHandler('update');
            }
        },

        /**
         * all
         * 
         * @access  public
         * @return  Array
         */
        all: function() {
            return this._accessors;
        },

        /**
         * each
         * 
         * @access  public
         * @param   Function iterator
         * @return  void
         */
        each: function(iterator) {
            jQuery.each(this._accessors, function(index, accessor) {
                iterator(index, accessor);
            });
        },

        /**
         * empty
         * 
         * @access  public
         * @return  void
         */
        empty: function() {
            this.remove(this._accessors.slice());
            this.triggerHandler('empty');
        },

        /**
         * filter
         * 
         * @access  public
         * @param   Function filter
         * @return  Array
         */
        filter: function(filter) {
            var matching = [];
            jQuery.each(this._accessors, function(index, accessor) {
                if (filter(index, accessor) === true) {
                    matching.push(accessor);
                }
            });
            return matching;
        },

        /**
         * find
         * 
         * @access  public
         * @param   String key
         * @return  false|Accessor
         */
        find: function(key) {
            var matching = this.filter(function(index, accessor) {
                return accessor.get('key') === key;
            });
            if (matching.length === 0) {
                return false;
            }
            return matching[0];
        },

        /**
         * first
         * 
         * @access  public
         * @return  Object
         */
        first: function() {
            return this._accessors[0];
        },

        /**
         * last
         * 
         * @access  public
         * @return  Object
         */
        last: function() {
            var position = this._accessors.length - 1;
            return this._accessors[position];
        },

        /**
         * length
         * 
         * @access  public
         * @return  Number
         */
        length: function() {
            return this._accessors.length;
        },

        /**
         * list
         * 
         * @note    I check for a "timeout" <textStatus> here (as opposed to
         *          other ajax calls) because there is a higher possibility that
         *          a request times out, since some of the list calls against a
         *          collection will be for Pixabay/The Noun Project, which have
         *          been known to timeout. I've checked the backend, and it looks
         *          like Collection.list calls are currently the only ones that
         *          actually attempt to make a connection to these 3rd parties.
         *          /save, and /feature don't, since they depend on passed in
         *          URLs.
         * @todo    Currently, a timeout will result in the same UI as empty
         *          search results. Update it so that it communicates that the
         *          user needs to try again.
         * @access  public
         * @param   Object data
         * @param   Function callback
         * @return  void
         */
        list: function(data, callback) {
            var _this = this,
                path = this._model.getBase(),
                signature = {file: 'Collection', line: 217};
            Stencil.ajax({
                signature: signature,
                url: path,
                type: 'GET',
                data: data,
                error: function(jqXHR, textStatus, errorThrown) {

                    // Console logging
                    App.log('jQuery AJAX error', true);
                    App.log(signature, true);
                    App.log(arguments, true);

                    // Timeouts are more common with resource collections
                    if (textStatus === 'timeout') {
                        _this.map([], true);
                        callback && callback({
                            data: {
                                more: false
                            }
                        });
                        _this.triggerHandler('list');
                    } else {

                        // Segment tracking
                        Track.event('Ajax Error (Collection)', {
                            _code: signature.line,
                            _reference: signature.file,
                            _data: JSON.stringify(data),
                            _url: path,
                            _textStatus: textStatus
                        });

                        // Connection check
                        Stencil.alive(function() {
                            var code = signature.line,
                                reference = signature.file;
                            Stencil.error(code, reference);
                        });
                    }
                },
                success: function(response) {
                    if (response.success === true) {
                        _this.map(response.data.objects, true);
                        callback && callback(response);
                        _this.triggerHandler('list');
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'c247-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        },

        /**
         * map
         * 
         * Maps raw data to it's associated accessors, and then pushes them into
         * the collection.
         * 
         * @example Collection.map(Object, true)
         *          Collection.map([Object], false)
         * @access  public
         * @param   Array|Object objects
         * @param   Boolean push Whether the object(s) should be pushed or
         *          unshifted against the array
         * @return  Array
         */
        map: function(objects, push) {
            var _this = this,
                accessors = [];
            if (jQuery.isArray(objects) === false) {
                objects = [objects];
            }
            jQuery.each(objects, function(index, obj) {
                accessors.push(_this._model.setAccessor(obj));
            });
            this.add(accessors, push);
            return accessors;
        },

        /**
         * move
         * 
         * @see     http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
         * @access  public
         * @param   Accessor accessor
         * @param   Number position
         * @return  void
         */
        move: function(accessor, position) {
            var original = this._accessors.indexOf(accessor);
            this._accessors.splice(
                position,
                0,
                this._accessors.splice(original, 1)[0]
            );
            this.triggerHandler('move', [accessor, position, original]);
        },

        /**
         * remove
         * 
         * @example Collection.remove(Accessor)
         *          Collection.remove([Accessor])
         * @access  public
         * @param   Array|Accessor accessors
         * @return  Number
         */
        remove: function(accessors) {
            var _this = this,
                removed = 0;
            if (jQuery.isArray(accessors) === false) {
                accessors = [accessors];
            }
            jQuery.each(accessors, function(index, accessor) {
                index = _this._accessors.indexOf(accessor);
                if (index !== -1) {
                    ++removed;
                    _this._accessors.splice(index, 1);
                    _this.triggerHandler('remove', [accessor]);
                }
            });
            if (removed > 0) {
                this.triggerHandler('update');
            }
            return removed;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'ColorModel'], function() {

    /**
     * ColorsCollection
     * 
     * @extends Collection
     */
    window.ColorsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Color'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorsCollection')
         */
        _string: 'ColorsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * addColor
         * 
         * @access  public
         * @param   String rgbaColorStr
         * @return  ColorAccessor
         */
        addColor: function(rgbaColorStr) {
            var hex = ColorUtils.convert(rgbaColorStr, 'hex'),
                colors = this.map({
                    'class': 'color',
                    'key': 'clrX' + DataUtils.getRandomString(8).toLowerCase(),
                    'label': hex.toLowerCase(),
                    'color': rgbaColorStr
                }, false);
            this._model.create({
                'label': hex.toLowerCase(),
                'color': rgbaColorStr
            }, function(data) {
                colors[0].swap(data.object);
            });
            return colors[0];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'ConnectionModel'], function() {

    /**
     * ConnectionsCollection
     * 
     * @extends Collection
     */
    window.ConnectionsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Connection'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionsCollection')
         */
        _string: 'ConnectionsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
            // this.on({
            //     'update': function(event) {
            //         Track.user();
            //     }
            // });
        },

        /**
         * facebook
         * 
         * @access  public
         * @return  Array
         */
        facebook: function() {
            return this.network('facebook');
        },

        /**
         * network
         * 
         * @access  public
         * @param   String network
         * @return  Array
         */
        network: function(network) {
            return this.filter(function(index, connection) {
                return connection.get('network') === network;
            });
        },

        /**
         * twitter
         * 
         * @access  public
         * @return  Array
         */
        twitter: function() {
            return this.network('twitter');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'CouponModel'], function() {

    /**
     * CouponsCollection
     * 
     * @extends Collection
     */
    window.CouponsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Coupon'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CouponsCollection')
         */
        _string: 'CouponsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'CustomerModel'], function() {

    /**
     * CustomersCollection
     * 
     * @extends Collection
     */
    window.CustomersCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Customer'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomersCollection')
         */
        _string: 'CustomersCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'FeatureModel'], function() {

    /**
     * FeaturesCollection
     * 
     * @extends Collection
     */
    window.FeaturesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Feature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FeaturesCollection')
         */
        _string: 'FeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {

            // Data
            var objects = {};
            jQuery.each(this._accessors, function(index, accessor) {
                objects[accessor.get('key')] = index;
            });

            // Save
            var path = '/features/sort';
            Stencil.ajax({
                signature: {file: 'Features', line: 54},
                url: path,
                type: 'POST',
                data: {
                    category: category.get('key'),
                    objects: objects
                },
                success: function(response) {
                    if (response.success === true) {
                    } else {
                        var error = Stencil.extractError(response),
                            code = 'f65-' + (error.code),
                            reference = error.reference;
                        Stencil.error(code, reference);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'FontModel'], function() {

    /**
     * FontsCollection
     * 
     * @see     https://speakerdeck.com/bramstein/web-fonts-performance
     * @events  load/all/normal
     * @extends Collection
     */
    window.FontsCollection = Collection.extend({

        /**
         * _loaded
         * 
         * Keeps track of fonts that have been loaded using familyName:n4
         * notation. This ensures that there aren't race-conditions between
         * loading the normal versions of fonts, and the full versions (which
         * may include bold, italic and/or bold + italic versions).
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _loaded: [],

        /**
         * _loading
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _loading: [],

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Font'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontsCollection')
         */
        _string: 'FontsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * findByFamilyName
         * 
         * @access  public
         * @param   String familyName
         * @return  false|FontAccessor
         */
        findByFamilyName: function(familyName) {
            var fonts = this.filter(function(index, font) {
                return font.get('familyName') === familyName;
            });
            if (fonts.length === 0) {
                return false;
            }
            return fonts.shift();
        },

        /**
         * getDefaults
         * 
         * @access  public
         * @return  Array
         */
        getDefaults: function() {
            return this.filter(function(index, font) {
                return font.get('uploaded').toInt() === 0;
            });
        },

        /**
         * getLoaded
         * 
         * @access  public
         * @return  Array
         */
        getLoaded: function() {
            return this._loaded;
        },

        /**
         * getLoading
         * 
         * @access  public
         * @return  Array
         */
        getLoading: function() {
            return this._loading;
        },

        /**
         * getUploaded
         * 
         * @access  public
         * @return  Array
         */
        getUploaded: function() {
            return this.filter(function(index, font) {
                return font.get('uploaded').toInt() === 1
                    && font.get('hasRegularAccess').toInt() === 1;
            });
        },

        /**
         * loadAllNormal
         * 
         * @access  public
         * @param   Array fontsToExclude
         * @return  void
         */
        loadAllNormal: function(fontsToExclude) {

            /**
             * Group fonts to load by whether they were uploaded or not
             * (excluding native and intentionally-excluded fonts).
             */
            var googleFontsToLoad = this.filter(function(index, font) {
                    var familyName = font.get('familyName');
                    return fontsToExclude.indexOf(familyName) === -1
                        && font.get('isLegacyFont') === false
                        && font.get('native').toInt() === 0
                        && font.get('uploaded').toInt() === 0;
                }),
                customFontsToLoad = this.filter(function(index, font) {
                    var familyName = font.get('familyName');
                    return fontsToExclude.indexOf(familyName) === -1
                        && font.get('native').toInt() === 0
                        && font.get('uploaded').toInt() === 1;
                });

            // Reformat the arrays for WebFont compatibility, and track them
            var googleFontFamiliesToLoad = (function(googleFontsToLoad) {
                    var familyNames = [], index, familyName;
                    for (index in googleFontsToLoad) {
                        familyName = googleFontsToLoad[index].get('familyName');
                        familyName += ':n4';
                        this._loading.push(familyName);
                        familyNames.push(familyName);
                    }
                    return familyNames;
                }).apply(this, [googleFontsToLoad]),
                customFontFamiliesToLoad = (function(customFontsToLoad) {
                    var familyNames = [], index, familyName;
                    for (index in customFontsToLoad) {
                        familyName = customFontsToLoad[index].get('familyName');
                        familyName += ':n4';
                        this._loading.push(familyName);
                        familyNames.push(familyName);
                    }
                    return familyNames;
                }).apply(this, [customFontsToLoad]);

            /**
             * Boot it in, and use the fontactive event to check whether all
             * the request fonts have been loaded. Using this instead of the
             * active event due to a bug with the library.
             */
            WebFont.load({
                classes: false,
                custom: {
                    families: DataUtils.convertGoogleFontNames(customFontFamiliesToLoad)
                },
                fontactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loaded.push(formattedFamilyName);
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/all/normal');
                    }
                }).proxy(this),
                fontinactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/all/normal');
                    }
                }).proxy(this),
                google: {
                    families: DataUtils.convertGoogleFontNames(googleFontFamiliesToLoad)
                },
                timeout: 5000
            });
        },

        /**
         * loadUploadedNormal
         * 
         * @access  public
         * @return  void
         */
        loadUploadedNormal: function() {

            // Get the uploaded FontAccessor's
            var customFontsToLoad = this.filter(function(index, font) {
                var familyName = font.get('familyName');
                return font.get('native').toInt() === 0
                    && font.get('uploaded').toInt() === 1;
            });

            // Reformat the fonts for WebFont compatibility, and track them
            var customFontFamiliesToLoad = (function(customFontsToLoad) {
                var familyNames = [], index, familyName;
                for (index in customFontsToLoad) {
                    familyName = customFontsToLoad[index].get('familyName');
                    familyName += ':n4';
                    this._loading.push(familyName);
                    familyNames.push(familyName);
                }
                return familyNames;
            }).apply(this, [customFontsToLoad]);

            /**
             * Boot it in, and use the fontactive event to check whether all
             * the request fonts have been loaded. Using this instead of the
             * active event due to a bug with the library.
             */
            WebFont.load({
                classes: false,
                custom: {
                    families: customFontFamiliesToLoad
                },
                fontactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loaded.push(formattedFamilyName);
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/uploaded/normal');
                    }
                }).proxy(this),
                fontinactive: (function(familyName, fvd) {
                    var formattedFamilyName = (familyName) + ':' + (fvd),
                        loadingArrayIndex = _.indexOf(
                            this._loading,
                            formattedFamilyName
                        );
                    this._loading.splice(loadingArrayIndex, 1);
                    if (this._loading.length === 0) {
                        this.triggerHandler('load/uploaded/normal');
                    }
                }).proxy(this),
                timeout: 5000
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'FrameModel'], function() {

    /**
     * FramesCollection
     * 
     * @extends Collection
     */
    window.FramesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Frame'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FramesCollection')
         */
        _string: 'FramesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
            // this.on({
            //     'update': function(event) {
            //         Track.user();
            //     }
            // });
        },

        /**
         * custom
         * 
         * @access  public
         * @return  Array
         */
        custom: function() {
            return this.filter(function(index, frame) {
                return frame.get('type') === 'custom';
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'GoogleFontModel'], function() {

    /**
     * GoogleFontsCollection
     * 
     * @extends Collection
     */
    window.GoogleFontsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GoogleFont'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontsCollection')
         */
        _string: 'GoogleFontsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourceFeaturesCollection', 'GraphicFeatureModel'], function() {

    /**
     * GraphicFeaturesCollection
     * 
     * @extends ResourceFeaturesCollection
     */
    window.GraphicFeaturesCollection = ResourceFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GraphicFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicFeaturesCollection')
         */
        _string: 'GraphicFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourcesCollection', 'GraphicResourceModel'], function() {

    /**
     * GraphicResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.GraphicResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('GraphicResource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicResourcesCollection')
         */
        _string: 'GraphicResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection', 'ImageFeatureModel'], function() {

    /**
     * ImageFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.ImageFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('ImageFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageFeaturesCollection')
         */
        _string: 'ImageFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {
            var accessors = this.all();
            if (category.syncedFeatures.contains.apply(category, [accessors]) === false) {
                category.unbind('syncedFeatures/add');
                category.once({
                    'syncedFeatures/add': this.sort.proxy(this, [category])
                });
            } else {
                this._super(category);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'ImageModel'], function() {

    /**
     * ImagesCollection
     * 
     * @extends Collection
     */
    window.ImagesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Image'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImagesCollection')
         */
        _string: 'ImagesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourceFeaturesCollection', 'PhotoFeatureModel'], function() {

    /**
     * PhotoFeaturesCollection
     * 
     * @extends ResourceFeaturesCollection
     */
    window.PhotoFeaturesCollection = ResourceFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PhotoFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoFeaturesCollection')
         */
        _string: 'PhotoFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourcesCollection', 'PhotoResourceModel'], function() {

    /**
     * PhotoResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.PhotoResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PhotoResource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoResourcesCollection')
         */
        _string: 'PhotoResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'PromoSetModel'], function() {

    /**
     * PromoSetsCollection
     * 
     * @extends Collection
     */
    window.PromoSetsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('PromoSet'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoSetsCollection')
         */
        _string: 'PromoSetsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourceFeaturesCollection', 'QuoteFeatureModel'], function() {

    /**
     * QuoteFeaturesCollection
     * 
     * @extends ResourceFeaturesCollection
     */
    window.QuoteFeaturesCollection = ResourceFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('QuoteFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteFeaturesCollection')
         */
        _string: 'QuoteFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['ResourcesCollection', 'QuoteResourceModel'], function() {

    /**
     * QuoteResourcesCollection
     * 
     * @extends ResourcesCollection
     */
    window.QuoteResourcesCollection = ResourcesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('QuoteResource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteResourcesCollection')
         */
        _string: 'QuoteResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection'], function() {

    /**
     * ResourceFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.ResourceFeaturesCollection = FeaturesCollection.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceFeaturesCollection')
         */
        _string: 'ResourceFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * This sort method is designed specifically for collections that may
         * include resource accessors (eg. photos, graphics, quotes). It's
         * needed because when a resource is added to a collection (including an
         * area favorites category/collection), the previous sort method would
         * check whether the key of a resource (eg. Pexels:1234) was included in
         * the _syncedFeatures array. This would invariably be false, since it's
         * the asset that would be in there.
         * 
         * Therefore, needed to loop over the accessors, and if it was a
         * ResourceAccessor or QuoteResourceAccessor, lookup the asset, and do
         * the search in the _syncedFeatures array within that.
         * 
         * @see     https://github.com/onassar/Stencil/blob/9cbc58f42361ee2ddbdeb53c54fd5c64ae2fda75/TurtlePHP/application/webroot/app/static/js/collections/QuoteFeatures.js
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {
            var accessors = this.all(),
                categoryContainsSyncedFeatures = function() {
                    if (accessors.length > 0) {
                        var featureObjects = [],
                            index,
                            accessor,
                            assetLookupClasses = [
                                'QuoteResourceAccessor',
                                'ResourceAccessor'
                            ];
                        for (index in accessors) {
                            accessor = accessors[index];
                            if (assetLookupClasses.indexOf(accessor.toString()) !== -1) {
                                featureObjects.push(accessor.getAsset());
                            } else {
                                featureObjects.push(accessor);
                            }
                        }
                        return category.syncedFeatures.contains.apply(category, [featureObjects]) === true;
                    }
                    return category.syncedFeatures.contains.apply(category, [accessors]) === true;
                };
            if (categoryContainsSyncedFeatures() === false) {
                category.unbind('syncedFeatures/add');
                category.once({
                    'syncedFeatures/add': this.sort.proxy(this, [category])
                });
            } else {
                this._super(category);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'ResourceModel'], function() {

    /**
     * ResourcesCollection
     * 
     * @extends Collection
     */
    window.ResourcesCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Resource'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourcesCollection')
         */
        _string: 'ResourcesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection', 'TemplateFeatureModel'], function() {

    /**
     * TemplateFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.TemplateFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('TemplateFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateFeaturesCollection')
         */
        _string: 'TemplateFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * sort
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        sort: function(category) {
            var accessors = this.all();
            if (category.syncedFeatures.contains.apply(category, [accessors]) === false) {
                category.unbind('syncedFeatures/add');
                category.once({
                    'syncedFeatures/add': this.sort.proxy(this, [category])
                });
            } else {
                this._super(category);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['FeaturesCollection', 'UploadFeatureModel'], function() {

    /**
     * UploadFeaturesCollection
     * 
     * @extends FeaturesCollection
     */
    window.UploadFeaturesCollection = FeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('UploadFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadFeaturesCollection')
         */
        _string: 'UploadFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'UploadModel'], function() {

    /**
     * UploadsCollection
     * 
     * @extends Collection
     */
    window.UploadsCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Upload'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadsCollection')
         */
        _string: 'UploadsCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['Collection', 'UserModel'], function() {

    /**
     * UsersCollection
     * 
     * @extends Collection
     */
    window.UsersCollection = Collection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('User'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UsersCollection')
         */
        _string: 'UsersCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['UploadFeaturesCollection', 'WatermarkFeatureModel'], function() {

    /**
     * WatermarkFeaturesCollection
     * 
     * @extends UploadFeaturesCollection
     */
    window.WatermarkFeaturesCollection = UploadFeaturesCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('WatermarkFeature'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkFeaturesCollection')
         */
        _string: 'WatermarkFeaturesCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * usable
         * 
         * @access  public
         * @return  Array
         */
        usable: function() {
            return this.filter(function(index, accessor) {
                return accessor.get('usable').toInt() === 1;
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires(['UploadsCollection', 'WatermarkModel'], function() {

    /**
     * WatermarksCollection
     * 
     * @extends UploadsCollection
     */
    window.WatermarksCollection = UploadsCollection.extend({

        /**
         * _model
         * 
         * @access  protected
         * @var     Model
         */
        _model: Stencil.getModel('Watermark'),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarksCollection')
         */
        _string: 'WatermarksCollection',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * usable
         * 
         * @access  public
         * @return  Array
         */
        usable: function() {
            return this.filter(function(index, accessor) {
                return accessor.get('usable').toInt() === 1;
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * AccountsController
     * 
     * @extends AppController
     */
    window.AccountsController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * checkout
         * 
         * @access  public
         * @param   String plan
         * @param   Object params
         * @return  void
         */
        checkout: function(plan, params) {
            var type = 'direct';
            if (params.curtain) {
                type = 'curtain';
            }
            if (Account.guest() === true) {
                var path = '/app/signup?',
                    redirect = '/app/checkout/' + (plan);
                if (type === 'curtain') {
                    path += 'curtain&';
                    redirect += '?curtain';
                }
                redirect = encodeURIComponent(redirect);
                path += 'redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (
                    Account.upgraded() === true
                    || User.admin() === true
                    || User.editor() === true
                ) {
                    App.getElement().removeClass('curtain');
                    Stencil.navigate('/app/only/free');
                } else {
                    this.track.event({
                        _plan: plan,
                        _type: type
                    });
                    this.track.page();
                    Modals.closeExcept(['Checkout']);
                    Modals.get('Checkout') || Modals.showCheckout(plan, type);
                    App.unrestrict();
                }
            }
        },

        /**
         * connections
         * 
         * @access  public
         * @param   String network
         * @param   Object params
         * @return  void
         */
        connections: function(type, params) {
            if (Account.guest() === true) {
                var path = '/app/login',
                    redirect = '/app/settings/' + (type) + '/connected';
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.closeExcept(['Settings']);
                var modal = Modals.get('Settings') || Modals.showSettings();
                modal.getSettings('social').show();
                Modals.showConnections(type);
                App.unrestrict();
            }
        },

        /**
         * countdown
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        countdown: function(params) {
            if (
                (
                    Account.upgraded() === true
                    && Stencil.account().get('monthlyMaxImages').toInt() === 0
                )
                || User.admin() === true
                || User.editor() === true
            ) {
                Stencil.navigate('/app/not/upgraded');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.showCountdown(params.onboard !== undefined);
                App.unrestrict();
            }
        },

        /**
         * plan
         * 
         * @access  public
         * @var     Object
         */
        plan: {

            /**
             * switch
             * 
             * @access  public
             * @param   String plan
             * @param   Object params
             * @return  void
             */
            switch: function(plan, params) {
                this.track.event();
                this.track.page();
                Modals.closeExcept(['Settings']);
                var modal = Modals.get('Settings') || Modals.showSettings();
                modal.getSettings('plan').show();
                Modals.showPlanSwitch(plan);
                App.unrestrict();
            },

            /**
             * switched
             * 
             * @access  public
             * @param   String plan
             * @param   Object data
             * @param   Object params
             * @return  void
             */
            switched: function(plan, data, params) {
                this.track.event();
                this.track.page();
                Modals.closeExcept(['Settings']);
                var modal = Modals.get('Settings') || Modals.showSettings();
                modal.getSettings('plan').show();
                Modals.showPlanSwitched(plan, data);
                App.unrestrict();
            }
        },

        /**
         * plans
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        plans: function(params) {
            // if (
            //     (
            //         Account.upgraded() === true
            //         && Account.plan('unlimited') === true
            //     )
            //     || User.admin() === true
            // ) {
            //     Stencil.navigate('/app/not/upgraded');
            // } else
            {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.showPlans({
                    curtain: params.curtain !== undefined
                });
                App.unrestrict();
            }
        },

        /**
         * upgrade
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String plan
         * @param   String reason
         * @param   Object params
         * @return  void
         */
        upgrade: function(plan, reason, params) {
            // if (
            //     Account.upgraded() === true
            //     || User.admin() === true
            // ) {
            //     Stencil.navigate('/app/not/upgraded');
            // } else
            {
                this.track.event({
                    _plan: plan,
                    _reason: reason
                });
                this.track.page();
                if (params.additive === undefined) {
                    Modals.close();
                }
                Modals.showUpgrade(plan, reason);
                App.unrestrict();
            }
        },

        /**
         * upgraded
         * 
         * @access  public
         * @param   String plan
         * @param   Object params
         * @return  void
         */
        upgraded: function(plan, params) {
            if (Account.upgraded() === false) {
            // if (false) {
                Stencil.navigate('/app/only/upgraded');
            } else {
                this.track.event({
                    _plan: plan
                });
                this.track.page();
                Modals.closeExcept(['Upgraded']);
                Modals.get('Upgraded') || Modals.showUpgraded(plan);
                App.unrestrict();
            }
        },

        /**
         * welcomeTour
         * 
         * @access  public
         * @param   String step
         * @param   Object params
         * @return  void
         */
        welcomeTour: function(step, params) {
            if (params === undefined) {
                params = step;
                step = 1;
            }
            this.track.event({
                _step: step
            });
            this.track.page();
            Modals.closeExcept(['WelcomeTour']);
            var modal = Modals.get('WelcomeTour') || Modals.showWelcomeTour();
            modal.step(step);
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * AdminController
     * 
     * @extends AppController
     */
    window.AdminController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * reimportAssets
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        reimportAssets: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/assets/reimport';
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    Modals.showAssetsReimport();
                    App.unrestrict();
                }
            }
        },

        /**
         * cacheRefresh
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        cacheRefresh: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/cache/refresh';
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    Modals.showCacheRefresh();
                    App.unrestrict();
                }
            }
        },

        /**
         * section
         * 
         * @access  public
         * @param   String section
         * @param   Object params
         * @return  void
         */
        section: function(section, params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/' + (section);
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (
                    User.admin() === false
                    && User.editor() === false
                ) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event({
                        _section: section
                    });
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection(section).show();
                    App.unrestrict();
                }
            }
        },

        /**
         * images
         * 
         * @access  public
         * @var     Object
         */
        images: {

            /**
             * results
             * 
             * @access  public
             * @param   String query
             * @param   Object params
             * @return  void
             */
            results: function(query, params) {
                if (typeof query === 'object') {
                    params = query;
                    query = '';
                }
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/images';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (
                        User.admin() === false
                        && User.editor() === false
                    ) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event({
                            _query: query
                        });
                        this.track.page();
                        Modals.closeExcept(['Admin']);
                        var modal = Modals.get('Admin') || Modals.showAdmin();
                        modal.getSection('images').show(query);
                        // modal.getSection('users').unload();
                        // modal.getSection('users').load(query);
                        App.unrestrict();
                    }
                }
            }
        },

        /**
         * users
         * 
         * @access  public
         * @var     Object
         */
        users: {

            /**
             * results
             * 
             * @access  public
             * @param   String query
             * @param   Object params
             * @return  void
             */
            results: function(query, params) {
                if (typeof query === 'object') {
                    params = query;
                    query = '';
                }
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/users';
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event({
                            _query: query
                        });
                        this.track.page();
                        Modals.closeExcept(['Admin']);
                        var modal = Modals.get('Admin') || Modals.showAdmin();
                        modal.getSection('users').show(query);
                        // modal.getSection('users').unload();
                        // modal.getSection('users').load(query);
                        App.unrestrict();
                    }
                }
            },

            /**
             * search
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            search: function(params) {
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/users/search';
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event();
                        this.track.page();
                        Modals.closeExcept(['Admin']);
                        var modal = Modals.get('Admin') || Modals.showAdmin(),
                            section = modal.getSection('users'),
                            query = section.getQuery();
                        section.show(query);
                        Modals.showSearchUsers(section);
                        App.unrestrict();
                    }
                }
            },

            /**
             * update
             * 
             * @access  public
             * @param   String key
             * @param   Object params
             * @return  void
             */
            update: function(key, params) {
                if (User.exists() === false) {
                    var path = '/app/login',
                        redirect = '/app/admin/users/' + (key);
                    path += '?redirect=' + (redirect);
                    redirect = encodeURIComponent(redirect);
                    Stencil.navigate(path);
                } else {
                    if (User.admin() === false) {
                        Stencil.navigate('/app/only/admin');
                    } else {
                        this.track.event();
                        this.track.page();
                        Modals.closeExcept(['Admin']);

                        // 
                        var show = function(user) {
                            var modal = Modals.get('Admin') || Modals.showAdmin(),
                                section = modal.getSection('users'),
                                query = section.getQuery();
                            section.show(query || '');
                            Modals.showUpdateUser(key, section);
                            App.unrestrict();
                        };

                        // 
                        var user = Stencil.getAccessor(key);
                        if (user === false) {
                            App.getBusy().show();
                            var model = Stencil.getModel('User');
                            model.read(key, function(data) {
                                App.getBusy().hide();
                                var user = model.setAccessor(data.object);
                                show(user);
                            });
                        } else {
                            show(user);
                        }
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Controller', function() {

    /**
     * AppController
     * 
     * @extends Controller
     */
    window.AppController = Controller.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * _getRouter
         * 
         * @access  protected
         * @return  Router
         */
        _getRouter: function() {
            return Stencil.getRouter();
        },

        /**
         * _store
         * 
         * Stores the path currently being experienced.
         * 
         * @access  protected
         * @return  void
         */
        _store: function() {
            var path = '/' + (this._getRouter().current().fragment);
            this._getRouter().setPrevious(path);
        },

        /**
         * alert
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String code
         * @param   Object params
         * @return  void
         */
        alert: function(code, params) {
            if (Stencil.get('alive') === true) {
                this.track.event({
                    _code: code
                });
                this.track.page();
            }
            Alerts.show(code);
            App.unrestrict();
        },

        /**
         * browser
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        browser: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.show('Browser');
            App.unrestrict();
        },

        /**
         * chromeSuccess
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        chromeSuccess: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.showChromeExtensionInstalled();
            App.unrestrict();
        },

        /**
         * cookies
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        cookies: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.show('Cookies');
            App.unrestrict();
        },

        /**
         * error
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        error: function(params) {
            this.track.event({
                _code: params.code,
                _reference: params.reference
            });
            this.track.page();
            Modals.close();
            Modals.show('Error', {
                code: params.code,
                reference: params.reference
            });
            App.unrestrict();
        },

        /**
         * extras
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        extras: function(params) {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.showExtras();
            App.unrestrict();
        },

        /**
         * googleFonts
         * 
         * @access  public
         * @return  void
         */
        googleFonts: function() {
            this.track.event();
            this.track.page();
            Modals.close();
            Modals.showGoogleFonts().show();
            App.unrestrict();
        },

        /**
         * legacy
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        legacy: function(params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.show('Legacy');
                App.unrestrict();
            }
        },

        /**
         * orientation
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        orientation: function(params) {
            this.track.event();
            this.track.page();
            Modals.show('Orientation');
            App.unrestrict();
        },

        /**
         * track
         * 
         * @access  public
         * @var     Object
         */
        track: {

            /**
             * event
             * 
             * Tracks an event relative to the current controller/action.
             * 
             * @access  protected
             * @param   undefined|Object properties
             * @return  void
             */
            event: function(properties) {
                var name = Stencil.getRouter().current().route.toString();
                Track.event(name, properties || {});
            },

            /**
             * page
             * 
             * Tracks an page relative to the current controller/action.
             * 
             * @access  protected
             * @return  void
             */
            page: function() {
                var path = Backbone.history.fragment;
                Track.page('/' + path);
            }
        },

        /**
         * tutorials
         * 
         * @access  public
         * @param   String slug
         * @param   Object params
         * @return  void
         */
        tutorials: function(slug, params) {
            var tutorials = Config.get('tutorials'),
                valid = function(slug) {
                    for (var index in tutorials) {
                        if (slug === tutorials[index].slug) {
                            return true;
                        }
                    }
                    return false;
                };
            if (valid(slug) === false) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                this.track.event({
                    _slug: slug
                });
                this.track.page();
                Modals.close();
                Modals.closeExcept(['Tutorials']);
                var modal = Modals.get('Tutorials') || Modals.showTutorials();
                modal.getTutorials(slug).show();
                App.unrestrict();
            }
        },

        /**
         * wildcard
         * 
         * @access  public
         * @param   String fragment
         * @param   Object params
         * @return  void
         */
        wildcard: function(fragment, params) {
            var redirects = Stencil.getRouter().getRedirects(),
                index,
                regEx,
                path = '/app';
            for (index in redirects) {
                regEx = new RegExp(index, 'i');
                if (regEx.test(fragment) === true) {
                    path = '/' + (fragment.replace(regEx, redirects[index]));
                    break;
                }
            }
            Backbone.history.navigate(
                path,
                {
                    trigger: true,
                    replace: true
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * AreasController
     * 
     * @extends AppController
     */
    window.AreasController = AppController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _areaType: false,

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * collection
         * 
         * @access  public
         * @param   String slug
         * @param   Object params
         * @return  void
         */
        collection: function(slug, params) {
            var type = this._areaType,
                lookupProperties = {
                    custom: 1,
                    slug: slug
                };
            lookupProperties[type] = 1;
            var category = Categories.account.one(lookupProperties);
            if (category === false) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug,
                    _custom: 1
                });
                this.track.page();
                var key = category.get('key');
                App.getEditor().getArea(type).getChild('categories').getChild(key).show();
                Modals.close();
                App.unrestrict();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * CategoriesController
     * 
     * @extends AppController
     */
    window.CategoriesController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        add: function(params) {
            if (User.exists() === false) {
                var redirect = '/app/admin/categories/add';
                Stencil.navigate('/app/login?redirect=' + (redirect));
            } else {
                if (
                    User.admin() === false
                    && User.editor() === false
                ) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection('categories').show();
                    Modals.showAddCategory();
                    App.unrestrict();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Class', function() {

    /**
     * Controller
     * 
     * @extends Class
     */
    window.Controller = Class.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * CouponsController
     * 
     * @extends AppController
     */
    window.CouponsController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        add: function(params) {
            if (User.exists() === false) {
                var path = '/app/login',
                    redirect = '/app/admin/coupons/add';
                redirect = encodeURIComponent(redirect);
                path += '?redirect' + (redirect);
                Stencil.navigate(path);
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection('coupons').show();
                    Modals.showAddCoupon();
                    App.unrestrict();
                }
            }
        },

        /**
         * apply
         * 
         * @access  public
         * @param   String plan
         * @param   String code
         * @param   Object params
         * @return  void
         */
        apply: function(plan, code, params) {
            if (typeof code === 'object') {
                params = code;
                code = false;
            }
            if (Account.guest() === true) {
                var path = '/app/signup?',
                    redirect = '/app/checkout/' + (plan) + '/coupon';
                if (code !== false) {
                    redirect += '/' + (code);
                }
                if (location.href.match(/curtain/) !== null) {
                    path += 'curtain&';
                    redirect += '?curtain';
                }
                redirect = encodeURIComponent(redirect);
                path += 'redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                if (Account.upgraded() === true) {
                    Stencil.navigate('/app/only/free');
                } else {
                    // this._store();
                    if (code === false) {
                        // params = code;
                        // code = false;
                        this.track.event({
                            _plan: plan
                        });
                    } else {
                        this.track.event({
                            _plan: plan,
                            _code: code
                        });
                    }
                    this.track.page();
                    Modals.closeExcept(['Checkout']);

                    // Grab checkout modal or open a new one
                    var type = 'direct';
                    if (params.curtain) {
                        type = 'curtain';
                    }
                    var modal = Modals.get('Checkout') || Modals.showCheckout(plan, type);

                    // Throw in the code if it's defined
                    if (code) {
                        Modals.showApplyCoupon(modal, code);
                    } else {
                        Modals.showApplyCoupon(modal);
                    }

                    // Ensure the app is not blocked with the busy modal
                    App.unrestrict();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreasController', function() {

    /**
     * GraphicsController
     * 
     * @extends AreasController
     */
    window.GraphicsController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'graphics')
         */
        _areaType: 'graphics',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = Categories.universal.all({
                graphics: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/icons';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = Categories.universal.all({
                        graphics: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app/icons';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('graphics').getChild('categories').getChild(key).show();
                    Modals.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Object params
         * @return  void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('graphics').getChild('queries').getChild(query).show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreasController', function() {

    /**
     * ImagesController
     * 
     * @extends AreasController
     */
    window.ImagesController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'images')
         */
        _areaType: 'images',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'all';
            }
            var categories = Categories.universal.all({
                images: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/saved';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'all') {
                            custom = 1;
                        }
                    }
                    categories = Categories.universal.all({
                        images: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'all' && category.get('custom').toInt() === 0) {
                    var path = '/app/saved';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('images').getChild('categories').getChild(key).show();
                    Modals.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * error
         * 
         * @note    Only accessed via ?clean=1
         * @note    Action logic isn't wrapped in record-lookup since this can
         *          currently only be accessed from within the app and a
         *          conventional flow. If this page needed to be accessed
         *          statically, then I'd need a lookup (for when it's accessed
         *          directly).
         * @access  public
         * @param   String key
         * @param   String connection
         * @param   Object params
         * @return  void
         */
        error: function(key, connection, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key,
                    _connection: connection
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var image = Stencil.getAccessor(key),
                    connection = Stencil.getAccessor(connection),
                    modal = Modals.get('Share') || Modals.showShare(image);
                modal.getNetwork(connection.get('network')).show();
                Modals.showShareError(modal, image, connection);
                App.unrestrict();
            }
        },

        /**
         * mobile
         * 
         * @access  public
         * @var     Object
         */
        mobile: {

            /**
             * confirm
             * 
             * @access  public
             * @param   String key
             * @param   String mobile
             * @param   Object params
             * @return  void
             */
            confirm: function(key, mobile, params) {
                if (Account.guest() === true) {
                    Stencil.navigate('/app/not/guests');
                } else {
                    this.track.event({
                        _key: key
                    });
                    this.track.page();
                    Modals.closeExcept(['Share']);
                    var image = Stencil.getAccessor(key),
                        modal = Modals.get('Share') || Modals.showShare(image);
                    modal.getNetwork('instagram').show(false);
                    modal = Modals.showConfirmMobile(modal, image);
                    modal.getElement().focusable().focus();
                    App.unrestrict();
                }
            }
        },

        /**
         * normalize
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        normalize: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                Modals.close();
                Modals.showLegacyImageNormalize(key);
                App.unrestrict();
            }
        },

        /**
         * sent
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        sent: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var image = Stencil.getAccessor(key),
                    modal = Modals.get('Share') || Modals.showShare(image);
                modal.getNetwork('instagram').show(false);
                Modals.showSent(modal, image);
                App.unrestrict();
            }
        },

        /**
         * share
         * 
         * @access  public
         * @param   String key
         * @param   String network
         * @param   Object params
         * @return  void
         */
        share: function(key, network, params) {
            if (Account.guest() === true) {
                var path = '/app/login',
                    redirect = '/app/images/' + (key) + '/share/' + (network);
                redirect = encodeURIComponent(redirect);
                path += '?redirect=' + (redirect);
                Stencil.navigate(path);
            } else {
                var show = function(image) {
                    var modal = Modals.get('Share') || Modals.showShare(image);
                    modal.getNetwork(network).show();
                    App.unrestrict();
                };
                this.track.event({
                    _key: key,
                    _network: network
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var image = Stencil.getAccessor(key);
                if (image === false) {
                    App.getBusy().show();
                    var model = Stencil.getModel('Image');
                    model.read(key, function(data) {
                        App.getBusy().hide();
                        var image = model.setAccessor(data.object);
                        show(image);
                    });
                } else {
                    show(image);
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreasController', function() {

    /**
     * PhotosController
     * 
     * @extends AreasController
     */
    window.PhotosController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'photos')
         */
        _areaType: 'photos',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = Categories.universal.all({
                photos: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = Categories.universal.all({
                        photos: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('photos').getChild('categories').getChild(key).show();
                    Modals.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Object params
         * @return  void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('photos').getChild('queries').getChild(query).show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * PromoSetsController
     * 
     * @extends AppController
     */
    window.PromoSetsController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * add
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        add: function(params) {
            if (User.exists() === false) {
                var redirect = '/app/admin/promoSets/add';
                Stencil.navigate('/app/login?redirect=' + (redirect));
            } else {
                if (User.admin() === false) {
                    Stencil.navigate('/app/only/admin');
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Admin']);
                    var modal = Modals.get('Admin') || Modals.showAdmin();
                    modal.getSection('promoSets').show();
                    Modals.showAddPromoSet();
                    App.unrestrict();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreasController', function() {

    /**
     * QuotesController
     * 
     * @extends AreasController
     */
    window.QuotesController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'quotes')
         */
        _areaType: 'quotes',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = Categories.universal.all({
                quotes: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/quotes';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = Categories.universal.all({
                        quotes: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app/quotes';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('quotes').getChild('categories').getChild(key).show();
                    Modals.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Object params
         * @return  void
         */
        search: function(query, params) {
            this._store();
            this.track.event({
                _query: query
            });
            this.track.page();
            App.getEditor().getArea('quotes').getChild('queries').getChild(query).show();
            Modals.close();
            App.unrestrict();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * SharesController
     * 
     * @extends AppController
     */
    window.SharesController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * success
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        success: function(key, params) {
            if (Account.guest() === true) {
                Stencil.navigate('/app/not/guests');
            } else {
                this.track.event({
                    _key: key
                });
                this.track.page();
                Modals.closeExcept(['Share']);
                var share = Stencil.getAccessor(key),
                    connection = share.reference('connection'),
                    image = share.reference('image'),
                    modal = Modals.get('Share') || Modals.showShare(image);
                modal.getNetwork(connection.get('network')).show();
                Modals.showShareSuccess(modal, share);
                App.unrestrict();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreasController', function() {

    /**
     * TemplatesController
     * 
     * @extends AreasController
     */
    window.TemplatesController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'templates')
         */
        _areaType: 'templates',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'featured';
            }
            var categories = Categories.universal.all({
                templates: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/templates';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'featured') {
                            custom = 1;
                        }
                    }
                    categories = Categories.universal.all({
                        templates: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'featured' && category.get('custom').toInt() === 0) {
                    var path = '/app/templates';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('templates').getChild('categories').getChild(key).show();
                    Modals.close();
                    App.unrestrict();
                }
            }
        },

        /**
         * preview
         * 
         * @access  public
         * @param   String key
         * @param   Object params
         * @return  void
         */
        preview: function(key, params) {
            var start = new Date(),
                show = function(template) {
                    var url = template.getPreviewThumbImageUrl();
                    if (Images.preloaded(url) === true) {
                        Modals.showTemplatePreview(template);
                        App.unrestrict();
                    } else {
                        Images.preload([url], function() {
                            (function() {
                                Modals.showTemplatePreview(template);
                                App.unrestrict();
                            }).minDelay(start, 1500);
                        });
                    }
                };
            this.track.event({
                _key: key
            });
            this.track.page();
            Modals.closeExcept(['TemplatePreview']);
            App.unrestrict();
            var msg = Stencil.getMessage('template.preview.loading');
            App.getBusy().show(msg);
            var template = Stencil.getAccessor(key);
            if (template === false) {
                // App.getBusy().show();
                var model = Stencil.getModel('Template');
                model.read(key, function(data) {
                    // App.getBusy().hide();
                    var template = model.setAccessor(data.object);
                    show(template);
                });
            } else {
                show(template);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreasController', function() {

    /**
     * UploadsController
     * 
     * @extends AreasController
     */
    window.UploadsController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'uploads')
         */
        _areaType: 'uploads',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'all';
            }
            var categories = Categories.universal.all({
                uploads: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/uploads';
                Stencil.navigate(path);
            } else {
                var category = categories[0];
                if (categories.length > 1) {
                    var custom = 0;
                    if (arguments.length >= 2) {
                        if (slug === 'all') {
                            custom = 1;
                        }
                    }
                    categories = Categories.universal.all({
                        uploads: 1,
                        slug: slug,
                        custom: custom
                    });
                    category = categories[0];
                }
                if (arguments.length >= 2 && slug === 'all' && category.get('custom').toInt() === 0) {
                    var path = '/app/uploads';
                    Stencil.navigate(path);
                } else {
                    this._store();
                    this.track.event({
                        _category: slug
                    });
                    this.track.page();
                    var key = category.get('key');
                    App.getEditor().getArea('uploads').getChild('categories').getChild(key).show();
                    Modals.close();
                    App.unrestrict();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppController', function() {

    /**
     * UsersController
     * 
     * @extends AppController
     */
    window.UsersController = AppController.extend({

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * delinquent
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        delinquent: function(params) {
            if (User.exists() === false) {
                Stencil.navigate('/app/only/upgraded');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.show('Delinquent');
                App.unrestrict();
            }
        },

        /**
         * login
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        login: function(params) {
            if (User.exists() === true) {
                if (params.redirect) {
                    Stencil.navigate(params.redirect);
                } else {
                    App.getElement().removeClass('curtain');
                    Stencil.navigate('/app/only/guests');
                }
            } else {
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.close();
                Modals.showLogin(type, params.redirect || false);
                App.unrestrict();
            }
        },

        /**
         * onboard
         * 
         * @note    Only accessed via ?clean=1
         * @access  public
         * @param   Object params
         * @return  void
         */
        onboard: function(params) {
            if (User.exists() === false) {
                Stencil.navigate('/app/only/users');
            } else {
                this.track.event();
                this.track.page();
                Modals.close();
                Modals.showOnboard();
                App.unrestrict();
            }
        },

        /**
         * password
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        password: function(params) {
            if (User.exists() === true) {
                App.getElement().removeClass('curtain');
                Stencil.navigate('/app/only/guests');
            } else {
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.close();
                Modals.showPassword(type, params.redirect || false);
                App.unrestrict();
            }
        },

        /**
         * promo
         * 
         * @access  public
         * @param   String|undefined partner
         * @param   Object params
         * @return  void
         */
        promo: function(partner, params) {
            if (typeof partner === 'object') {
                params = partner;
                partner = false;
            }
            var type = 'direct';
            if (params.curtain) {
                type = 'curtain';
            }
            this.track.event({
                _type: type
            });
            this.track.page();
            Modals.close();
            Modals.showPromo(partner, type, params.redirect || false);
            App.unrestrict();
        },

        /**
         * settings
         * 
         * @access  public
         * @var     Object
         */
        settings: {

            /**
             * notifications
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            notifications: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/notifications';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('notifications').show();
                    App.unrestrict();
                }
            },

            /**
             * obfuscate
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            obfuscate: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/delete';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('obfuscate').show();
                    App.unrestrict();
                }
            },

            /**
             * password
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            password: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/password';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('password').show();
                    App.unrestrict();
                }
            },

            /**
             * payment
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            payment: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/payment';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (Account.upgraded() === false) {
                        Stencil.navigate('/app/settings/profile');
                    } else {
                        if (Account.promo() === true) {
                            Stencil.navigate('/app/settings/profile');
                        } else {
                            this.track.event();
                            this.track.page();
                            Modals.closeExcept(['Settings']);
                            var modal = Modals.get('Settings') || Modals.showSettings();
                            modal.getSettings('payment').show();
                            App.unrestrict();
                        }
                    }
                }
            },

            /**
             * plan
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            plan: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/plan';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('plan').show();
                    App.unrestrict();
                }
            },

            /**
             * profile
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            profile: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/profile';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('profile').show();
                    App.unrestrict();
                }
            },

            /**
             * referral
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            referral: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/referral';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    if (Account.upgraded() === false) {
                        Stencil.navigate('/app/settings/profile');
                    } else {
                        if (Account.promo() === true) {
                            Stencil.navigate('/app/settings/profile');
                        } else {
                            this.track.event();
                            this.track.page();
                            Modals.closeExcept(['Settings']);
                            var modal = Modals.get('Settings') || Modals.showSettings();
                            modal.getSettings('referral').show();
                            App.unrestrict();
                        }
                    }
                }
            },

            /**
             * social
             * 
             * @access  public
             * @param   Object params
             * @return  void
             */
            social: function(params) {
                if (Account.guest() === true) {
                    var path = '/app/login',
                        redirect = '/app/settings/social';
                    redirect = encodeURIComponent(redirect);
                    path += '?redirect=' + (redirect);
                    Stencil.navigate(path);
                } else {
                    this.track.event();
                    this.track.page();
                    Modals.closeExcept(['Settings']);
                    var modal = Modals.get('Settings') || Modals.showSettings();
                    modal.getSettings('social').show();
                    App.unrestrict();
                }
            }
        },

        /**
         * signup
         * 
         * @access  public
         * @param   Object params
         * @return  void
         */
        signup: function(params) {
            if (User.exists() === true) {
                App.getElement().removeClass('curtain');
                Stencil.navigate('/app/only/guests');
            } else {
                var type = 'direct';
                if (params.save) {
                    type = 'save';
                } else if (params.upgrade) {
                    type = 'upgrade';
                } else if (params.checkout) {
                    type = 'checkout';
                } else if (params.curtain) {
                    type = 'curtain';
                }
                this.track.event({
                    _type: type
                });
                this.track.page();
                Modals.close();
                Modals.showSignup(type, params.redirect || false);
                App.unrestrict();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreasController', function() {

    /**
     * WatermarksController
     * 
     * @extends AreasController
     */
    window.WatermarksController = AreasController.extend({

        /**
         * _areaType
         * 
         * @access  protected
         * @var     String (default: 'watermarks')
         */
        _areaType: 'watermarks',

        /**
         * init
         * 
         * @access  public
         * @return  void
         */
        init: function() {
            this._super();
        },

        /**
         * category
         * 
         * @access  public
         * @param   String slug (optional)
         * @param   Object params
         * @return  void
         */
        category: function(slug, params) {
            if (typeof slug === 'object') {
                params = slug;
                slug = 'all';
            }
            var categories = Categories.universal.all({
                watermarks: 1,
                slug: slug
            });
            if (categories.length === 0) {
                var path = '/app/logos';
                Stencil.navigate(path);
            } else {
                this._store();
                this.track.event({
                    _category: slug
                });
                this.track.page();
                var key = categories[0].get('key');
                App.getEditor().getArea('watermarks').getChild('categories').getChild(key).show();
                Modals.close();
                App.unrestrict();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminCategoriesView
     * 
     * @extends AdminSectionView
     */
    window.AdminCategoriesView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|CategoriesCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _more: true,

        /**
         * _section
         * 
         * @access  protected
         * @var     String (default: 'categories')
         */
        _section: 'categories',

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCategoriesView')
         */
        _string: 'AdminCategoriesView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawCategory
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @param   Number position
         * @return  void
         */
        _drawCategory: function(category, position) {
            var $row = DataUtils.render('AdminCategoryRow', {
                category: category
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminCategoryRowView($row, category);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new CategoriesCollection();
            this._collection.on({
                'add': function(event, category, position) {
                    _this._drawCategory(category, position);
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this;
            this._collection.list({
                limit: Config.default('objectsPerPage').admin.categories,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                this.trackLoad();
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminCategoryRowView
     * 
     * @extends View
     */
    window.AdminCategoryRowView = View.extend({

        /**
         * _category
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCategoryRowView')
         */
        _string: 'AdminCategoryRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, category) {
            this._super(element);
            this._category = category;
            this._setupTooltips();
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._category.on({
                'delete': function(event) {
                    // var collection = Modals.get('Admin').getSection('categories')._collection;
                    _this._element.remove();
                    // collection.remove(_this._category);
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this category?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function(event) {
                    _this._category.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminCouponRowView
     * 
     * @extends View
     */
    window.AdminCouponRowView = View.extend({

        /**
         * _coupon
         * 
         * @access  protected
         * @var     null|CouponAccessor (default: null)
         */
        _coupon: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $checkbox
                     * @return  void
                     */
                    'input[type="checkbox"]': function(event, $checkbox) {
                        var checked = $checkbox.prop('checked');
                        if (checked === true) {
                            this._coupon.set({
                                'active': 1
                            });
                        } else {
                            this._coupon.set({
                                'active': 0
                            });
                        }
                        this._coupon.save(['active']);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCouponRowView')
         */
        _string: 'AdminCouponRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CouponAccessor coupon
         * @return  void
         */
        init: function(element, coupon) {
            this._super(element);
            this._coupon = coupon;
            this._setupTooltips();
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._coupon.on({
                'delete': function(event) {
                    // var collection = Modals.get('Admin').getSection('coupons')._collection;
                    _this._element.remove();
                    // collection.remove(_this._coupon);
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this coupon?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function(event) {
                    _this._coupon.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminCouponsView
     * 
     * @extends AdminSectionView
     */
    window.AdminCouponsView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|CouponsCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _more: true,

        /**
         * _section
         * 
         * @access  protected
         * @var     String (default: 'coupons')
         */
        _section: 'coupons',

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminCouponsView')
         */
        _string: 'AdminCouponsView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawCoupon
         * 
         * @access  protected
         * @param   CouponAccessor coupon
         * @param   Number position
         * @return  void
         */
        _drawCoupon: function(coupon, position) {
            var $row = DataUtils.render('AdminCouponRow', {
                coupon: coupon
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminCouponRowView($row, coupon);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new CouponsCollection();
            this._collection.on({
                'add': function(event, coupon, position) {
                    _this._drawCoupon(coupon, position);
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this;
            this._collection.list({
                limit: Config.default('objectsPerPage').admin.coupons,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                this.trackLoad();
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminDashboardView
     * 
     * @extends AdminSectionView
     */
    window.AdminDashboardView = AdminSectionView.extend({

        /**
         * _section
         * 
         * @access  protected
         * @var     String (default: 'dashboard')
         */
        _section: 'dashboard',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminDashboardView')
         */
        _string: 'AdminDashboardView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminImageRowView
     * 
     * @extends View
     */
    window.AdminImageRowView = View.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminImageRowView')
         */
        _string: 'AdminImageRowView',

        /**
         * _image
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _image: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Object image
         * @return  void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this.on({
                'open': function(event) {
                    var url = Images.s3(this._image.get('key'));
                    window.open(url);
                    // window.open(this._image.url('original'));
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminImagesView
     * 
     * @extends AdminSectionView
     */
    window.AdminImagesView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|ImagesCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _more: false,

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _section
         * 
         * @access  protected
         * @var     String (default: 'images')
         */
        _section: 'images',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminImagesView')
         */
        _string: 'AdminImagesView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 500)
         */
        _threshold: 500,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawImage
         * 
         * @access  protected
         * @param   ImageAccessor image
         * @param   Number position
         * @return  void
         */
        _drawImage: function(image, position) {
            var $row = DataUtils.render('AdminImageRow', {
                image: image
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminImageRowView($row, image);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new ImagesCollection();
            this._collection.on({
                'add': function(event, image, position) {
                    _this._drawImage(image, position);
                },
                'empty': function(event) {
                    _this.find('div.image').remove();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            // if (this._query === false || this._query === '') {
                return '/app/admin/images';
            // }
            // var encoded = encodeURIComponent(this._query);
            // return '/app/admin/images/search/' + (encoded);
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this;
            this._collection.list({
                all: 1,
                limit: Config.default('objectsPerPage').admin.images,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
            // if (this._query !== query) {
                this.unload();
                // this._query = query;
                this.trackLoad();
                this.load();
            }
        },

        /**
         * unload
         * 
         * @access  public
         * @return  void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminPromoSetRowView
     * 
     * @extends View
     */
    window.AdminPromoSetRowView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $checkbox
                     * @return  void
                     */
                    'input[type="checkbox"]': function(event, $checkbox) {
                        var checked = $checkbox.prop('checked');
                        if (checked === true) {
                            this._promoSet.set({
                                'active': 1
                            });
                        } else {
                            this._promoSet.set({
                                'active': 0
                            });
                        }
                        this._promoSet.save(['active']);
                    }
                }
            });
        },

        /**
         * _promoSet
         * 
         * @access  protected
         * @var     null|PromoSetAccessor (default: null)
         */
        _promoSet: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminPromoSetRowView')
         */
        _string: 'AdminPromoSetRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PromoSetAccessor promoSet
         * @return  void
         */
        init: function(element, promoSet) {
            this._super(element);
            this._promoSet = promoSet;
            this._setupTooltips();
            this.on({
                'download': function(event) {
                    var path = '/promoSets/' + (promoSet.get('key')) +
                        '/download';
                    window.open(path);
                },
                'downloadUnused': function(event) {
                    var path = '/promoSets/' + (promoSet.get('key')) +
                        '/download?unused=1';
                    window.open(path);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminPromoSetsView
     * 
     * @extends AdminSectionView
     */
    window.AdminPromoSetsView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|PromoSetsCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _more: true,

        /**
         * _section
         * 
         * @access  protected
         * @var     String (default: 'promoSets')
         */
        _section: 'promoSets',

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminPromoSetsView')
         */
        _string: 'AdminPromoSetsView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawPromoSet
         * 
         * @access  protected
         * @param   PromoSetAccessor promoSet
         * @param   Number position
         * @return  void
         */
        _drawPromoSet: function(promoSet, position) {
            var $row = DataUtils.render('AdminPromoSetRow', {
                promoSet: promoSet
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminPromoSetRowView($row, promoSet);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new PromoSetsCollection();
            this._collection.on({
                'add': function(event, promoSet, position) {
                    _this._drawPromoSet(promoSet, position);
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this;
            this._collection.list({
                limit: Config.default('objectsPerPage').admin.promoSets,
                offset: this._collection.all().length
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            if (this._loaded === false) {
                this.trackLoad();
                this.load();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminSectionView
     * 
     * @extends View
     */
    window.AdminSectionView = View.extend({

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|AdminModalView (default: null)
         */
        _modal: null,

        /**
         * _section
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _section: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminSectionView')
         */
        _string: 'AdminSectionView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[section="' + (this._section) + '"]');
            $anchor.siblings('[section]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            if (UserAgent.is.tablet() === false) {
                this._element.focusable().focus();
            }
        },

        /**
         * trackLoad
         * 
         * Tracks that results are being loaded.
         * 
         * @access  public
         * @return  void
         */
        trackLoad: function() {
            this._loaded = true;
            this._loading = true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AdminUserRowView
     * 
     * @extends View
     */
    window.AdminUserRowView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $checkbox
                     * @return  void
                     */
                    'input[type="checkbox"]': function(event, $checkbox) {
                        // event.preventDefault();
                        this._user.active().upgradeToPlan('unlimited');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminUserRowView')
         */
        _string: 'AdminUserRowView',

        /**
         * _user
         * 
         * @access  protected
         * @var     null|UserAccessor (default: null)
         */
        _user: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UserAccessor user
         * @return  void
         */
        init: function(element, user) {
            this._super(element);
            this._user = user;
            this._setupTooltips();
            this.on({
                'cancel': function(event) {
                    var active = this._user.active();
                    Modals.showCancelAccount(active);
                },
                'impersonate': function(event) {
                    var _this = this;
                    User.logout(function() {
                        var path = '/app?impersonate=1&secret=' +
                            _this._user.get('secret');
                        window.location.assign(path);
                    });
                },
                'show/update': function(event) {
                    var path = '/app/admin/users/' + (this._user.get('key'));
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AdminSectionView', function() {

    /**
     * AdminUsersView
     * 
     * @extends AdminSectionView
     */
    window.AdminUsersView = AdminSectionView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|UsersCollection (default: null)
         */
        _collection: null,

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _more: false,

        /**
         * _query
         * 
         * @access  protected
         * @var     String|false (default: false)
         */
        _query: false,

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load(this._query);
                        }
                    }
                }
            }
        },

        /**
         * _section
         * 
         * @access  protected
         * @var     String (default: 'users')
         */
        _section: 'users',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminUsersView')
         */
        _string: 'AdminUsersView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 100)
         */
        _threshold: 100,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupCollection();
            this._addInfiniteScrollEvents();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            this.find('div.content').first().bind(listener, check);
        },

        /**
         * _drawUser
         * 
         * @access  protected
         * @param   UserAccessor user
         * @param   Number position
         * @return  void
         */
        _drawUser: function(user, position) {
            var $row = DataUtils.render('AdminUserRow', {
                user: user
            });
            if (position === 0) {
                this.find('.inner').prepend($row);
            } else {
                this.find('.inner').append($row);
            }
            new AdminUserRowView($row, user);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new UsersCollection();
            this._collection.on({
                'add': function(event, user, position) {
                    _this._drawUser(user, position);
                },
                'empty': function(event) {
                    _this.find('div.user').remove();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._query === false || this._query === '') {
                return '/app/admin/users';
            }
            var encoded = encodeURIComponent(this._query);
            return '/app/admin/users/search/' + (encoded);
        },

        /**
         * getQuery
         * 
         * @access  public
         * @return  String
         */
        getQuery: function() {
            return this._query;
        },

        /**
         * load
         * 
         * @access  public
         * @param   String query
         * @return  void
         */
        load: function(query) {
            var _this = this;
            this._collection.list({
                limit: Config.default('objectsPerPage').admin.users,
                offset: this._collection.all().length,
                query: query
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
            });
        },

        /**
         * show
         * 
         * @access  public
         * @param   String query
         * @return  void
         */
        show: function(query) {
            this._super();
            if (this._query !== query) {
                this.unload();
                this._query = query;
                this.load(query);
            }
        },

        /**
         * unload
         * 
         * @access  public
         * @return  void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ColorPickerView
     * 
     * @extends View
     * @fires   change
     *          hide
     *          show
     *          minicolors/change
     *          minicolors/hide
     *          minicolors/show
     */
    window.ColorPickerView = View.extend({

        /**
         * _$input
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$input: null,

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|ColorsCollection (default: null)
         */
        _collection: null,

        /**
         * _colorSwatches
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _colorSwatches: [],

        /**
         * _eventsEnabled
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _eventsEnabled: true,

        /**
         * _eyeDropperEnabled
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _eyeDropperEnabled: false,

        /**
         * _options
         * 
         * @access  protected
         * @var     Object
         */
        _options: {

            /**
             * fallbackColor
             * 
             * @access  protected
             * @var     false|String (default: false)
             */
            fallbackColor: false,

            /**
             * openDirection
             * 
             * @access  protected
             * @var     String (default: 'down')
             */
            openDirection: 'down',

            /**
             * showOpacitySlider
             * 
             * @access  protected
             * @var     Boolean (default: true)
             */
            showOpacitySlider: true
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorPickerView')
         */
        _string: 'ColorPickerView',

        /**
         * _toolbar
         * 
         * @access  protected
         * @var     null|ToolbarView (default: null)
         */
        _toolbar: null,

        /**
         * _visible
         * 
         * Boolean state which tracks whether the color picker (including
         * minicolors itself) is visible to the client.
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _visible: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   jQuery $input
         * @param   ToolbarView toolbar
         * @param   undefined|Object options (default: {})
         * @return  void
         */
        init: function(element, $input, toolbar, options) {
            this._colorSwatches = [];
            options = DataUtils.getDefaultValue(options, {});
            this._toolbar = toolbar;
            this._options = DataUtils.merge(this._options, options);
            this._super(element);
            this._$input = $input;
            this._addEscapeKeyListener();
            this._setupMinicolors();
            this._setupMinicolorsEvents();
            this._setupToolbarEvents();
            this._rearrangeElements();
            this._setupCollection();
            this._drawColorSwatches();
            this._addAddColorListener();
            this._addEyeDropperListener();
            this._refreshButton();
        },

        /**
         * _addAddColorListener
         * 
         * @access  protected
         * @return  void
         */
        _addAddColorListener: function() {
            this.on({
                'addColor': function(event) {
                    if (this._collection.length() < 20) {
                        var rgbaColorStr = this.getColor();
                        if (rgbaColorStr !== false) {
                            this._collection.addColor(rgbaColorStr);
                            var $last = ArrayUtils.last(this._colorSwatches).getElement();
                            $last.addClass('fadeIn');
                            (function() {
                                $last.removeClass('fadeIn');
                            }).delay(950);
                        }
                    }
                }
            });
        },

        /**
         * _addEscapeKeyListener
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeKeyListener: function() {
            var _this = this,
                $app = App.getElement(),
                hide = {
                    'body/keydown/escape': function(event) {
                        if (event.which === 27) {
                            if (_this._visible === true) {
                                if (_this._eyeDropperEnabled === true) {
                                    _this.disableEyeDropper();
                                } else {
                                    _this._$input.minicolors('hide');
                                }
                            }
                        }
                    }
                };
            $app.on({
                'keydown': hide['body/keydown/escape']
            });
        },

        /**
         * _addEyeDropperListener
         * 
         * @access  protected
         * @return  void
         */
        _addEyeDropperListener: function() {
            this.on({
                'toggleEyeDropper': function(event, $element) {
                    this._toggleEyeDropper();
                }
            });
            var eyeDropper = this._getEyeDropper(),
                _this = this;
            eyeDropper.on({
                'disable': function(event) {
                    _this._eyeDropperEnabled = false;
                    var $eyedropper = _this.find('[lookup="eyedropper"]');
                    $eyedropper.removeClass('active');
                },
                'enable': function(event) {
                    _this._eyeDropperEnabled = true;
                    var $eyedropper = _this.find('[lookup="eyedropper"]');
                    $eyedropper.addClass('active');
                }
            });
        },

        /**
         * _destroyTooltips
         * 
         * @access  protected
         * @return  void
         */
        _destroyTooltips: function() {
            var $cta = this.find('.colorSwatch.cta'),
                $anchor = $cta.find('> a');
            $anchor.tooltip('destroy');
            this._element.tooltip('destroy');
        },

        /**
         * _drawColorSwatch
         * 
         * @access  protected
         * @param   ColorAccessor color
         * @param   Number position
         * @return  void
         */
        _drawColorSwatch: function(color, position) {
            var $colorSwatch = DataUtils.render('ColorSwatch', {
                    color: color
                }),
                colorSwatch = new ColorSwatchView($colorSwatch, this, color);
            this._colorSwatches.push(colorSwatch);
            if (position === 0) {
                var $first = this.find('.swatches').find('.colorSwatch').first();
                $colorSwatch.insertAfter($first);
            } else {
                this.find('.swatches').append($colorSwatch);
            }
        },

        /**
         * _drawColorSwatches
         * 
         * @access  protected
         * @return  void
         */
        _drawColorSwatches: function() {
            var _this = this;
            this._collection.each(function(index, color) {
                _this._drawColorSwatch(color, index);
            });
        },

        /**
         * _enableEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _enableEyeDropper: function() {
            if (this._eyeDropperEnabled === false) {
                var eyeDropper = this._getEyeDropper(),
                    _this = this;
                eyeDropper.on({
                    'preview': function(event, rgbaColorStr) {
                        _this.setColor(rgbaColorStr, false);
                        _this.triggerHandler('change', [rgbaColorStr]);
                    }
                });
                eyeDropper.once({
                    'select': function(event, rgbaColorStr) {
                        _this.setColor(rgbaColorStr);
                        _this.disableEyeDropper();
                    }
                });
                eyeDropper.enable();
            }
        },

        /**
         * _getColorKeywords
         * 
         * @access  protected
         * @return  Array
         */
        _getColorKeywords: function() {
            var colors = Config.get('colors'),
                spacedColors = ArrayUtils.insertSpacesIntoCamelCase(colors),
                merged = ArrayUtils.merge(colors, spacedColors);
            return merged;
        },

        /**
         * _getEyeDropper
         * 
         * @access  protected
         * @return  EyeDropperView
         */
        _getEyeDropper: function() {
            var stageContent = this._getStageContent(),
                eyeDropper = stageContent.getEyeDropper();
            return eyeDropper;
        },

        /**
         * _getStageContent
         * 
         * @access  protected
         * @return  StageContentView
         */
        _getStageContent: function() {
            var stageContent = this._toolbar.getToolbars().getStageContent();
            return stageContent;
        },

        /**
         * _rearrangeElements
         * 
         * @access  protected
         * @return  void
         */
        _rearrangeElements: function() {
            this.find('div.content').append(
                this._$input.nextAll('div.minicolors-panel')
            );
            this._element.insertAfter(this._$input);
            this.find('div.content div.grid').append(
                this.find('div.minicolors-grid')
            );
            this.find('div.content div.slider').append(
                this.find('div.minicolors-slider')
            );
            this.find('div.content div.opacity').append(
                this.find('div.minicolors-opacity-slider')
            );
            this.find('.minicolors-panel').append(
                this.find('div.content div.grid'),
                this.find('div.content div.slider'),
                this.find('div.content div.opacity')
            );
            this.find('.minicolors-panel').addClass('clearfix');
            if (this._options.showOpacitySlider === false) {
                this._element.addClass('slim');
            }
            this._element.addClass('opens');
            this._element.addClass('down');
            if (this._options.openDirection === 'up') {
                this._element.removeClass('down');
                this._element.addClass('up');
            }
        },

        /**
         * _refreshButton
         * 
         * @access  protected
         * @return  void
         */
        _refreshButton: function() {
            this._destroyTooltips();
            this._refreshTooltips();
            var $cta = this.find('.colorSwatch.cta'),
                $anchor = $cta.find('> a'),
                colors = this._collection.length();
            $cta.enable();
            if (colors === 0 || colors >= 20) {
                this._setupTooltips();
            }
            if (colors >= 20) {
                $cta.disable();
            }
        },

        /**
         * _refreshGridEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _refreshGridEyeDropper: function() {
            var rgbaColorStr = this.getColor(),
                colorStr = ColorUtils.getWhite('rgba', 0);
            if (rgbaColorStr !== false) {
                colorStr = ColorUtils.convert(rgbaColorStr, 'hex');
            }
            this.find('.minicolors-picker > div').css({
                'background-color': colorStr
            });
        },

        /**
         * _refreshTooltips
         * 
         * @access  protected
         * @return  void
         */
        _refreshTooltips: function() {
            var $cta = this.find('.colorSwatch.cta'),
                $anchor = $cta.find('> a'),
                colors = this._collection.length(),
                title = '';
            if (colors === 0 || colors >= 20) {
                var title = 'Save this color<br />to your account';
                if (colors >= 20) {
                    title = 'You have reached your account maximum of 20 ' +
                        'colors. Please delete one to save a new color.'
                }
            }
            $anchor.attr('data-original-title', title);
            $anchor.attr('data-title', title);
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._collection = Stencil.account().collection('colors');
            var _this = this;
            this._collection.on({
                'add': function(event, colorAccessor, position) {
                    _this._drawColorSwatch(colorAccessor, position);
                },
                'empty': function(event) {
                    _this.find('.colorSwatch:not(.cta)').remove();
                },
                'remove': function(event, colorAccessor) {
                    var colorSwatches = _this._colorSwatches,
                        colorSwatch,
                        index;
                    for (index in colorSwatches) {
                        colorSwatch = colorSwatches[index];
                        if (colorSwatch.getColor() === colorAccessor) {
                            colorSwatch.remove();
                            colorSwatches.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {
                    _this._refreshButton();
                }
            });
        },

        /**
         * _setupMinicolors
         * 
         * @access  protected
         * @return  void
         */
        _setupMinicolors: function() {
            var _this = this,
                placement = 'bottom right',
                opacity = true,
                colorKeywords = this._getColorKeywords();
            if (this._options.showOpacitySlider === false) {
                opacity = false;
            }
            this._$input.on({
                'focus': function(event) {
                    _this._refreshGridEyeDropper();
                }
            });
            this._$input.minicolors({
                'format': 'hex',
                'keywords': colorKeywords.join(','),
                'hideSpeed': 0,
                'showSpeed': 0,
                'opacity': opacity,
                'position': placement,
                'change': function(value, opacity) {
                    _this.triggerHandler('minicolors/change', [value, opacity]);
                },
                'hide': function(value, opacity) {
                    _this.triggerHandler('minicolors/hide');
                },
                'show': function(value, opacity) {
                    _this.triggerHandler('minicolors/show');
                }
            });
            // this._$input.nextAll('.minicolors-input-swatch').on({
            //     'mousedown': function(event) {
            //         event.preventDefault();
            //         if (_this._visible === true) {
            //             // _this.hide();
            //             // _this._$input.trigger('blur');
            //         }
            //     }
            // });
        },

        /**
         * _setupMinicolorsEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupMinicolorsEvents: function() {
            var colorKeywords = this._getColorKeywords(),
                lowercaseColorKeywords = ArrayUtils.lowercase(colorKeywords);
            this.on({
                'change': function(event, rgbaColorStr) {
                    this._refreshGridEyeDropper();
                },
                'minicolors/change': function(event, value, opacity) {
                    if (value === '') {
                        this._refreshGridEyeDropper();
                    }
                    if (value !== '' && value.match(/^#/) === null) {
                        if (ArrayUtils.contains(value, lowercaseColorKeywords) === true) {
                            value = value.replace(/ /g, '');
                            value = ColorUtils.convert(value, 'hex');
                            var rgbaColorStr = ColorUtils.convert(value, 'rgba');
                            this.setColor(rgbaColorStr, false);
                        }
                    }
                    if (this._eventsEnabled === true) {
                        var fallbackColor = this._options.fallbackColor;
                        if (fallbackColor !== false) {
                            if (value === '') {
                                value = fallbackColor;
                                opacity = ColorUtils.getAlpha(fallbackColor);
                            }
                        }
                        if (value !== '') {
                            var hex = ColorUtils.convert(value, 'hex'),
                                rgbaColorStr = ColorUtils.convert(hex, 'rgba', opacity);
                            this.triggerHandler('change', [rgbaColorStr]);
                        }
                        this.disableEyeDropper();
                    }
                },
                'minicolors/hide': function(event) {
                    this.hide();
                },
                'minicolors/show': function(event) {
                    this.show();
                }
            });
        },

        /**
         * _setupToolbarEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupToolbarEvents: function() {
            var _this = this;
            this._toolbar.on({
                'hide': function(event) {
                    _this._$input.minicolors('hide');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '.colorSwatch.cta > [tooltip]',
                container: App.getElement(),
                placement: 'left'
            });
        },

        /**
         * _toggleEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _toggleEyeDropper: function() {
            if (this._eyeDropperEnabled === false) {
                this._enableEyeDropper();
            } else {
                this.disableEyeDropper();
            }
        },

        /**
         * clearMinicolors
         * 
         * @access  public
         * @return  void
         */
        clearMinicolors: function() {
            this._$input.minicolors('value', '');
            this._$input.minicolors('opacity', '1');
        },

        /**
         * disableEyeDropper
         * 
         * @access  public
         * @return  void
         */
        disableEyeDropper: function() {
            if (this._eyeDropperEnabled === true) {
                var eyeDropper = this._getEyeDropper();
                eyeDropper.disable();
            }
        },

        /**
         * getColor
         * 
         * @access  public
         * @return  false|String
         */
        getColor: function() {
            var colorStr = this._$input.minicolors('value');
            if (colorStr === '') {
                return false;
            }
            var opacity = this._$input.minicolors('opacity'),
                rgbaColorStr = ColorUtils.convert(
                    colorStr,
                    'rgba',
                    opacity
                );
            return rgbaColorStr;
        },

        /**
         * getInput
         * 
         * @access  public
         * @return  jQuery
         */
        getInput: function() {
            return this._$input;
        },

        /**
         * removeLastChange
         * 
         * This resets the internal minicolors object that keeps track of
         * what the last color was. This is to address a bug whereby if the
         * copy + pasted the same color into other fields, the color would
         * not take effect, since minicolors did not think anything has
         * changed (since the input itself is the same one between text
         * layers).
         * 
         * @access  public
         * @return  void
         */
        removeLastChange: function() {
            this._$input.removeData('minicolors-lastChange');
        },

        /**
         * setColor
         * 
         * @note    minicolors always fires the <change> method, even when the
         *          color and/or opacity are set manually. To get around this
         *          (since I only want the event firing when it's manually
         *          changed), I use an internal property called _eventsEnable
         *          which prevents the event from firing.
         * @see     https://github.com/claviska/jquery-minicolors/issues/183
         * @access  public
         * @param   String rgbaColorStr
         * @param   undefined|Boolean triggerEvent (default: true)
         * @return  void
         */
        setColor: function(rgbaColorStr, triggerEvent) {
            triggerEvent = DataUtils.getDefaultValue(triggerEvent, true);
            var color = rgbaColorStr,
                hex = ColorUtils.convert(color, 'hex'),
                opacity = ColorUtils.getAlpha(color);
            if (triggerEvent === false) {
                this._eventsEnabled = false;
                this._$input.minicolors('value', hex);
                this._$input.minicolors('opacity', opacity);
                this._eventsEnabled = true;
            } else {
                this._$input.minicolors('value', hex);
                this._$input.minicolors('opacity', opacity);
            }
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            if (this._visible === true) {
                this._visible = false;
                this._element.addClass('hidden');
                this.disableEyeDropper();
                this.triggerHandler('hide');
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            if (this._visible === false) {
                this._visible = true;
                this._element.removeClass('hidden');
                this.triggerHandler('show');
            }
        },

        /**
         * visible
         * 
         * @access  public
         * @return  Boolean
         */
        visible: function() {
            return this._visible;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ColorSwatchView
     * 
     * @extends View
     */
    window.ColorSwatchView = View.extend({

        /**
         * _color
         * 
         * @access  protected
         * @var     null|ColorAccessor (default: null)
         */
        _color: null,

        /**
         * _colorPicker
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _colorPicker: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorSwatchView')
         */
        _string: 'ColorSwatchView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ColorPicker colorPicker
         * @param   ColorAccessor color
         * @return  void
         */
        init: function(element, colorPicker, color) {
            this._super(element);
            this._colorPicker = colorPicker;
            this._color = color;
            this._addDeleteListener();
            this._addSetListener();
            this._setupTooltips();
        },

        /**
         * _addDeleteListener
         * 
         * @access  protected
         * @return  void
         */
        _addDeleteListener: function() {
            this.on({
                'delete': function(event) {
                    this._delete();
                }
            });
        },

        /**
         * _addSetListener
         * 
         * @access  protected
         * @return  void
         */
        _addSetListener: function() {
            this.on({
                'set': function(event) {
                    this._colorPicker.setColor(
                        this._color.get('color')
                    );
                }
            });
        },

        /**
         * _delete
         * 
         * @access  protected
         * @return  void
         */
        _delete: function() {
            this._colorPicker.disableEyeDropper();
            var _this = this,
                question = 'Are you sure you want to delete this color?',
                modal = Modals.showConfirmDelete(question),
                $minicolors = this._colorPicker.getElement().parent('.minicolors');
            $minicolors.removeClass('minicolors-focus');
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.getElement().addClass('warning');
            modal.on({
                'leave close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                    $minicolors.addClass('minicolors-focus');
                },
                'yes': function(event) {
                    _this._color.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * getColor
         * 
         * @access  public
         * @return  ColorAccessor
         */
        getColor: function() {
            return this._color;
        },

        /**
         * remove
         * 
         * @access  public
         * @return  void
         */
        remove: function() {
            this._element.remove();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ConnectionRowView
     * 
     * @todo    After all connections have been deleted, close the modal
     * @events  confirm/delete
     * @extends View
     */
    window.ConnectionRowView = View.extend({

        /**
         * _connection
         * 
         * @access  protected
         * @var     null|ConnectionAccessor (default: null)
         */
        _connection: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionRowView')
         */
        _string: 'ConnectionRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ConnectionAccessor connection
         * @return  void
         */
        init: function(element, connection) {
            this._super(element);
            this._connection = connection;
            this._setupTooltips();
            this.on({
                'confirm/delete': function(event) {
                    App.tooltips.hide();
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._connection.on({
                'delete': function(event) {
                    _this._element.remove();
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this connection?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function(event) {
                    _this._connection.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FrameView', function() {

    /**
     * CustomFrameView
     * 
     * @events  confirm/delete
     * @extends FrameView
     */
    window.CustomFrameView = FrameView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CustomFrameView')
         */
        _string: 'CustomFrameView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   FramerView framer
         * @param   FrameAccessor frame
         * @return  void
         */
        init: function(element, framer, frame) {
            this._super(element, framer, frame);
            this.on({
                'confirm/delete': function(event) {
                    this._confirmDelete();
                }
            });
            var _this = this;
            this._frame.on({
                'delete': function(event) {
                    _this._element.remove();
                    // Track.user();
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * Confirms that a user wants to delete a frame. If they attempt to
         * delete the frame that their draft is currently using, simply switch
         * them to the orphan frame so that the word "Custom" shows up. To
         * ensure that the orphan has thsame width and height, I set it right
         * before switching to it.
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this custom size?',
                modal = Modals.showConfirmDelete(question);
            modal.on({
                'yes': function(event) {
                    var key = _this._frame.get('key'),
                        account = Stencil.account(),
                        draft = account.draft();
                    if (key === draft.get('frame')) {
                        var orphan = account.orphanFrame();
                        orphan.set({
                            width: _this._frame.get('width').toInt(),
                            height: _this._frame.get('height').toInt()
                        });
                        orphan.select();
                        orphan.setToPreviewCanvas();
                    }
                    _this._frame.delete();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * DropzoneView
     * 
     * @events  complete
     *          start
     * @extends View
     */
    window.DropzoneView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.prompt': function(event, $div) {
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {
                            var $file = this.find('input[type="file"]');
                            !this._uploading && $file.trigger('click');
                        }
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[lookup="again"]': function(event, $element) {
                        event.preventDefault();
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {
                            var $file = this.find('input[type="file"]');
                            !this._uploading && $file.trigger('click');
                        }
                    }
                },
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @note    The check for a non-empty files array is to deal
                     *          with an IE bug whereby the change event fires
                     *          twice: one with an empty array, and one with the
                     *          proper files array. More info here:
                     *          https://stackoverflow.com/questions/7419560/solve-ie7-bug-input-type-file-onchange-fire-twice
                     *          https://sentry.io/stencil/javascript/issues/395973564/
                     *          https://i.imgur.com/n05l2LX.png
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="file"]': function(event, $input) {
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {
                            if (this._uploading === false) {
                                var files = jQuery.makeArray(
                                    $input.prop('files')
                                );
                                if (files.length > 0) {
                                    this.receive(files);
                                }
                            }
                        }
                    }
                }
            });
        },

        /**
         * _max
         * 
         * Object defining the maximum filesize and count for uploads. It is set
         * when the view is initiated, as it's pulled dynamically from the
         * Stencil config settings.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _max: {},

        /**
         * _models
         * 
         * Defines the models that different types of DropzoneView's ought to
         * use when creating and referencing an accessor.
         * 
         * @access  protected
         * @var     Object
         */
        _models: {
            image: 'Upload',
            font: 'Upload',
            watermark: 'Watermark'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DropzoneView')
         */
        _string: 'DropzoneView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _type: '',

        /**
         * _managedUpload
         * 
         * @access  protected
         * @var     null|AWS.S3.ManagedUpload (default: null)
         */
        _managedUpload: null,

        /**
         * _uploading
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _uploading: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @return  void
         */
        init: function(element, type) {
            this._type = type;
            this._super(element);
            this._setMax();
            Scripts.load('aws');
            this.on({
                'cancel': function(event) {
                    this._managedUpload.abort();
                },
                'show/pad': function(event) {
                    this.show('prompt');
                }
            });
        },

        /**
         * _setMax
         * 
         * Defines the maximum files that can be uploaded at once, as well as
         * the maximum filesize for each file.
         * 
         * Note that the filesize limitation is defined in bytes.
         * 
         * @access  public
         * @return  void
         */
        _setMax: function() {
            this._max = {
                fonts: {
                    count: Config.default('fontUploadMaxFiles').toInt(),
                    size: Config.default('fontUploadMaxBytes').toInt()
                },
                images: {
                    count: Config.default('imageUploadMaxFiles').toInt(),
                    size: Config.default('imageUploadMaxBytes').toInt()
                }
            };
        },

        /**
         * _createUploadRecord
         * 
         * @see     http://stackoverflow.com/questions/12570834/how-to-preview-image-get-file-size-image-height-and-width-before-upload
         * @see     http://jsbin.com/oTAtIpA/3/edit?html,css,js,output
         * @access  public
         * @param   File file
         * @param   Function callback
         * @return  void
         */
        _createUploadRecord: function(file, callback) {
            var model = Stencil.getModel(this._models[this._type]);
            model.create({
                mime: file.type,
                name: file.name,
                size: file.size,
                type: this._type
            }, callback);
        },

        /**
         * isUploading
         * 
         * @access  public
         * @return  Boolean
         */
        isUploading: function() {
            return this._uploading === true;
        },

        /**
         * availableForUpload
         * 
         * @access  public
         * @return  Boolean
         */
        availableForUpload: function() {

            // S3 is disabled
            if (Services.check('aws') === false) {
                Stencil.alert('service.aws');
                return false;
            }

            // Currently uploading
            if (this._uploading === true) {
                return false;
            }
            return true;
        },

        /**
         * receive
         * 
         * @access  public
         * @param   Array files
         * @return  Boolean
         */
        receive: function(files) {

            // Clear input value
            var $file = this.find('input[type="file"]');
            $file.val('');

            // Check count
            var max = this._max.images;
            if (this._type === 'font') {
                max = this._max.fonts;
            }
            if (files.length > max.count) {
                if (this._type === 'font') {
                    Stencil.alert('upload.font.max.count');
                } else {
                    Stencil.alert('upload.image.max.count');
                }
                return false;
            }

            // Check type
            var imageTypes = Config.default('imageUploadMimeTypes');
            if (this._type === 'font') {
                for (var index in files) {
                    if (files[index].name.match(/\.zip$/i) !== null) {
                        Stencil.set('ignoreMouseDownLayerBlur', true);
                        Stencil.alert('upload.font.type');
                        Modals.getOpen()[0].once({
                            'leave': Stencil.set.proxy(
                                Stencil,
                                ['ignoreMouseDownLayerBlur', false]
                            )
                        });
                        return false;
                    }
                }
            } else {
                for (var index in files) {
                    if (ArrayUtils.contains(files[index].type, imageTypes) === false) {
                        Stencil.alert('upload.image.type');
                        return false;
                    }
                }
            }

            // Check maximum filesize
            for (index in files) {
                if (files[index].size > max.size) {
                    // if (User.admin() === true) {
                    //     if (this._type === 'font') {
                    //         Stencil.alert('upload.font.max.filesize.admin');
                    //     } else {
                    //         Stencil.alert('upload.image.max.filesize.admin');
                    //     }
                    //     return false;
                    // }
                    if (this._type === 'font') {
                        Stencil.alert('upload.font.max.filesize');
                    } else {
                        Stencil.alert('upload.image.max.filesize');
                    }
                    return false;
                }
            }

            // Check minimum filesize
            for (index in files) {
                if (files[index].size < 10) {
                    var key = 'upload.singular.filesize.zero';
                    if (files.length > 1) {
                        key = 'upload.multiple.filesize.zero';
                    }
                    Stencil.alert(key);
                    return false;
                }
            }

            // Success
            this.triggerHandler('start');
            var total = files.length;
            this.find('.context').addClass('hidden');
            if (total > 1) {
                this.find('.context').removeClass('hidden');
                this.find('[lookup="total"]').text(total);
            }
            var next = (function() {
                var current = total - files.length + 1;
                this.find('[lookup="current"]').text(current);
                this.uploadFile(files.shift(), current, total, function() {
                    if (files.length > 0) {
                        next();
                    }
                });
            }).proxy(this);
            next();
        },

        /**
         * reset
         * 
         * @access  public
         * @return  void
         */
        reset: function() {
            this.find('.progress').addClass('off').css({
                width: '0%'
            }).removeClass('off');
            this.find('.percentage').text('0%');
        },

        /**
         * show
         * 
         * @access  public
         * @param   String parent
         * @param   String child
         * @return  void
         */
        show: function(parent, child) {

            // Parent
            this.find('.prompt').addClass('invisible');
            this.find('.status').addClass('invisible');
            this.find('.prompt').removeClass('visible');
            this.find('.status').removeClass('visible');
            this.find('.' + (parent)).removeClass('invisible');
            this.find('.' + (parent)).addClass('visible');

            // Child 
            if (child) {
                this.find('.status').removeClass('uploading');
                this.find('.status').removeClass('processing');
                this.find('.status').removeClass('complete');
                this.find('.status').removeClass('failed');
                this.find('.status').addClass(child);
            }
        },

        /**
         * uploadFile
         * 
         * @todo    Proper error handling for too large of a file
         * @todo    When upload reaches 100%, switch to Processing state right
         *          away. Do this because sometimes things freeze for a few
         *          seconds here, which is confusing since it says 100%.
         * @access  public
         * @param   File file
         * @param   Number current
         * @param   Number total
         * @param   Function callback
         * @return  void
         */
        uploadFile: function(file, current, total, callback) {

            // Cancel link
            this._uploading = true;
            var _this = this,
                $cta = this.find('div.status div.uploading div.cta');
            $cta.addClass('hidden');

            // UI
            this.show('status', 'uploading');
            this.reset();

            // Let's do this
            this._createUploadRecord(
                file,

                /**
                 * (anonymous)
                 * 
                 * @param   Object data
                 * @return  void
                 */
                function(data) {

                    // Get reference to Upload or Watermark accessor
                    var model = Stencil.getModel(_this._models[_this._type]),
                        upload = model.setAccessor(data.object),
                        response;

                    model = Stencil.getModel('S3Upload');
                    response = model.uploadFile(
                        upload,
                        upload.get('key'),
                        file
                    );

                    // Successful attempt
                    if (response.success === true) {

                        // Move ahead
                        _this._managedUpload = response.response.managedUpload;

                        // Failed
                        upload.on({
                            'upload/error': function(event, err, responseObject) {
                                _this.find('.context').addClass('hidden');
                                _this._uploading = false;
                                _this.show('status', 'failed');
                                Track.event('Dropzone upload fail', {
                                    err: err
                                });
                                var msg = {
                                    err: err
                                }
                                Stencil.report('upload:upload/error', msg);
                            }
                        });

                        // Abort
                        upload.on({
                            'upload/abort': function(event, err, responseObject) {
                                _this._uploading = false;
                                _this.show('prompt');
                            }
                        });

                        // Success
                        upload.on({

                            /**
                             * (anonymous)
                             * 
                             * The point of preloading and have success/error
                             * callbacks is so that if there's a problem accessing
                             * the image's converted sizes, we can signal an error
                             * to the user and allow them to re-upload the file. An
                             * example of this would be if the user uploads a .zip
                             * file that was accidentally renamed .jpeg. This would
                             * get passed the checks (both drag/drop and click of
                             * the dropzone pad), but would fail when accessed via
                             * Cloudinary.
                             * 
                             * @todo    Ensure that the <upload.syncDimensions> call
                             *          is hooked up to the complete event here
                             * @access  private
                             * @param   Object event
                             * @param   Object response
                             * @param   Object responseObject
                             * @return  void
                             */
                            'upload/success': function(event, response, responseObject) {
                                upload.set({
                                    'uploaded': 1
                                });
                                _this._uploading = false;
                                _this.show('status', 'processing');
                                upload.once({
                                    'sync/complete': function(event, data) {
                                        if (_this._type === 'font') {
                                            var model = Stencil.getModel('Font');
                                            model.create({
                                                upload: this.get('key')
                                            }, function(response) {

                                                // 
                                                var model = Stencil.getModel('Font'),
                                                    font = model.setAccessor(response.object);
                                                _this.show('status', 'complete');
                                                _this.triggerHandler(
                                                    'complete',
                                                    [upload, font]
                                                );

                                                /**
                                                 * Delays here are intended to not
                                                 * jolt the user when the Dropzone
                                                 * prompt UI state is shown again.
                                                 */
                                                if (current === total) {
                                                    _this.show.delay(
                                                        2000,
                                                        _this,
                                                        ['prompt']
                                                    );
                                                } else {
                                                    (function() {
                                                        _this.show('prompt');
                                                        callback && callback();
                                                    }).delay(1000, _this);
                                                }
                                            }, function(response) {
                                                // console.log(response);
                                                Stencil.set('ignoreMouseDownLayerBlur', true);
                                                Stencil.alert('upload.font.failed');
                                                Modals.getOpen()[0].once({
                                                    'leave': Stencil.set.proxy(
                                                        Stencil,
                                                        ['ignoreMouseDownLayerBlur', false]
                                                    )
                                                });
                                                _this.show.delay(
                                                    0,
                                                    _this,
                                                    ['prompt']
                                                );
                                            });
                                        } else {
                                            upload.preload(
                                                function() {
                                                    _this.show('status', 'complete');
                                                    _this.triggerHandler(
                                                        'complete',
                                                        [upload]
                                                    );

                                                    /**
                                                     * Delays here are intended to not
                                                     * jolt the user when the Dropzone
                                                     * prompt UI state is shown again.
                                                     */
                                                    if (current === total) {
                                                        _this.show.delay(
                                                            2000,
                                                            _this,
                                                            ['prompt']
                                                        );
                                                    } else {
                                                        (function() {
                                                            _this.show('prompt');
                                                            callback && callback();
                                                        }).delay(1000, _this);
                                                    }
                                                },
                                                function() {
                                                    upload.delete();
                                                    _this.find('.context').addClass(
                                                        'hidden'
                                                    );
                                                    _this._uploading = false;
                                                    _this.show('status', 'failed');
                                                }
                                            );
                                        }
                                    }
                                });
                                upload.save(['uploaded'], {
                                    success: function() {
                                        this.sync();
                                    }
                                });
                            }
                        });

                        // Progress
                        upload.on({

                            /**
                             * (anonymous)
                             * 
                             * @access  private
                             * @param   Object event
                             * @param   Number loaded
                             * @param   Number total
                             * @return  void
                             */
                            'upload/progress': function(event, loaded, total) {

                                // Cancel link
                                var $cta = _this.find('div.status div.uploading div.cta');
                                $cta.addClass('hidden');
                                if (file.size > 5 * 1024 * 1024) {
                                    $cta.removeClass('hidden');
                                }

                                // Percentage
                                var percentage = Math.round(
                                    (loaded / total) * 100
                                );
                                if (percentage < 3) {
                                    percentage = 3;
                                }
                                _this.find('.progress').css({
                                    width: (percentage) + '%'
                                });
                                _this.find('.percentage').text(
                                    (percentage) + '%'
                                );
                            }
                        });

                        // Fake a progress event to ensure something is visible
                        upload.triggerHandler('upload/progress', [3, 100]);
                    }
                    // Upload failed; alert
                    else {
                        _this._uploading = false;
                        _this.show('prompt');
                        Stencil.alert(response.failedRules[0].key);
                    }
                }
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FontsDropdownView
     * 
     * @events  hover
     *          close
     *          open
     *          toggle
     *          select
     * @extends View
     */
    window.FontsDropdownView = View.extend({

        /**
         * _dropzone
         * 
         * @access  protected
         * @var     null|FontsDropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _fontsCollection
         * 
         * @access  protected
         * @var     null|FontsCollection (default: null)
         */
        _fontsCollection: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'nav a[section]': function(event, $anchor) {
                        event.preventDefault();
                        var section = $anchor.attr('section');
                        this.showTab(section);
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'div.selected a': function(event, $anchor) {
                        event.preventDefault();
                        this.toggle();
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'li a.label': function(event, $anchor) {
                        event.preventDefault();
                        var value = $anchor.parent().attr('value'),
                            font = this._fontsCollection.findByFamilyName(value);
                        this.selectFont(font);
                        this.saveFontAsAccountDefault(font);
                        this.triggerHandler('select', font);
                        this.close();
                    }
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'li a': function(event, $anchor) {
                        var $li = $anchor.parent(),
                            value = $li.attr('value'),
                            font = this._fontsCollection.findByFamilyName(value);
                        $li.siblings().removeClass('hover');
                        $li.addClass('hover');
                        this.triggerHandler('hover', font);
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'li a': function(event, $anchor) {
                        var $li = $anchor.parent();
                        $li.removeClass('hover');
                    }
                }
            });
        },

        /**
         * _scrollbars
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _scrollbars: {},

        /**
         * _selectedFont
         * 
         * @access  protected
         * @var     false|FontAccessor
         */
        _selectedFont: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontsDropdownView')
         */
        _string: 'FontsDropdownView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   FontsCollection fontsCollection
         * @return  void
         */
        init: function(element, fontsCollection) {
            this._super(element);
            this._fontsCollection = fontsCollection;
            this._addAuthEvents();
            this._addHoverEvents();
            this._setupAuth();
            this._setupDropzone();
            this._setupImportClickEvent();
            this.on({
                'edit': function(event, $anchor) {
                    var key = $anchor.attr('key'),
                        font = this._fontsCollection.find(key);
                    this._edit(font);
                },
                'confirm/delete': function(event, $anchor) {
                    var key = $anchor.attr('key'),
                        font = this._fontsCollection.find(key);
                    this._confirmDelete(font);
                }
            });
            if (UserAgent.supports.css.scrollbars() === false) {
                this._setupScrollbars();
            }
            this.showAppropriateMessagingElements();
        },

        /**
         * _addAuthEvents
         * 
         * @note    Delayed to the end of the stack (via 0 millisecond delay) to
         *          ensure the modal is available before an event is bound to it.
         * @access  protected
         * @return  void
         */
        _addAuthEvents: function() {
            var $anchors = this._element.find(
                'a[href^="/app/login"], ' +
                'a[href^="/app/signup"], ' +
                'a[href^="/app/plans"]'
            );
            $anchors.on({
                'click': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', true);
                    (function() {
                        var modal = Modals.getOpen()[0];
                        modal.once({
                            'close': function() {
                                Stencil.set('ignoreMouseDownLayerBlur', false);
                            }
                        });
                    }).delay(0);
                }
            });
        },

        /**
         * _addEscapeEvent
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeEvent: function() {
            var _this = this,
                callback = function(event) {
                    if (
                        event.which === 27
                        && Stencil.get('ignoreMouseDownLayerBlur') !== true
                        && _this._element.hasClass('open') === true
                    ) {
                        event.preventDefault();
                        _this.close();
                        // $(this).unbind(event);
                    }
                };
            App.getElement().on({
                'keydown': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('keydown', callback);
                }
            });
        },

        /**
         * _addHoverEvents
         * 
         * @note    There is a bug where by if the page has a scrollbar and an
         *          element that is being hovered over exists outside of the
         *          scope of the page-scrollbar, the elementFromPoint can't seem
         *          to find it, resulting in the following error:
         *          https://i.imgur.com/SdBdmRf.png
         *          So to deal with this, I simply ensure the length of $el is
         *          greater than 0.
         * @access  protected
         * @return  void
         */
        _addHoverEvents: function() {
            this.find('div.list').scroll(function(event) {
                var el = document.elementFromPoint(App.getX(), App.getY()),
                    $el = $(el);
                if ($el.length > 0) {
                    if ($el.tag() === 'a') {
                        $el.trigger('mouseenter');
                    }
                }
            });
        },

        /**
         * _blur
         * 
         * @access  protected
         * @param   jQuery event
         * @return  void
         */
        _blur: function(event) {
            var $target = $(event.target);
            if (Stencil.get('ignoreMouseDownLayerBlur') !== true) {
                if ($target.closest('.fontsDropdown').length === 0) {
                    this.close();
                }
            }
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @param   FontAccessor font
         * @return  void
         */
        _confirmDelete: function(font) {
            var _this = this,
                question = 'Are you sure you want to delete this font?',
                // h2 = '<strong>WARNING:</strong> This cannot be undone. Any ' +
                //     'images youve saved using this font will revert to a ' +
                //     'default font.',
                // modal = Modals.showConfirmDelete(question, h2);
                modal = Modals.showConfirmDelete(question);
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.getElement().addClass('warning');
            modal.on({
                'close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'yes': function(event) {

                    // Revert any fonts being used to the app default
                    _this._revertTextLayersUsingFont(font);

                    /**
                     * Wait until the stack has ended (to ensure mouseup or
                     * keyup events have fired), and then go through the change
                     * history and swap out any text layers that were using that
                     * font with the app default. This is to prevent a bug when
                     * trying to revert to one of those older or future
                     * versions.
                     * 
                     * Without the 0-second delay (which effectively just moves
                     * the call to the end of the stack), no operation gets
                     * recorded, since previous operations would have had their
                     * font families reverted to the app default already, which
                     * means the ChangeHistory.track method wouldn't notice that
                     * anything's changed.
                     */
                    ChangeHistory.syncDeletedFont.delay(0, ChangeHistory, [font]);

                    // Overhead procedures
                    _this.removeFont(font);
                    font.delete();
                    _this.showAppropriateMessagingElements();
                    this.triggerHandler('leave');
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _edit
         * 
         * @access  protected
         * @param   FontAccessor font
         * @return  void
         */
        _edit: function(font) {
            var _this = this,
                modal = Modals.showRename(font, 'label');
            modal.find('input').select();
            Stencil.set('ignoreMouseDownLayerBlur', true);
            modal.on({
                'close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'save': function(event, object) {
                    font.set({
                        label: object.label
                    });
                    var familyName = font.get('familyName'),
                        $li = _this.find('li[value="' + (familyName) + '"]'),
                        $label = $li.find('a.label');
                    $label.text(object.label);
                    this.triggerHandler.delay(500, this, ['close']);
                }
            });
        },

        /**
         * _focusOnSelectedFont
         * 
         * @access  protected
         * @return  void
         */
        _focusOnSelectedFont: function() {
            var uploaded = this._selectedFont.get('uploaded').toInt() === 1
                    && this._selectedFont.get('hasRegularAccess').toInt() === 1,
                sections = {
                    $default: this.find('section[section="default"]'),
                    $uploaded: this.find('section[section="uploaded"]')
                },
                lists = {
                    $default: this.find('[section="default"] div.list'),
                    $uploaded: this.find('[section="uploaded"] div.list')
                },
                $active = this.find('[section] li.active');
            if (UserAgent.supports.css.scrollbars() === false) {
                this._scrollbars.$default.data('jsp').scrollToY(0, false);
                this._scrollbars.$uploaded.data('jsp').scrollToY(0, false);
                if (uploaded === false) {
                    this._scrollbars.$default.data('jsp').scrollToY(
                        $active.position().top - 4,
                        false
                    );
                } else {
                    this._scrollbars.$uploaded.data('jsp').scrollToY(
                        $active.position().top - 4,
                        false
                    );
                }
            } else {
                sections.$default.removeClass('hidden');
                lists.$default.scrollTop(0);
                sections.$default.addClass('hidden');
                sections.$uploaded.removeClass('hidden');
                lists.$uploaded.scrollTop(0);
                sections.$uploaded.addClass('hidden');
                if (uploaded === false) {
                    sections.$default.removeClass('hidden');
                    lists.$default.scrollTop($active.position().top - 4);
                } else {
                    sections.$uploaded.removeClass('hidden');
                    lists.$uploaded.scrollTop($active.position().top - 4);
                }
            }
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $default
         * @param   jQuery $uploaded
         * @return  void
         */
        _makeScrollable: function($default, $uploaded) {
            this._scrollbars.$default = $default;
            this._scrollbars.$uploaded = $uploaded;
            this._scrollbars.$default.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            this._scrollbars.$uploaded.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _revertTextLayersUsingFont
         * 
         * @access  protected
         * @param   FontAccessor font
         * @return  void
         */
        _revertTextLayersUsingFont: function(font) {
            var account = Stencil.account(),
                fontsCollection = this._fontsCollection,
                appDefaultFontFamily = Stencil.account().getDefaultFontFamily(),
                backupFont = fontsCollection.findByFamilyName(appDefaultFontFamily),
                draftImageDocument = account.draft().getImageDocument(),
                textLayersWithSelectedFont = draftImageDocument.filter(function(index, layer) {
                    return layer.getStyle('fontFamily') === font.get('familyName');
                });
            if (textLayersWithSelectedFont.length > 0) {
                ChangeHistory.setOperationType('fonts // reset');
            }
            jQuery.each(textLayersWithSelectedFont, function(index, textLayer) {
                textLayer.triggerHandler('change/fontFamily', backupFont);
            });

            /**
             * Re-select the font for this selected layer, just incase it was
             * deleted. This ensures either the backup font is showing in the
             * dropdown if it ought to be.
             */
            var activeFontFamily = Canvases.Preview.getSelectedLayer().getStyle('fontFamily'),
                activeFont = fontsCollection.findByFamilyName(activeFontFamily);
            this.selectFont(activeFont);
        },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            var _this = this;
            User.once({
                'login': function(event) {
                    _this.showAppropriateMessagingElements();
                },
                'signup': function(event, user) {
                    _this.showAppropriateMessagingElements();
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this.showAppropriateMessagingElements();
                }
            });
        },

        /**
         * _setupDropzone
         * 
         * @access  protected
         * @return  void
         */
        _setupDropzone: function() {
            var collection = this._fontsCollection,
                $dropzone = this.find('.dropzone');
            this._dropzone = new FontsDropzoneView($dropzone, 'font');
            this._dropzone.on({
                'complete': function(event, upload, font) {
                    Track.event('Font uploaded');
                    collection.add(font);
                    font.loadFull(function() {
                        var fontsDropdown = Toolbars.getToolbar('text').getFontsDropdown();
                        fontsDropdown.addFont(font, false);
                        fontsDropdown.scrollToTop('uploaded');
                    });
                }
            });
        },

        /**
         * _setupImportClickEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupImportClickEvent: function() {
            this.on({
                'import': function(event, $anchor) {
                    // if (Account.upgraded() === true || User.admin() === true) {
                        Stencil.navigate('/app/fonts/import');
                    // } else {
                    //     Stencil.navigate('/app/upgrade/pro/font-imports?clean=1');
                    // }
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbars: function() {
            var $default = this.find('section[section="default"] div.list'),
                $uploaded = this.find('section[section="uploaded"] div.list');
            $default.addClass('dark');
            $uploaded.addClass('dark');
            this._makeScrollable($default, $uploaded);
        },

        /**
         * _showTabForSelectedFont
         * 
         * @access  protected
         * @return  void
         */
        _showTabForSelectedFont: function() {
            var font = this._selectedFont,
                section = 'default';
            if (
                font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1
            ) {
                section = 'uploaded';
            }
            this.showTab(section);
        },

        /**
         * addFont
         * 
         * @access  public
         * @param   FontAccessor font
         * @param   Boolean sort
         * @return  void
         */
        addFont: function(font, sort) {
            this.showAppropriateMessagingElements();
            var section = font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1 ? 'uploaded' : 'default';
            var $section = this.find('section[section="' + (section) + '"]'),
                $li = $('<li></li>'),
                $a = $('<a class="label" click="" trigger="null"></a>'),
                $editIcon = $('<a class="icon edit fa fa-pencil" click="" trigger="edit"></a>'),
                $deleteIcon = $('<a class="icon delete fa fa-trash" click="" trigger="confirm/delete"></a>');
            $li.attr('value', font.get('familyName'));
            $li.attr('style', 'font-family: ' + (font.get('familyName')) + ', monospace');
            $a.text(font.get('label'));
            $editIcon.attr('key', font.get('key'));
            $deleteIcon.attr('key', font.get('key'));
            $li.append($a);
            if (
                font.get('uploaded').toInt() === 1
                && font.get('hasRegularAccess').toInt() === 1
            ) {
                $li.append($editIcon, $deleteIcon);
            }
            $section.find('ul').prepend($li);
            if (sort === true) {
                $section.find('ul')[0].orderAlphabeticallyByText();
            }
            this.refreshScrollbars(section);
        },

        /**
         * close
         * 
         * @access  public
         * @return  void
         */
        close: function() {
            this._element.removeClass('open');
            this.triggerHandler('close');
        },

        /**
         * getDropzone
         * 
         * @access  public
         * @return  FontsDropzoneView
         */
        getDropzone: function() {
            return this._dropzone;
        },

        /**
         * getFontsCollection
         * 
         * @access  public
         * @return  FontsCollection
         */
        getFontsCollection: function() {
            return this._fontsCollection;
        },

        /**
         * getSelectedFont
         * 
         * @access  public
         * @return  false|FontAccessor
         */
        getSelectedFont: function() {
            return this._selectedFont;
        },

        /**
         * open
         * 
         * @access  public
         * @return  void
         */
        open: function() {
            this._addEscapeEvent();
            var callback = this._blur.proxy(this);
            App.getElement().on({
                'click': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('click', callback);
                }
            });
            this._element.addClass('open');
            this._showTabForSelectedFont();
            this.refreshScrollbars();
            this._focusOnSelectedFont();
            this.triggerHandler('open');

            // 
            var callback = this._blur.proxy(this),
                cotton = Canvases.Preview.getCotton();
            cotton.on({
                'object:selected': callback
            });
            this.once({
                'close': function(event) {
                    cotton.off('object:selected', callback);
                }
            });
        },

        /**
         * refreshScrollbars
         * 
         * @access  public
         * @param   undefined|String section
         * @return  void
         */
        refreshScrollbars: function(section) {
            if (UserAgent.supports.css.scrollbars() === false) {
                var sections = {
                        $default: this.find('section[section="default"]'),
                        $uploaded: this.find('section[section="uploaded"]')
                    },
                    lists = {
                        $default: this.find('[section="default"] div.list'),
                        $uploaded: this.find('[section="uploaded"] div.list')
                    };
                sections.$default.removeClass('hidden');
                sections.$uploaded.removeClass('hidden');
                this._scrollbars.$default.data('jsp').reinitialise();
                this._scrollbars.$uploaded.data('jsp').reinitialise();
                sections.$default.addClass('hidden');
                sections.$uploaded.addClass('hidden');
                if (section === undefined) {
                    var font = this._selectedFont;
                    if (
                        font.get('uploaded').toInt() === 1
                        && font.get('hasRegularAccess').toInt() === 1
                    ) {
                        sections.$uploaded.removeClass('hidden');
                    } else {
                        sections.$default.removeClass('hidden');
                    }
                } else {
                    if (section === 'default') {
                        sections.$default.removeClass('hidden');
                    } else {
                        sections.$uploaded.removeClass('hidden');
                    }
                }
            }
        },

        /**
         * removeFont
         * 
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        removeFont: function(font) {
            var familyName = font.get('familyName'),
                $li = this.find('li[value="' + (familyName) + '"]');
            $li.remove();
            this.refreshScrollbars('uploaded');
        },

        /**
         * saveFontAsAccountDefault
         * 
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        saveFontAsAccountDefault: function(font) {
            if (font.get('uploaded').toInt() === 0) {
                var account = Stencil.account();
                account.push('settings.defaultFontFamily', font.get('key'));
            }
        },

        /**
         * scrollToTop
         * 
         * @access  public
         * @param   String section
         * @return  void
         */
        scrollToTop: function(section) {
            if (UserAgent.supports.css.scrollbars() === false) {
                if (section === 'uploaded') {
                    this._scrollbars.$uploaded.data('jsp').scrollToY(0, false);
                } else {
                    this._scrollbars.$default.data('jsp').scrollToY(0, false);
                }
            } else {
                this.find('[section="' + (section) + '"] div.list').scrollTop(0);
            }
        },

        /**
         * selectFont
         * 
         * Sets an internal reference to the passed in FontAccessor, and updates
         * the UI so that the .selected element has that corresponding label
         * and font-family set.
         * 
         * @note    I remove any possible "hidden" class from the list item to
         *          ensure that if the font is a legacy one, it can be seen. This
         *          is because legacy fonts are written to the DOM, but simply
         *          hidden (since they're only used when legacy images or
         *          templates are used).
         * @access  public
         * @param   FontAccessor font
         * @return  void
         */
        selectFont: function(font) {
            this._selectedFont = font;
            var familyName = font.get('familyName'),
                label = font.get('label'),
                $li = this.find('li[value="' + (familyName) + '"]'),
                $copy = this.find('div.selected a span.copy'),
                $items = this.find('section[section] div ul li');
            $li.removeClass('hidden');
            $items.removeClass('active');
            $li.addClass('active');
            $copy.css('font-family', familyName);
            $copy.text(label);
        },

        /**
         * showAppropriateMessagingElements
         * 
         * @access  public
         * @return  void
         */
        showAppropriateMessagingElements: function() {
            var $lists = this.find('section[section="uploaded"] div.list');
            $lists.removeClass('hidden');
            this.find('.messaging,.empty,.guest,.free').addClass('hidden');
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                if (this._fontsCollection.getUploaded().length === 0) {
                    $lists.addClass('hidden');
                    this.find('.messaging,.empty').removeClass('hidden');
                }
            } else {
                $lists.addClass('hidden');
                if (Account.guest() === true) {
                    this.find('.messaging,.guest').removeClass('hidden');
                } else if (Account.free() === true) {
                    this.find('.messaging,.free').removeClass('hidden');
                } else {
                    // Should never get here
                }
            }
        },

        /**
         * showTab
         * 
         * @access  public
         * @param   String section
         * @return  void
         */
        showTab: function(section) {
            this.find('nav a[section]').addClass('noAnimation').removeClass('active');
            this.find('nav a[section="' + (section) + '"]').addClass('active');
            this.find('nav a[section]').removeClass('noAnimation');
            this.find('section[section]').addClass('hidden');
            this.find('section[section="' + (section) + '"]').removeClass('hidden');
        },

        /**
         * toggle
         * 
         * Either closes or opens the dropdown by calling the helper <close> or
         * <open> methods. Also fires the <toggle> event.
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            this.triggerHandler('toggle');
            if (this._element.hasClass('open') === true) {
                this.close();
            } else {
                this.open();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('DropzoneView', function() {

    /**
     * FontsDropzoneView
     * 
     * @events  complete
     * @extends DropzoneView
     */
    window.FontsDropzoneView = DropzoneView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.prompt': function(event, $div) {

                        // Max has been reached
                        var fonts = Stencil.account().collection('fonts').getUploaded(),
                            max = Config.default('maxFontUploads');
                        if (fonts.length >= max) {
                            Stencil.set('ignoreMouseDownLayerBlur', true);
                            Stencil.alert('font.import.max');
                            Modals.getOpen()[0].once({
                                'leave': Stencil.set.proxy(
                                    Stencil,
                                    ['ignoreMouseDownLayerBlur', false]
                                )
                            });
                        }
                        // Good to go
                        else {
                            if (Services.check('fonts') === false) {
                                Stencil.alert('service.fonts.disabled');
                            } else {

                                // Pro user
                                if (
                                    Account.upgraded() === true
                                    || User.admin() === true
                                    || User.editor() === true
                                ) {
                                    var $file = this.find('input[type="file"]');
                                    !this._uploading && $file.trigger('click');
                                }
                                // Upsell
                                else {
                                    Stencil.set('ignoreMouseDownLayerBlur', true);
                                    Stencil.navigate('/app/upgrade/pro/fonts?clean=1');
                                    var modal = Modals.getOpen()[0];
                                    modal.once({
                                        'leave': function(event) {
                                            Stencil.set('ignoreMouseDownLayerBlur', false);
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FontsDropzoneView')
         */
        _string: 'FontsDropzoneView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @return  void
         */
        init: function(element, type) {
            this._super(element, type);
        },

        /**
         * availableForUpload
         * 
         * @access  public
         * @return  Boolean
         */
        availableForUpload: function() {

            // Max has been reached
            var fonts = Stencil.account().collection('fonts').getUploaded(),
                max = Config.default('maxFontUploads');
            if (fonts.length >= max) {
                Stencil.set('ignoreMouseDownLayerBlur', true);
                Stencil.alert('font.import.max');
                Modals.getOpen()[0].once({
                    'leave': Stencil.set.proxy(
                        Stencil,
                        ['ignoreMouseDownLayerBlur', false]
                    )
                });
                return false;
            }

            // Fonts are disabled
            if (Services.check('fonts') === false) {
                Stencil.alert('service.fonts.disabled');
                return false;
            }

            // Upgraded/admin user
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                if (this._uploading === true) {
                    return false;
                }
                return true;
            }

            // Upsell
            Stencil.set('ignoreMouseDownLayerBlur', true);
            Stencil.navigate('/app/upgrade/pro/fonts?clean=1');
            var modal = Modals.getOpen()[0];
            modal.once({
                'leave': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                }
            });
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FrameView
     * 
     * @extends View
     */
    window.FrameView = View.extend({

        /**
         * _frame
         * 
         * @access  protected
         * @var     null|FrameAccessor (default: null)
         */
        _frame: null,

        /**
         * _framer
         * 
         * @access  protected
         * @var     null|FramerView (default: null)
         */
        _framer: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FrameView')
         */
        _string: 'FrameView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   FramerView framer
         * @param   FrameAccessor frame
         * @return  void
         */
        init: function(element, framer, frame) {
            this._super(element);
            this._framer = framer;
            this._frame = frame;
            this._addSelectListener();
        },

        /**
         * _addSelectListener
         * 
         * Listens for a frame being selected in the UI, and when it is, first
         * tracks the position of the background image (relative to the
         * background image and frame-key combination) before changing to the
         * new frame. This is because it's possible that the user moves the
         * background position from it's default 50-50 position, and just wants
         * to see what, for example, a Pinterest frame looks like. By storing
         * this background position, it allows us to reposition the background
         * image if the user goes back to the previous frame. It is less
         * jarring.
         * 
         * After the select happens against the FrameAccessor, I then redraw the
         * image (via the setToPreviewCanvas method), and then restore the
         * background image (relative to the background image and the frame
         * being switched to), if any position details were stored (logic is
         * elsewhere for that).
         * 
         * Finally, I hide the Framer, and make a call to set the configuration
         * of the image to ensure, after the application-wide save-delay, the
         * image configuration details are saved.
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event) {
                    ChangeHistory.setOperationType('frame // changed');
                    var canvas = Canvases.Preview,
                        draft = Stencil.account().draft();
                    canvas.trackBackgroundImageLayerPosition();
                    this._frame.select();
                    this._frame.setToPreviewCanvas();
                    canvas.restoreFrameSpecificPosition();
                    this._framer.hide();
                    draft.setConfiguration();
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * GoogleFontRowView
     * 
     * @extends View
     */
    window.GoogleFontRowView = View.extend({

        /**
         * _googleFont
         * 
         * @access  protected
         * @var     null|GoogleFontAccessor (default: null)
         */
        _googleFont: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontRowView')
         */
        _string: 'GoogleFontRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GoogleFontAccessor googleFont
         * @return  void
         */
        init: function(element, googleFont) {
            this._super(element);
            this._googleFont = googleFont;
            // this._setupTooltips();
            this.on({
                'import': function(event, $anchor) {
                    if (Services.check('fonts') === false) {
                        Stencil.alert('service.fonts.disabled');
                    } else {
                        if (
                            Account.upgraded() === true
                            || User.admin() === true
                            || User.editor() === true
                        ) {

                            // Max has been reached
                            var fonts = Stencil.account().collection('fonts').getUploaded(),
                                max = Config.default('maxFontUploads');
                            if (fonts.length >= max) {
                                Stencil.alert('font.import.max');
                            }
                            // Good to go
                            else {
                                var modal = Modals.getOpen()[0];
                                modal.pause();
                                $anchor.addClass('busy');
                                $anchor.disable();
                                // modal.find('a.button.tiny').disable();
                                this._googleFont.once({
                                    'import': function(event, data) {

                                        // Button updates
                                        $anchor.removeClass('busy');
                                        $anchor.addClass('done');
                                        // modal.find('a.button.tiny:not(.done)').enable();
                                        // $anchor.enable();
                                        modal.unpause();

                                        // Collection updates
                                        var model = Stencil.getModel('Font'),
                                            font = model.setAccessor(data.object),
                                            fontsDropdown = Toolbars.getToolbar('text').getFontsDropdown(),
                                            collection = fontsDropdown.getFontsCollection();
                                        Track.event('Font imported');
                                        collection.add(font);
                                        font.loadFull(function() {
                                            fontsDropdown.addFont(font, false);
                                            fontsDropdown.scrollToTop('uploaded');
                                        });

                                        // Focus on the tab in the dropdown
                                        fontsDropdown.showTab('uploaded');
                                    }
                                });
                                this._googleFont.import();
                            }
                        } else {
                            Modals.showUpgrade('pro', 'font-imports');
                            // Stencil.navigate('/app/upgrade/pro/font-imports');
                        }
                    }
                }
            });
        }
        //,

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        // _setupTooltips: function() {
        //     this._element.tooltip({
        //         html: true,
        //         selector: '[tooltip]',
        //         // container: App.getElement(),
        //         // container: this._element.closest('.modal'),
        //         placement: 'bottom'
        //     });
        // }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ResourcesSearchView
     * 
     * @events  clear
     *          submit
     * @extends View
     */
    window.ResourcesSearchView = View.extend({

        /**
         * _area
         * 
         * @access  protected
         * @var     null|AreaView (default: null)
         */
        _area: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        if (event.which === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            }
                        } else if (event.which === 27) {
                            // var val = $input.val();
                            // if (val !== '') {
                            //     $input.val('');
                            // } else {
                                $input.blur();
                            // }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="clear"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('clear');
                    }
                },
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        $input.parent().removeClass('queried');
                        $input.parent().removeClass('active');
                        if ($input.val().length > 0) {
                            $input.parent().addClass('active');
                        }

                        // Mark UI as queried if user types their way back
                        var activeResults = this._area.getChild('queries').getActiveResults();
                        if (activeResults !== null) {
                            if ($input.val() === activeResults.getQuery()) {
                                $input.parent().removeClass('active');
                                $input.parent().addClass('queried');
                            }
                        }
                    }
                }
            });
        },

        /**
         * _maxOpenQueries
         * 
         * The maximum number of queries that can be open at once before
         * garbage collection kicks in.
         * 
         * @access  protected
         * @var     Number (default: 10)
         */
        _maxOpenQueries: 10,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourcesSearchView')
         */
        _string: 'ResourcesSearchView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element);
            this._area = area;
            this.on({
                'clear': function(event) {
                    var categoryPath = this._area.getChild('categories').getPath();
                    Stencil.navigate(categoryPath);
                },
                'submit': function(event) {
                    var $input = this.find('input.search'),
                        val = $input.val(),
                        children = this._area.getChild('queries').getChildren();
                    if (children[val] !== undefined) {
                        this._area.getChild('queries').getChild(val).triggerHandler('destroy');
                    }
                    this._destroyIdleQueries(val);
                    if (UserAgent.is.tablet() === true) {
                        document.activeElement.blur();
                        $input.blur();
                    }
                    this._area.search(val, true);
                }
            });
        },

        /**
         * _destroyIdleQueries
         * 
         * Destroys QueryResultsView's once the limit has been reached (for
         * memory purposes).
         * 
         * @note    Was named oscar, after Oscar the Grouch ;)
         * @note    Second length check needs to be made since the destroy
         *          handler changes the response from getChildren
         * @access  protected
         * @param   String currentQuery the query currently being searched for
         * @return  void
         */
        _destroyIdleQueries: function(currentQuery) {
            var children = this._area.getChild('queries').getChildren(),
                maxOpenQueries = this._maxOpenQueries;
            if (Object.keys(children).length >= maxOpenQueries) {
                var query;
                for (query in children) {
                    if (query !== currentQuery) {
                        if (Object.keys(children).length >= maxOpenQueries) {
                            children[query].triggerHandler('destroy');
                        }
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ToolbarsView
     * 
     * @extends View
     */
    window.ToolbarsView = View.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _drawProperties: {
            'backgroundBitmapImage': {
                'template': 'BackgroundBitmapImageToolbar',
                'view': 'BackgroundBitmapImageToolbarView'
            },
            'backgroundRectangle': {
                'template': 'BackgroundRectangleToolbar',
                'view': 'BackgroundRectangleToolbarView'
            },
            'colorVectorImage': {
                'template': 'ColorVectorImageToolbar',
                'view': 'ColorVectorImageToolbarView'
            },
            'foregroundBitmapImage': {
                'template': 'ForegroundBitmapImageToolbar',
                'view': 'ForegroundBitmapImageToolbarView'
            },
            'text': {
                'template': 'TextToolbar',
                'view': 'TextToolbarView'
            },
            'vectorImage': {
                'template': 'VectorImageToolbar',
                'view': 'VectorImageToolbarView'
            },
            'watermarkBitmapImage': {
                'template': 'WatermarkBitmapImageToolbar',
                'view': 'WatermarkBitmapImageToolbarView'
            }
        },

        /**
         * _stageContent
         * 
         * @access  protected
         * @var     null|StageContentView (default: null)
         */
        _stageContent: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ToolbarsView')
         */
        _string: 'ToolbarsView',

        /**
         * _toolbars
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _toolbars: {},

        /**
         * _visibleToolbar
         * 
         * @access  protected
         * @var     false|ToolbarView (default: false)
         */
        _visibleToolbar: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   StageContentView stageContent
         * @return  void
         */
        init: function(element, stageContent) {
            this._toolbars = {};
            this._stageContent = stageContent;
            this._super(element);
            this._drawToolbars();
        },

        /**
         * _drawToolbar
         * 
         * @access  protected
         * @param   String type
         * @return  void
         */
        _drawToolbar: function(type) {
            var template = this._drawProperties[type].template,
                viewName = this._drawProperties[type].view,
                $element = DataUtils.render(template),
                view = new window[viewName]($element, this);
            this._toolbars[type] = view;
            this._element.append($element);
        },

        /**
         * _drawToolbars
         * 
         * @access  protected
         * @return  void
         */
        _drawToolbars: function() {
            for (var index in this._drawProperties) {
                this._drawToolbar(index);
            }
        },

        /**
         * getStageContent
         * 
         * @access  public
         * @return  null|StageContentView
         */
        getStageContent: function() {
            return this._stageContent;
        },

        /**
         * getToolbar
         * 
         * @access  public
         * @param   String type
         * @return  ToolbarView
         */
        getToolbar: function(type) {
            return this._toolbars[type];
        },

        /**
         * getVisibleToolbar
         * 
         * @access  public
         * @return  false|ToolbarView
         */
        getVisibleToolbar: function() {
            return this._visibleToolbar;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            for (var index in this._toolbars) {
                this._toolbars[index].hide();
            }
            var content = App.getStage().getContent();
            content.handles.hide.apply(content);
        },

        /**
         * setVisibleToolbar
         * 
         * @access  public
         * @param   false|ToolbarView toolbar
         * @return  void
         */
        setVisibleToolbar: function(toolbar) {
            this._visibleToolbar = toolbar;
        },

        /**
         * show
         * 
         * @access  public
         * @param   String type
         * @param   undefined|Object options (default: {})
         * @return  void
         */
        show: function(type, options) {
            options = DataUtils.getDefaultValue(options, {});
            this.hide();
            this._toolbars[type].show(options);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * TutorialsView
     * 
     * @extends View
     */
    window.TutorialsView = View.extend({

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|TutorialsModalView (default: null)
         */
        _modal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TutorialsView')
         */
        _string: 'TutorialsView',

        /**
         * _slug
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _slug: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String slug
         * @param   TutorialsModalView modal
         * @return  void
         */
        init: function(element, slug, modal) {
            this._super(element);
            this._slug = slug;
            this._modal = modal;
            this.on({
                'overlay': function(event, $div) {
                    var youTubeSlug = $div.attr('youTubeSlug'),
                        modal = Modals.showYouTubeVideo(youTubeSlug, {});
                    // modal.setFallback(this.getPath());
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  void
         */
        getPath: function() {
            return '/app/help/' + (this._slug);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[tutorials="' + (this._slug) + '"]');
            $anchor.siblings('[tutorials]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AreaView
     * 
     * @extends View
     */
    window.AreaView = View.extend({

        /**
         * _activeGroup
         * 
         * @access  protected
         * @var     null|GroupView (default: null)
         */
        _activeGroup: null,

        /**
         * _canHaveCollections
         * 
         * @access  protected
         * @var     true (default: true)
         */
        _canHaveCollections: true,

        /**
         * _children
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _children: {},

        /**
         * _contextMenu
         * 
         * @access  protected
         * @var     null|ContextMenuView (default: null)
         */
        _contextMenu: null,

        /**
         * _nav
         * 
         * @access  protected
         * @var     null|AreaNavView (default: null)
         */
        _nav: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AreaView')
         */
        _string: 'AreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @note    Below <_children> is needed because of how inheritance works
         *          with the extend.js library
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._children = {};
            this._super(element);
        },

        /**
         * canHaveCollections
         * 
         * @access  public
         * @return  Boolean
         */
        canHaveCollections: function() {
            return this._canHaveCollections;
        },

        /**
         * getActiveGroup
         * 
         * @access  public
         * @return  GroupView
         */
        getActiveGroup: function() {
            return this._activeGroup;
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String type
         * @return  GroupView
         */
        getChild: function(type) {
            return this._children[type];
        },

        /**
         * getContextMenu
         * 
         * @access  public
         * @return  ContextMenuView
         */
        getContextMenu: function() {
            return this._contextMenu;
        },

        /**
         * getHomePath
         * 
         * @access  public
         * @return  String
         */
        getHomePath: function() {
            return this.find('div.sticky a').first().attr('href');
        },

        /**
         * getNav
         * 
         * @access  public
         * @return  jQuery
         */
        getNav: function() {
            return this._nav;
        },

        /**
         * getType
         * 
         * @access  public
         * @return  String
         */
        getType: function() {
            return this._type;
        },

        /**
         * setActiveGroup
         * 
         * @access  protected
         * @param   GroupView group
         * @return  void
         */
        setActiveGroup: function(group) {
            this._activeGroup = group;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            App.getEditor().setActiveArea(this);
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            var $nav = App.getSidebar().getNav(),
                $anchor = $nav.find('[area="' + (this._type) + '"]');
            $anchor.siblings('[area]').removeClass('active');
            $anchor.addClass('active');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * GraphicsAreaView
     * 
     * @extends AreaView
     */
    window.GraphicsAreaView = AreaView.extend({

        /**
         * _resourcesSearch
         * 
         * @access  protected
         * @var     null|ResourcesSearchView (default: null)
         */
        _resourcesSearch: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicsAreaView')
         */
        _string: 'GraphicsAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'graphics')
         */
        _type: 'graphics',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
            this._setupResourceSearch();
            this._setupQueries();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new GraphicCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new GraphicContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('GraphicAreaNav', {
                categories: Categories.global.type('graphics', false)
            });
            this._nav = new GraphicAreaNavView(
                $nav,
                this,
                Categories.global.type('graphics', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupQueries
         * 
         * @access  protected
         * @return  void
         */
        _setupQueries: function() {
            var $queries = this.find('section[group="queries"]');
            this._children.queries = new GraphicQueriesGroupView(
                $queries,
                this
            );
        },

        /**
         * _setupResourceSearch
         * 
         * @access  protected
         * @return  void
         */
        _setupResourceSearch: function() {
            var total = Config.get('theNounProject').total.commas(),
                placeholder = 'Search ' + (total) + '+ royalty-free icons',
                $resourcesSearch = DataUtils.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this._resourcesSearch = new ResourcesSearchView(
                $resourcesSearch,
                this
            );
            this.find('> header').prepend($resourcesSearch);
        },

        /**
         * getResourceSearch
         * 
         * @access  public
         * @return  ResourcesSearchView
         */
        getResourceSearch: function() {
            return this._resourcesSearch;
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Boolean refresh
         * @return  void
         */
        search: function(query, refresh) {
            query = query.trim();
            query = encodeURIComponent(query);
            var path = '/app/icons/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * ImagesAreaView
     * 
     * @extends AreaView
     */
    window.ImagesAreaView = AreaView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImagesAreaView')
         */
        _string: 'ImagesAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'images')
         */
        _type: 'images',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new ImageCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new ImageContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('ImageAreaNav', {
                categories: Categories.global.type('images', false)
            });
            this._nav = new ImageAreaNavView(
                $nav,
                this,
                Categories.global.type('images', false)
            );
            this.find('> header').append($nav);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * PhotosAreaView
     * 
     * @extends AreaView
     */
    window.PhotosAreaView = AreaView.extend({

        /**
         * _resourcesSearch
         * 
         * @access  protected
         * @var     null|ResourcesSearchView (default: null)
         */
        _resourcesSearch: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotosAreaView')
         */
        _string: 'PhotosAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'photos')
         */
        _type: 'photos',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
            this._setupResourceSearch();
            this._setupQueries();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new PhotoCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new PhotoContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('PhotoAreaNav', {
                categories: Categories.global.type('photos', false)
            });
            this._nav = new PhotoAreaNavView(
                $nav,
                this,
                Categories.global.type('photos', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupQueries
         * 
         * @access  protected
         * @return  void
         */
        _setupQueries: function() {
            var $queries = this.find('section[group="queries"]');
            this._children.queries = new PhotoQueriesGroupView(
                $queries,
                this
            );
        },

        /**
         * _setupResourceSearch
         * 
         * @access  protected
         * @return  void
         */
        _setupResourceSearch: function() {
            var total = StatUtils.getPhotoPartnerImageCount(),
                placeholder = 'Search ' + (total) + '+ royalty-free photos',
                $resourcesSearch = DataUtils.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this._resourcesSearch = new ResourcesSearchView(
                $resourcesSearch,
                this
            );
            this.find('> header').prepend($resourcesSearch);
        },

        /**
         * getResourceSearch
         * 
         * @access  public
         * @return  ResourcesSearchView
         */
        getResourceSearch: function() {
            return this._resourcesSearch;
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Boolean refresh
         * @return  void
         */
        search: function(query, refresh) {
            query = query.trim();
            query = encodeURIComponent(query);
            var path = '/app/photos/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * QuotesAreaView
     * 
     * @extends AreaView
     */
    window.QuotesAreaView = AreaView.extend({

        /**
         * _resourcesSearch
         * 
         * @access  protected
         * @var     null|ResourcesSearchView (default: null)
         */
        _resourcesSearch: null,

        /**
         * _dragImage
         * 
         * @access  protected
         * @var     null|Image (default: null)
         */
        _dragImage: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuotesAreaView')
         */
        _string: 'QuotesAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'quotes')
         */
        _type: 'quotes',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._preloadDragImage();
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
            this._setupResourceSearch();
            this._setupQueries();
        },

        /**
         * _preloadDragImage
         * 
         * @access  protected
         * @return  void
         */
        _preloadDragImage: function() {
            var url = window.STATIC + Config.default('quoteDragImagePath'),
                image = new Image();
            image.onload = function() {
                image.width = this.width;
                image.height = this.height;
            };
            image.src = url;
            this._dragImage = image;
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new QuoteCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new QuoteContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('QuoteAreaNav', {
                categories: Categories.global.type('quotes', false)
            });
            this._nav = new QuoteAreaNavView(
                $nav,
                this,
                Categories.global.type('quotes', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupQueries
         * 
         * @access  protected
         * @return  void
         */
        _setupQueries: function() {
            var $queries = this.find('section[group="queries"]');
            this._children.queries = new QuoteQueriesGroupView(
                $queries,
                this
            );
        },

        /**
         * _setupResourceSearch
         * 
         * @access  protected
         * @return  void
         */
        _setupResourceSearch: function() {
            var total = StatUtils.getAlgoliaQuotesCount(),
                placeholder = 'Search ' + (total) + '+ quotes',
                $resourcesSearch = DataUtils.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this._resourcesSearch = new ResourcesSearchView(
                $resourcesSearch,
                this
            );
            this.find('> header').prepend($resourcesSearch);
        },

        /**
         * getDragImage
         * 
         * @access  public
         * @return  Image
         */
        getDragImage: function() {
            return this._dragImage;
        },

        /**
         * getResourceSearch
         * 
         * @access  public
         * @return  ResourcesSearchView
         */
        getResourceSearch: function() {
            return this._resourcesSearch;
        },

        /**
         * search
         * 
         * @access  public
         * @param   String query
         * @param   Boolean refresh
         * @return  void
         */
        search: function(query, refresh) {
            query = query.trim();
            query = encodeURIComponent(query);
            var path = '/app/quotes/search/' + (query);
            Stencil.navigate(path, true, refresh);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * TemplatesAreaView
     * 
     * @extends AreaView
     */
    window.TemplatesAreaView = AreaView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplatesAreaView')
         */
        _string: 'TemplatesAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'templates')
         */
        _type: 'templates',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new TemplateCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new TemplateContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('TemplateAreaNav', {
                categories: Categories.global.type('templates', false)
            });
            this._nav = new TemplateAreaNavView(
                $nav,
                this,
                Categories.global.type('templates', false)
            );
            this.find('> header').append($nav);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * UploadsAreaView
     * 
     * @extends AreaView
     */
    window.UploadsAreaView = AreaView.extend({

        /**
         * _dropzone
         * 
         * @access  protected
         * @var     null|DropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadsAreaView')
         */
        _string: 'UploadsAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'uploads')
         */
        _type: 'uploads',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupDropzone();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new UploadCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new UploadContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('UploadAreaNav', {
                categories: Categories.global.type('uploads', false)
            });
            this._nav = new UploadAreaNavView(
                $nav,
                this,
                Categories.global.type('uploads', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupDropzone
         * 
         * @access  protected
         * @return  void
         */
        _setupDropzone: function() {
            var $dropzone = this.find('.dropzone'),
                children = this._children;
            this._dropzone = new DropzoneView($dropzone, 'image');
            this._dropzone.on({
                'complete': function(event, uploadAccessor) {
                    var category = Categories.account.list('uploads'),
                        key = category.get('key'),
                        results = children.categories.getChild(key),
                        collection = results.getCollection();
                    results.scrollToTop();
                    Track.event('Image uploaded');
                    collection.map(uploadAccessor.data(), false);
                    Stencil.navigate('/app/uploads');
                    category.features.add.apply(category, [uploadAccessor]);
                    uploadAccessor.getModel().feature(
                        uploadAccessor.get('key'),
                        {
                            category: category.get('key')
                        }
                    );
                }
            });
        },

        /**
         * getDropzone
         * 
         * @access  public
         * @return  DropzoneView
         */
        getDropzone: function() {
            return this._dropzone;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaView', function() {

    /**
     * WatermarksAreaView
     * 
     * @extends AreaView
     */
    window.WatermarksAreaView = AreaView.extend({

        /**
         * _canHaveCollections
         * 
         * @access  protected
         * @var     false (default: false)
         */
        _canHaveCollections: false,

        /**
         * _dropzone
         * 
         * @access  protected
         * @var     null|DropzoneView (default: null)
         */
        _dropzone: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarksAreaView')
         */
        _string: 'WatermarksAreaView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'watermarks')
         */
        _type: 'watermarks',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupContextMenu();
            this._setupDropzone();
            this._setupNav();
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section[group="categories"]');
            this._children.categories = new WatermarkCategoriesGroupView(
                $categories,
                this
            );
        },

        /**
         * _setupContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenu: function() {
            var $element = this.find('div.contextMenu');
            this._contextMenu = new WatermarkContextMenuView(
                $element,
                this
            );
        },

        /**
         * _setupNav
         * 
         * @access  protected
         * @return  void
         */
        _setupNav: function() {
            var $nav = DataUtils.render('WatermarkAreaNav', {
                categories: Categories.global.type('watermarks', false)
            });
            this._nav = new WatermarkAreaNavView(
                $nav,
                this,
                Categories.global.type('watermarks', false)
            );
            this.find('> header').append($nav);
        },

        /**
         * _setupDropzone
         * 
         * @note    Because the complete event does not get fired within the flow
         *          of a mouseup or keyup event, it's important to trigger the
         *          ChangeHistory.track method here, to ensure it's tracked at
         *          the right moment.
         * @access  protected
         * @return  void
         */
        _setupDropzone: function() {
            var $dropzone = this.find('.dropzone'),
                children = this._children;
            this._dropzone = new WatermarksDropzoneView($dropzone, 'watermark');
            this._dropzone.on({
                'complete': function(event, watermarkUploadAccessor) {
                    var category = Categories.account.list('watermarks'),
                        key = category.get('key'),
                        collections = {
                            account: Stencil.account().collection('watermarks'),
                            category: children.categories.getChild(key).getCollection()
                        };
                    watermarkUploadAccessor.setDefaultSettings();
                    watermarkUploadAccessor.addToCanvas(true);
                    App.triggerHandler('changeHistory/track');
                    Track.event('Watermark uploaded');
                    collections.account.map(watermarkUploadAccessor.data(), false);
                    collections.category.map(watermarkUploadAccessor.data(), false);
                    Stencil.navigate('/app/logos');
                    category.features.add.apply(category, [watermarkUploadAccessor]);
                    watermarkUploadAccessor.getModel().feature(
                        watermarkUploadAccessor.get('key'),
                        {
                            category: category.get('key')
                        }
                    );
                }
            });
        },

        /**
         * getDropzone
         * 
         * @access  public
         * @return  DropzoneView
         */
        getDropzone: function() {
            return this._dropzone;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AreaNavView
     * 
     * @extends View
     */
    window.AreaNavView = View.extend({

        /**
         * _area
         * 
         * @access  protected
         * @var     false|AreaView (default: false)
         */
        _area: false,

        /**
         * _categories
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _categories: [],

        /**
         * _closable
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _closable: true,

        /**
         * _collectionResults
         * 
         * @access  protected
         * @var     false|CollectionResultsView (default: false)
         */
        _collectionResults: false,

        /**
         * _previousCategory
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _previousCategory: null,

        /**
         * _pulse
         * 
         * This is a reference to the timeout of the current (if any) pulse
         * going on. This is needed to cancel any pulses before starting a new
         * one.
         * 
         * @access  protected
         * @var     false|Number (default: false)
         */
        _pulse: false,

        /**
         * _secondaryBlurDelay
         * 
         * The number of milliseconds to wait before blurring the secondary
         * nav, to allow for slight errors in a mouse movement whereby the mouse
         * temporarily moves out of the relevant area while moving towards the
         * secondary nav.
         * 
         * @access  protected
         * @var     Number (default: 200)
         */
        _secondaryBlurDelay: 200,

        /**
         * _selectedCategory
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _selectedCategory: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AreaNavView')
         */
        _string: 'AreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @param   Array categories
         * @return  void
         */
        init: function(element, area, categories) {
            this._super(element);
            this._area = area;
            this._categories = categories;
            if (this._area.canHaveCollections() === true) {
                this._setupCollectionSubnav();
                this._setupCollectionsListeners();
            }
            this._addSelectListener();
            this._setupCountListeners();
            this._setupPinKeyListeners();
            this._setupPopover();
            this._setupTooltips();
            this.secondary.delayReferences = [];
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this.on({
                'select': function(event, category) {
                    if (this._previousCategory !== null) {
                        this._previousCategory.unbind('change/name', this.updateName.proxy(this));
                    }
                    this._selectedCategory.on({
                        'change/name': this.updateName.proxy(this)
                    });
                    this.updateName();
                }
            });
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            var _this = this,
                index;
            for (index in this._categories) {
                this.addCategoryCountChangeListener(this._categories[index]);
            }
        },

        /**
         * _setupPinKeyListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupPinKeyListeners: function() {
            var _this = this,
                index;
            for (index in this._categories) {
                this.addPinKeyChangeListener(this._categories[index]);
            }

            // 
            // (function() {
            //     var selectors = [
            //         'div.sticky a > div.icon[style*="/if_els"]',
            //         'div.curated a > div.icon[style*="/if_els"]'
            //     ];
            //     var $icons = this.find(selectors.join(','));
            //     $icons.each(function(index, icon) {
            //         var $icon = $(icon),
            //             backgroundImage = $icon.css('background-image'),
            //             key = backgroundImage.match(/([^\/]+)$/)[0].replace(')', '').replace('"', '');
            //         console.log(
            //             Images.thumb(key, {
            //                 type: 'thumb'
            //             })
            //         );
            //     });
            // }).delay(1000, this);
        },

        /**
         * _setupPopover
         * 
         * @access  protected
         * @return  void
         */
        _setupPopover: function() {
            this.on({
                'menu/close': function(event) {
                    this.find('> div.filter').removeClass('expanded');
                    this.secondary.hide.apply(this);
                },
                'menu/open': function(event) {
                    var _this = this;
                    this.find('> div.filter').addClass('expanded');

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                if (_this.closable() === true) {
                                    var $target = $(event.target);
                                    if ($target.parents('div.popover').length === 0) {
                                        _this.triggerHandler('menu/close');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (_this.closable() === true) {
                                    if (event.which === 27) {
                                        _this.triggerHandler('menu/close');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                }
            });
        },

        /**
         * _setupCollectionsListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionsListeners: function() {
            var selectors = [
                    'div.sticky a:not([lookup="viewCollections"])',
                    'div.curated a:not([lookup="viewCollections"])'
                ],
                _this = this,
                secondaryBlurDelay = this._secondaryBlurDelay;
            this.find(selectors.join(',')).on({
                'mouseenter': function(event) {
                    _this.secondary.delayReferences.push(
                        _this.secondary.hide.delay(secondaryBlurDelay, _this)
                    );
                }
            });
            this.find('a[lookup="viewCollections"]').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                    _this.secondary.show.apply(_this);
                }
            });
            this.find('div.collections').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                }
            });
        },

        /**
         * _setupCollectionSubnav
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionSubnav: function() {
            var $collection = this.find('div.collections'),
                areaType = this._area.getType(),
                customCategories = Categories.account.custom(areaType).slice().reverse();
            this._collectionResults = new CollectionResultsView(
                $collection,
                this._area
            );
            this._collectionResults.getCollection().add(customCategories);
            this._collectionResults.showHideEmptyState();
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * addCategoryCountChangeListener
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        addCategoryCountChangeListener: function(category) {
            var _this = this;
            category.on({
                'change/count': function(event, newValue, oldValue) {
                    var path, selector, $count;
                    path = this.getPath();
                    selector = 'a[href="' + (path) + '"] div[lookup="count"]';
                    $count = _this.find(selector);
                    $count.text(newValue.commas());
                }
            });
        },

        /**
         * addPinKeyChangeListener
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        addPinKeyChangeListener: function(category) {
            var _this = this;
            category.on({
                'change/pinKey': function(event, newValue) {
                    var path, selector, $pin;
                    path = this.getPath();
                    selector = 'a[href="' + (path) + '"] > div.icon';
                    $pin = _this.find(selector),
                    pinUrl = category.getPinUrl();
                    $pin.css({
                        'background-image': 'url(' + (pinUrl) + ')'
                    });
                }
            });
        },

        /**
         * closable
         * 
         * @note    Works as a getter/setter
         * @access  public
         * @param   undefined|Boolean closable
         * @return  Boolean|void
         */
        closable: function(closable) {
            if (closable === undefined) {
                return this._closable === true;
            }
            this._closable = closable === true;
        },

        /**
         * getCollectionResults
         * 
         * @access  public
         * @return  CollectionResultsView
         */
        getCollectionResults: function() {
            return this._collectionResults;
        },

        /**
         * hideResultsLabel
         * 
         * @access  public
         * @return  void
         */
        hideResultsLabel: function() {
            this.find('label.category').removeClass('hidden');
            this.find('label.results').addClass('hidden');
        },

        /**
         * pulse
         * 
         * @access  protected
         * @return  void
         */
        pulse: function() {
            var _this = this,
                $anchor = this.find('div.favorites a'),
                trigger = function() {
                    $anchor.addClass('pulse');
                },
                cleanup = function() {
                    this._pulse = false;
                    $anchor.removeClass('pulse');
                };
            if (this._pulse !== false) {
                TimeoutPool.clear(this._pulse);
                $anchor.removeClass('pulse');
                trigger.delay(0);
                this._pulse = cleanup.delay(1200, this);
            } else {
                trigger.apply();
                this._pulse = cleanup.delay(1200, this);
            }
        },

        /**
         * secondary
         * 
         * @access  public
         * @var     Object
         */
        secondary: {

            /**
             * clearDelays
             * 
             * @access  public
             * @return  void
             */
            clearDelays: function() {
                var delayReferences = this.secondary.delayReferences,
                    index;
                for (index in delayReferences) {
                    TimeoutPool.clear(delayReferences[index]);
                }
            },

            /**
             * delayReferences
             * 
             * @access  public
             * @return  Array (default: [])
             */
            delayReferences: [],

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                this.find('.popover').removeClass('expanded');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                this.find('.popover').addClass('expanded');
                var $activeAnchor = this.find('.secondary a.active');
                if ($activeAnchor.length > 0) {
                    $activeAnchor.parent().data('view').scrollTo(0);
                }
            }
        },

        /**
         * select
         * 
         * @access  public
         * @param   CategoryAccessor category
         * @return  void
         */
        select: function(category) {
            var path = category.getPath(),
                $anchor = this.find('a[href="' + (path) + '"]');
            this.triggerHandler('menu/close');
            this.find('a.active').removeClass('active');
            $anchor.addClass('active');
            this.hideResultsLabel();
            if (category !== this._selectedCategory) {
                this._previousCategory = this._selectedCategory;
                this._selectedCategory = category;
                this.triggerHandler('select', [this._selectedCategory]);
            }
        },

        /**
         * showResultsLabel
         * 
         * @access  public
         * @return  void
         */
        showResultsLabel: function() {
            this.find('label.category').addClass('hidden');
            this.find('label.results').removeClass('hidden');
            this.find('a.active').removeClass('active');
        },

        /**
         * updateName
         * 
         * @access  public
         * @return  void
         */
        updateName: function() {
            var name = this._selectedCategory.getLabelName(),
                $categoryLabel = this.find('label.category');
            $categoryLabel.find('span.copy').text(name);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('GroupView', function() {

    /**
     * CategoriesGroupView
     * 
     * @extends GroupView
     */
    window.CategoriesGroupView = GroupView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoriesGroupView')
         */
        _string: 'CategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   String key
         * @return  void
         */
        _drawChild: function(key) {
            var category = Stencil.getAccessor(key),
                key = category.get('key'),
                $results = DataUtils.render(this._drawProperties.template, {
                    category: category
                });
            this._element.append($results);
            this._children[key] = new window[this._drawProperties.view](
                $results,
                this,
                category
            );
            var _this = this;
            this._children[key].on({
                'destroy': function(event) {
                    delete _this._children[key];
                }
            });
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String key
         * @return  PhotoCategoryResultsView
         */
        getChild: function(key) {
            if (this._super(key) === undefined) {
                this._drawChild(key);
            }
            return this._super(key);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResultsView', function() {

    /**
     * CategoryResultsView
     * 
     * @extends ResultsView
     */
    window.CategoryResultsView = ResultsView.extend({

        /**
         * _category
         * 
         * @access  protected
         * @var     null|CategoryAccessor (default: null)
         */
        _category: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CategoryResultsView')
         */
        _string: 'CategoryResultsView',

        /**
         * init
         * 
         * @note    Important for the category to be set before the parent
         *          constructor is called.
         * @access  public
         * @param   jQuery element
         * @param   CategoriesGroupView categoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, categoriesGroup, category) {
            this._category = category;
            this._super(element, categoriesGroup);
            this.on({
                'destroy': function(event) {
                    this._collection.empty();
                    this._element.remove();
                }
            });
            // this._collection.on({
            //     'add': function(event) {
            //         category.set('count', this.length());
            //     }
            // });
            this._setupAuthCollectionEmpty();
            this._setupAuthSort();
        },

        /**
         * _setupAuthCollectionEmpty
         * 
         * Ensures that after a User/login event, if these results are for a
         * category that is owned by an account, empty it out (since the
         * after the user logs in, the content needs to be reloaded to ensure it
         * properly represents the recently logged in user).
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthCollectionEmpty: function() {
            var _this,
                accountId = this._category.get('accountId').toInt();
            if (accountId !== 0) {
                var _this = this;
                User.once({
                    'login': function(event, user) {
                        _this.triggerHandler('destroy');
                    }
                });
            }
        },

        /**
         * _setupAuthSort
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthSort: function() {
            if (this._category.get('accountId').toInt() === 0) {
                if (
                    User.admin() === true
                    || User.editor() === true
                ) {
                    this._setupSort();
                }
                var _this = this;
                User.once({
                    'login': function(event, user) {
                        if (
                            User.admin() === true
                            || User.editor() === true
                        ) {
                            _this._setupSort();
                        }
                    }
                });
            } else {
                this._setupSort();
            }
        },

        /**
         * _setupSort
         * 
         * @see     https://github.com/RubaXa/Sortable
         * @access  protected
         * @return  void
         */
        _setupSort: function() {
            var _this = this,
                list = this.find('.inner')[0];
            this._element.addClass('sortable');
            Sortable.create(list, {
                scroll: true,
                handle: '.move',
                ghostClass: 'ghost',
                onEnd: function(event) {
                    /**
                     * For some reason, after a sort has been performed, the
                     * Sortable class seems to set the draggable attribute
                     * of the a.overlay (and all child-elements of the along
                     * with the parent element itself) to false. So I simply
                     * reinstate this.
                     */
                    App.getEditor().getJoystick().find('a.overlay').attr(
                        'draggable',
                        'true'
                    );
                },
                onUpdate: function(event) {
                    var accessor = $(event.item).data('accessor');
                    _this._collection.move(accessor, event.newIndex);
                }
            });

            // Trigger server side sync after debounced delay
            var delay = Stencil.getSaveDelay('sort');
            this._collection.on({
                'move': _.debounce(
                    this._collection.sort.proxy(this._collection, [this._category]),
                    delay
                )
            });
        },

        /**
         * getCategory
         * 
         * @access  public
         * @return  CategoryAccessor
         */
        getCategory: function() {
            return this._category;
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            return this._category.getPath();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                nav = area.getNav(),
                path = this._category.getPath();
            App.getSidebar().updatePath(area, path);
            nav.select(this._category);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * CollectionResultsView
     * 
     * @extends View
     */
    window.CollectionResultsView = View.extend({

        /**
         * _area
         * 
         * @access  protected
         * @var     false|AreaView (default: false)
         */
        _area: false,

        /**
         * _childrenCanBeSorted
         * 
         * @access  protected
         * @var     true|Boolean (default: true)
         */
        _childrenCanBeSorted: true,

        /**
         * _children
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _children: [],

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|CategoriesCollection (default: null)
         */
        _collection: null,

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'CollectionRow',
            view: 'CollectionRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CollectionResultsView')
         */
        _string: 'CollectionResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._children = [];
            this._area = area;
            this._super(element);
            this._addCreateCollectionListener();
            this._addHelpListener();
            if (this._area.canHaveCollections() === true) {
                this._setupCollection();
            }
            if (this._childrenCanBeSorted === true) {
                this._setupSort();
            }
        },

        /**
         * _addCreateCollectionListener
         * 
         * @access  protected
         * @return  void
         */
        _addCreateCollectionListener: function() {
            this.on({
                'createCollection': function(event, $anchor) {
                    if (User.exists() === false) {
                        var nav = this._area.getNav(),
                            contextMenu = this._area.getContextMenu();
                        nav.triggerHandler('menu/close');
                        contextMenu.triggerHandler('close');
                        Stencil.navigate('/app/signup');
                    } else {
                        var showAutoFeaturingMessaging = true;
                        if (this === this._area.getNav().getCollectionResults()) {
                            showAutoFeaturingMessaging = false;
                        }
                        var areaType = this._area.getType(),
                            modal = Modals.showCreateCollection(
                                areaType,
                                showAutoFeaturingMessaging
                            ),
                            _this = this;
                        this._area.getNav().closable(false);
                        this._area.getContextMenu().closable(false);
                        modal.find('input').select();
                        modal.on({
                            'close': function(event) {
                                _this._area.getNav().closable(true);
                                _this._area.getContextMenu().closable(true);
                            },
                            'save': function(event, object) {
                                var collectionResults = {
                                        contextMenu: _this._area.getContextMenu().getCollectionResults(),
                                        nav: _this._area.getNav().getCollectionResults()
                                    },
                                    collections = {
                                        contextMenu: collectionResults.contextMenu.getCollection(),
                                        nav: collectionResults.nav.getCollection()
                                    },
                                    accessors = {
                                        contextMenu: collections.contextMenu.map(object),
                                        nav: collections.nav.map(object)
                                    },
                                    categories = Stencil.get('account').collection('categories');
                                this.triggerHandler.delay(750, this, ['close']);
                                collections.contextMenu.triggerHandler('update');
                                collections.nav.triggerHandler('update');
                                collectionResults.contextMenu.sort();
                                collectionResults.nav.sort();
                                categories.add(accessors.contextMenu[0]);
                                _this._area.getContextMenu().updateCollectionResultRowStates();

                                // Scrolling
                                var relevantCollectionResults = collectionResults.contextMenu;
                                if (_this === collectionResults.nav) {
                                    relevantCollectionResults = _this;
                                }
                                var length = relevantCollectionResults.getChildren().length,
                                    child = relevantCollectionResults.getChildren()[length - 1];
                                if (_this !== collectionResults.nav) {
                                    child.toggle();
                                }
                                (function() {
                                    if (child.visible() === false) {
                                        child.scrollTo(undefined, function() {
                                            child.highlight();
                                        });
                                    } else {
                                        child.highlight();
                                    }
                                }).delay(750);
                            }
                        });
                    }
                }
            });
        },

        /**
         * _addHelpListener
         * 
         * @access  protected
         * @return  void
         */
        _addHelpListener: function() {
            this.on({
                'showCollectionsIntro': function(event, $anchor) {
                    if ('HS.beacon.show'.validMethod() === true) {
                        HS.beacon.show('59e4c4e42c7d3a752de11f73');
                    }
                }
            });
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @param   Number position
         * @return  CollectionRowView
         */
        _drawChild: function(category, position) {
            var $element = DataUtils.render(this._drawProperties.template, {
                category: category
            });
            if (position === 0) {
                this._element.find('div.inner').prepend($element);
            } else {
                this._element.find('div.inner').append($element);
            }
            var child = new window[this._drawProperties.view](
                $element,
                category,
                this
            );
            this._children.push(child);
            $element.data('category', category);
            $element.data('view', child);
            return child;
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new CategoriesCollection();
            this._collection.on({
                'add': function(event, categoryAccessor, position) {
                    _this._drawChild(categoryAccessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                },
                'remove': function(event, categoryAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getCategory() === categoryAccessor) {
                            children[index].getElement().remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                }
            });
        },

        /**
         * _setupSort
         * 
         * @see     https://github.com/RubaXa/Sortable
         * @access  protected
         * @return  void
         */
        _setupSort: function() {
            var _this = this,
                list = this._element.find('div.results div.inner')[0];
            Sortable.create(list, {
                scroll: true,
                handle: '.move',
                ghostClass: 'ghost',
                chosenClass: 'chosen',
                setData: function(dataTransfer) {
                    // dragGhost = dragEl.cloneNode(true);
                    // dragGhost.classList.add('custom-drag-ghost');
                    // document.body.appendChild(dragGhost);
                    // dataTransfer.setDragImage(dragGhost, 0, 0);
                },
                onEnd: function() {
                    $(list).removeClass('active');
                },
                onStart: function() {
                    $(list).addClass('active');
                },
                onUpdate: function(event) {
                    var accessor = $(event.item).data('category');
                    _this._collection.move(accessor, event.newIndex);
                    _this._area.getContextMenu().getCollectionResults().getCollection().move(accessor, event.newIndex);
                }
            });

            // Trigger server side sync after debounced delay
            var delay = Stencil.getSaveDelay('category.sort');
            this._collection.on({
                'move': _.debounce(
                    this._collection.sort.proxy(this._collection),
                    delay
                )
            });
        },

        /**
         * getArea
         * 
         * @access  public
         * @return  AreaView
         */
        getArea: function() {
            return this._area;
        },

        /**
         * getChildren
         * 
         * @access  public
         * @return  Array
         */
        getChildren: function() {
            return this._children;
        },

        /**
         * getCollection
         * 
         * @access  public
         * @return  Collection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * showHideEmptyState
         * 
         * Shows or hides the appropriate section depending on whether there are
         * any custom categories.
         * 
         * @access  public
         * @return  void
         */
        showHideEmptyState: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty').addClass('hidden');
            if (this._collection.all().length === 0) {
                this.find('.results').addClass('hidden');
                this.find('.messaging,.empty').removeClass('hidden');
            }
        },

        /**
         * sort
         * 
         * @access  public
         * @return  void
         */
        sort: function() {
            if (Config.default('collectionSortOrder') === 'alphabetical') {
                var $inner = this.find('div.inner'),
                    selector = '> div.collectionRow';
                $inner.get(0).orderAlphabeticallyByText(selector);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * CollectionRowView
     * 
     * @extends View
     */
    window.CollectionRowView = View.extend({

        /**
         * _category
         * 
         * @access  protected
         * @var     false|CategoryAccessor (default: false)
         */
        _category: false,

        /**
         * _collectionResults
         * 
         * @access  protected
         * @var     false|CollectionResultsView (default: false)
         */
        _collectionResults: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CollectionRowView')
         */
        _string: 'CollectionRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CategoryAccessor category
         * @param   CollectionResultsView collectionResults
         * @return  void
         */
        init: function(element, category, collectionResults) {
            this._category = category;
            this._collectionResults = collectionResults;
            this._super(element, category);
            this._addCategoryCountChangeListener();
            this._addRowListeners();
        },

        /**
         * _addCategoryCountChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _addCategoryCountChangeListener: function() {
            var _this = this;
            this._category.on({
                'change/count': function(event, newValue, oldValue) {
                    var commaValue = newValue.toInt().commas();
                    _this.find('div.count').html(commaValue);
                }
            });
        },

        /**
         * _addConfirmDeleteListener
         * 
         * @access  protected
         * @return  void
         */
        _addConfirmDeleteListener: function() {
            this.on({
                'confirm/delete': function(event, $anchor) {
                    this._confirmDelete();
                }
            });
        },

        /**
         * _addEditListener
         * 
         * @access  protected
         * @return  void
         */
        _addEditListener: function() {
            this.on({
                'edit': function(event, $anchor) {
                    this._edit();
                }
            });
        },

        /**
         * _addNameChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _addNameChangeListener: function() {
            var _this = this;
            this._category.on({
                'change/name': function(event, newValue, oldValue) {
                    _this.find('div.copy').text(newValue);
                    var key = _this._category.get('key'),
                        selector = 'div.filter label.category[category="' + (key) + '"] span.copy';
                    App.find(selector).html(newValue);
                    _this._collectionResults.sort();
                }
            });
        },

        /**
         * _addRowListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRowListeners: function() {
            this._addConfirmDeleteListener();
            this._addEditListener();
            this._addNameChangeListener();
            this._addSlugChangeListener();
        },

        /**
         * _addSlugChangeListener
         * 
         * @access  protected
         * @return  void
         */
        _addSlugChangeListener: function() {
            var _this = this;
            this._category.on({
                'change/slug': function(event, newValue, oldValue) {
                    var path = this.getPath();
                    _this.getElement().find('> a').attr('href', path);
                }
            });
        },

        /**
         * _confirmDelete
         * 
         * @access  protected
         * @return  void
         */
        _confirmDelete: function() {
            var _this = this,
                question = 'Are you sure you want to delete this collection?',
                modal = Modals.showConfirmDelete(question);
            this._getArea().getNav().closable(false);
            modal.getElement().addClass('warning');
            modal.on({
                'close': function(event) {
                    _this._getArea().getNav().closable(true);
                },
                'yes': function(event) {
                    _this._category.delete();
                    this.triggerHandler('leave');

                    // Navigate home if focused on the category
                    var activeResults = _this._getActiveResults();
                    if (activeResults.category() === true) {
                        if (activeResults.getCategory() === _this._category) {
                            var path = _this._getArea().getHomePath(),
                                nav = _this._getArea().getNav();
                            Stencil.navigate(path);
                            nav.triggerHandler('menu/open');
                            nav.secondary.show.apply(nav);
                        }
                    }
                },
                'no': function(event) {
                    this.triggerHandler('leave');
                }
            });
        },

        /**
         * _edit
         * 
         * @access  protected
         * @return  void
         */
        _edit: function() {
            var _this = this,
                category = this._category,
                modal = Modals.showRename(category, 'name');
            modal.find('input').select();
            this._getArea().getNav().closable(false);
            modal.on({
                'close': function(event) {
                    _this._getArea().getNav().closable(true);
                },
                'save': function(event, object) {
                    category.set({
                        name: object.name,
                        slug: object.slug
                    });
                    this.triggerHandler.delay(500, this, ['close']);
                    _this._collectionResults.getCollection().triggerHandler('update');

                    // Scrolling
                    (function() {
                        if (_this.visible() === false) {
                            _this.scrollTo(undefined, function() {
                                _this.highlight();
                            });
                        } else {
                            _this.highlight();
                        }
                    }).delay(500);

                    // Navigate home if focused on the category
                    var activeResults = _this._getActiveResults();
                    if (activeResults.category() === true) {
                        if (activeResults.getCategory() === _this._category) {
                            var path = category.getPath();
                            Stencil.navigate(path, false);
                        }
                    }
                }
            });
        },

        /**
         * _getArea
         * 
         * @access  protected
         * @return  AreaView
         */
        _getArea: function() {
            return this._collectionResults.getArea();
        },

        /**
         * _getActiveResults
         * 
         * @access  protected
         * @return  ResultsView
         */
        _getActiveResults: function() {
            return this._getArea().getActiveGroup().getActiveResults();
        },

        /**
         * _parentHasScrollbar
         * 
         * @access  protected
         * @return  Boolean
         */
        _parentHasScrollbar: function() {
            var $parent = this._element.parent();
            return $parent.get(0).scrollHeight > $parent.height();
        },

        /**
         * getCategory
         * 
         * @access  public
         * @return  CategoryAccessor
         */
        getCategory: function() {
            return this._category;
        },

        /**
         * highlight
         * 
         * @access  public
         * @return  void
         */
        highlight: function() {
            // var animationClassName = 'shake';
            var animationClassName = 'flicker';
            this._element.addClass(animationClassName);
            this._element.removeClass.delay(750, this._element, [
                animationClassName
            ]);
        },

        /**
         * scrollTo
         * 
         * @access  public
         * @param   undefined|Number duration (optional)
         * @param   undefined|Function callback (optional)
         * @return  void
         */
        scrollTo: function(duration, callback) {
            if (this._parentHasScrollbar() === true) {
                var $element = this.getElement(),
                    $parent = $element.parent();
                $parent.scrollTo($element, duration, callback);
            }
        },

        /**
         * visible
         * 
         * @access  public
         * @return  Boolean
         */
        visible: function() {
            var $parent = this._element.parent(),
                percentageVisible = this._element.percentageVisible($parent);
            if (percentageVisible < 25) {
                return false;
            }
            return true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ContextMenuView
     * 
     * @extends View
     */
    window.ContextMenuView = View.extend({

        /**
         * _$relative
         * 
         * @access  protected
         * @var     jQuery (default: null)
         */
        _$relative: null,

        /**
         * _area
         * 
         * @access  protected
         * @var     AreaView (default: null)
         */
        _area: null,

        /**
         * _closable
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _closable: true,

        /**
         * _collectionResults
         * 
         * @access  protected
         * @var     false|CollectionResultsView (default: false)
         */
        _collectionResults: false,

        /**
         * _delays
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            multiple: {
                delete: 650,
                // favorite: 650,
                trailing: 750,
                // unfavorite: 650
            }
        },

        /**
         * _secondaryBlurDelay
         * 
         * The number of milliseconds to wait before blurring the secondary
         * nav, to allow for slight errors in a mouse movement whereby the mouse
         * temporarily moves out of the relevant area while moving towards the
         * secondary nav.
         * 
         * @access  protected
         * @var     Number (default: 200)
         */
        _secondaryBlurDelay: 200,

        /**
         * _showing
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _showing: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ContextMenuView')
         */
        _string: 'ContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._area = area;
            this._super(element);
            this.secondary.delayReferences = [];
            if (this._area.canHaveCollections() === true) {
                this._setupCollectionSubContextMenu();
                this._setupCollectionsListeners();
            }
            // this._addCloseListeners();
        },

        /**
         * _addCloseListeners
         * 
         * @access  protected
         * @return  void
         */
        _addCloseListeners: function() {
            var _this = this,
                $app = App.getElement(),
                view = this._getView(),
                callback = function() {
                    if (this.closable() === true) {
                        this.hide();
                        this.secondary.hide.apply(this);
                        $app.unbind('mousedown', handlers['body/mousedown']);
                        $app.unbind('keydown', handlers['body/keydown/escape']);
                        Stencil.getRouter().unbind('route', handlers['route']);
                        this.unbind('close', handlers['close']);
                        view.getResults().removeScrollEvent(
                            handlers['results/scroll']
                        );
                    }
                },
                handlers = {
                    'body/mousedown': function(event) {
                        var $target = $(event.target);
                        if ($target.parents('div.contextMenu').length === 0) {
                            callback.apply(_this);
                        }
                    },
                    'body/keydown/escape': function(event) {
                        if (event.which === 27) {
                            callback.apply(_this);
                        }
                    },
                    'close': function(event) {
                        callback.apply(_this);
                    },
                    'results/scroll': function(event) {
                        var $results = _this._$relative.closest('.results'),
                            percentageVisible = _this._$relative.percentageVisible($results);
                        if (percentageVisible < 30) {
                            callback.apply(_this);
                            // var results = _this._area.getActiveGroup().getActiveResults();
                            // results.deselectAll();
                        } else {
                            _this.position();
                        }
                    },
                    'route': function(event) {
                        callback.apply(_this);
                    }
                };
            $app.on({
                'mousedown': handlers['body/mousedown'],
                'keydown': handlers['body/keydown/escape']
            });
            Stencil.getRouter().on({
                'route': handlers['route']
            });
            this.on({
                'close': handlers['close']
            });
            this._$relative.data('view').getResults().addScrollEvent(
                handlers['results/scroll']
            );
        },

        /**
         * _destroyTooltips
         * 
         * @access  protected
         * @return  void
         */
        _destroyTooltips: function() {
            this._element.tooltip('destroy');
        },

        /**
         * _getAccessor
         * 
         * @access  protected
         * @return  Accessor
         */
        _getAccessor: function() {
            return this._getSelected()[0].getAccessor();
        },

        /**
         * _getBusyMessage
         * 
         * @access  protected
         * @param   String type
         * @return  String
         */
        _getBusyMessage: function(type) {
            var areaType = this._area.getType(),
                key = 'multiple.' + (areaType) + '.' + (type);
            return Stencil.getMessage(key);
        },

        /**
         * _getConfirmDeleteQuestion
         * 
         * @access  protected
         * @param   Array selected
         * @return  String
         */
        _getConfirmDeleteQuestion: function(selected) {
            if (selected.length === 1) {
                return this._messages.delete.one;
            }
            var count = selected.length;
            return this._messages.delete.multiple.replace('###', count);
        },

        /**
         * _getMultipleDelay
         * 
         * @access  protected
         * @param   String action
         * @return  Number
         */
        _getMultipleDelay: function(action) {
            return this._delays.multiple[action];
        },

        /**
         * _getSelected
         * 
         * @access  protected
         * @return  Array
         */
        _getSelected: function() {
            var results = this._area.getActiveGroup().getActiveResults();
            return results.childrenSelected.all.apply(results);
        },

        /**
         * _getView
         * 
         * @access  protected
         * @return  View
         */
        _getView: function() {
            return this._$relative.data('view');
        },

        /**
         * _multipleSelected
         * 
         * @access  protected
         * @return  Boolean
         */
        _multipleSelected: function() {
            return this._getSelected().length > 1;
        },

        /**
         * _positionCaret
         * 
         * Positions the caret perfectly in the middle of the part of the thumb
         * that is currently visible.
         * 
         * @note    The check for the relative offset being less than 200 is to
         *          ensure that the percentageVisible conditional only applies
         *          when the relative is partially obstructed at the top of the
         *          scrollable area, rather than the bottom. It's a crude way of
         *          doing this, but it's effective and saves me from having to
         *          write a helper method that determines if the bleed is
         *          occuring at the top or bottom of the scrollable area.
         * @access  protected
         * @return  void
         */
        _positionCaret: function() {
            var $relative = this._$relative,
                $container = $relative.closest('.results'),
                $caret = this.find('.stencil-caret'),
                percentageVisible = $relative.percentageVisible($container),
                relativeHeight = $relative.outerHeight().toInt(),
                heightShowing = ((relativeHeight * percentageVisible) / 100).round(0),
                middlePoint = (heightShowing / 2).round(0),
                middlePointGlobalReference = middlePoint + $relative.offset().top;
            if (percentageVisible < 100 && $relative.offset().top < 200) {
                middlePointGlobalReference = middlePoint + $container.offset().top;
            }
            var middlePointRelativeValue = middlePointGlobalReference - this._element.offset().top;
            if ($caret.css('top').toInt() !== middlePointRelativeValue) {
                $caret.css({
                    'top': (middlePointRelativeValue).round(0) + 'px'
                }); 
            }
        },

        /**
         * _positionSecondary
         * 
         * Toggles a class on and off depending on whether the secondary menu
         * would bleed past the app's viewport.
         * 
         * @access  protected
         * @return  void
         */
        _positionSecondary: function() {
            var $secondary = this.find('.secondary'),
                wouldBleedBeyondBottomOfViewport = function() {
                    var top = this._element.offset().top - App.getElement().css('padding-top').toInt(),
                        height = $secondary.outerHeight(),
                        viewportHeight = App.getElement().find('> div.content').outerHeight(),
                        bottomPadding = 9;
                    return (top + height + bottomPadding) > viewportHeight;
                };
            if (wouldBleedBeyondBottomOfViewport.apply(this) === true) {
                if (this._element.hasClass('bottomToTop') === false) {
                    this._element.addClass('bottomToTop');
                }
            } else {
                if (this._element.hasClass('bottomToTop') === true) {
                    this._element.removeClass('bottomToTop');
                }
            }
        },

        /**
         * _positionWrapper
         * 
         * @access  protected
         * @return  void
         */
        _positionWrapper: function() {

            /**
             * Left
             * 
             */
            var rightPadding = 4,
                left = this._$relative.offset().left + this._$relative.outerWidth().toInt() - this._element.parent().offset().left + rightPadding;

            /**
             * Top
             * 
             */

            // Calculated top value
            var relativeMiddlePoint = this._$relative.offset().top + (this._$relative.outerHeight() / 2).round(0),
                top = relativeMiddlePoint - this._element.css('margin-top').toInt() - (this._element.outerHeight().toInt() / 2).round(0);
            top -= App.getElement().css('padding-top').toInt();
            top = Math.max(0, top);


            // Max top
            var maxTop,
                elementMarginTop = this._element.css('margin-top').toInt(),
                elementMarginBottom = this._element.css('margin-bottom').toInt();
            maxTop = App.getElement().find('> div.content').height().toInt() - this._element.outerHeight().toInt() - elementMarginBottom - elementMarginBottom;
            // maxTop -= App.getElement()[0].scrollHeight - $(window).height();
            // maxTop += $(window).scrollTop();

            // Validate max top
            top = Math.min(top, maxTop);

            // Done
            if (
                this._element.css('left').toInt() !== left
                || this._element.css('top').toInt() !== top
            ) {
                this._element.css({
                    left: (left) + 'px',
                    top: (top) + 'px'
                });
            }
        },

        /**
         * _pulseFavoriteIcon
         * 
         * @access  protected
         * @return  void
         */
        _pulseFavoriteIcon: function() {
            var $unfavorite = this.find('[lookup="unfavorite"]'),
                $icon = $unfavorite.find('.icon');
            $icon.addClass('pulse');
            (function() {
                $icon.removeClass('pulse');
            }).delay(1200);
        },

        /**
         * _selectedHaveBeenFavorited
         * 
         * @access  protected
         * @return  Boolean
         */
        _selectedHaveBeenFavorited: function() {
            var selected = this._getSelected(),
                index = 0;
            for (index; index < selected.length; ++index) {
                if (selected[index].getAccessor().favorited() === false) {
                    return false;
                }
            }
            return true;
        },

        /**
         * _setupCollectionsListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionsListeners: function() {
            var selector = 'div.primary a:not([lookup="viewCollections"])',
                _this = this,
                secondaryBlurDelay = this._secondaryBlurDelay;
            this.find(selector).on({
                'mouseenter': function(event) {
                    _this.secondary.delayReferences.push(
                        _this.secondary.hide.delay(secondaryBlurDelay, _this)
                    );
                }
            });
            this.find('a[lookup="viewCollections"]').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                    if ($(this).attr('disabled') === undefined) {
                        _this.secondary.show.apply(_this);
                    }
                }
            });
            this.find('div.secondary').on({
                'mouseenter': function(event) {
                    _this.secondary.clearDelays.apply(_this);
                }
            });
        },

        /**
         * _setupCollectionSubContextMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupCollectionSubContextMenu: function() {
            var $collection = this.find('div.collections'),
                areaType = this._area.getType(),
                customCategories = Categories.account.custom(areaType).slice().reverse();
            this._collectionResults = new ContextMenuCollectionResultsView(
                $collection,
                this._area
            );
            this._collectionResults.getCollection().add(customCategories);
            this._collectionResults.showHideEmptyState();
        },

        /**
         * _setupConfirmDeleteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupConfirmDeleteEvent: function() {
            this.on({
                'confirm/delete': function(event, $anchor) {
                    var _this = this,
                        selected = this._getSelected(),
                        question = this._getConfirmDeleteQuestion(selected),
                        modal = Modals.showConfirmDelete(question);
                    this.triggerHandler('close');
                    modal.on({
                        'yes': function(event) {
                            if (selected.length === 1) {
                                selected[0].getAccessor().delete();
                                this.triggerHandler('leave');
                                var results = _this._area.getActiveGroup().getActiveResults();
                                results.deselectAll();
                            } else {
                                var callback = function(index) {
                                    if (index < selected.length) {
                                        this.showBusyModalProgressMessaging(
                                            index,
                                            selected
                                        );
                                        var accessor = selected[index].getAccessor(),
                                            delay = this._getMultipleDelay('delete'),
                                            areaType = this._area.getType();
                                            eventType = 'model/delete';
                                        if (areaType === 'watermarks') {
                                            eventType = 'update/usable';
                                        }
                                        accessor.once(eventType, function(event) {
                                            if ((index + 1) >= selected.length) {
                                                delay = _this._getMultipleDelay('trailing');
                                            }
                                            callback.delay(delay, _this, [index + 1]);
                                        });

                                        // Prevent image/template busy hiding
                                        if (
                                            areaType === 'images'
                                            || areaType === 'templates'
                                        ) {
                                            accessor.delete(false);
                                        } else {
                                            accessor.delete();
                                        }
                                    } else {
                                        App.getBusy().hide();
                                        this.closable(true);
                                        var results = this._area.getActiveGroup().getActiveResults();
                                        results.deselectAll();
                                    }
                                };

                                // UI
                                this.triggerHandler('leave');
                                var msg = _this._getBusyMessage('delete');
                                App.getBusy().show(msg);
                                _this.closable(false);
                                callback.apply(_this, [0]);
                            }
                        },
                        'no': function(event) {
                            this.triggerHandler('leave');
                        }
                    });
                }
            });
            // this.on({
            //     'confirm/delete': function(event, $anchor) {
            //         var _this = this,
            //             selected = this._getSelected(),
            //             question = this._getConfirmDeleteQuestion(selected),
            //             modal = Modals.showConfirmDelete(question);
            //         this.triggerHandler('close');
            //         modal.on({
            //             'yes': function(event) {
            //                 if (selected.length === 1) {
            //                     selected[0].getAccessor().delete();
            //                     this.triggerHandler('leave');
            //                     var results = _this._area.getActiveGroup().getActiveResults();
            //                     results.deselectAll();
            //                 } else {
            //                     var callback = function(index) {
            //                         if (index < selected.length) {
            //                             this.showBusyModalProgressMessaging(
            //                                 index,
            //                                 selected
            //                             );
            //                             var accessor = selected[index].getAccessor(),
            //                                 delay = this._getMultipleDelay('delete');
            //                             accessor.once({
            //                                 'model/delete': function(event) {
            //                                     if ((index + 1) >= selected.length) {
            //                                         delay = _this._getMultipleDelay('trailing');
            //                                     }
            //                                     callback.delay(delay, _this, [index + 1]);
            //                                 }
            //                             });

            //                             // Prevent image/template busy hiding
            //                             var areaType = this._area.getType();
            //                             if (
            //                                 areaType === 'images'
            //                                 || areaType === 'templates'
            //                             ) {
            //                                 accessor.delete(false);
            //                             } else {
            //                                 accessor.delete();
            //                             }
            //                         } else {
            //                             App.getBusy().hide();
            //                             this.closable(true);
            //                             var results = this._area.getActiveGroup().getActiveResults();
            //                             results.deselectAll();
            //                         }
            //                     };

            //                     // UI
            //                     this.triggerHandler('leave');
            //                     var msg = _this._getBusyMessage('delete');
            //                     App.getBusy().show(msg);
            //                     _this.closable(false);
            //                     callback.apply(_this, [0]);
            //                 }
            //             },
            //             'no': function(event) {
            //                 this.triggerHandler('leave');
            //             }
            //         });
            //     }
            // });
        },

        /**
         * _setupFavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupFavoriteEvent: function() {
            this.on({
                'favorite': function(event, $anchor) {
                    var areaType = this._area.getType();
                    if (this._multipleSelected() === false) {
                        if (
                            Account.max.favorites() === true
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {
                            this._getAccessor().favorite(areaType, true);
                            this._area.getNav().pulse();
                            this._toggleFavoriteState();
                            this._pulseFavoriteIcon();
                        }
                    } else {

                        // Get ones that can be favorited
                        var selected = this._getSelected(),
                            unfavoritedSelected = [],
                            index;
                        for (index in selected) {
                            if (selected[index].getAccessor().favorited() === false) {
                                unfavoritedSelected.push(selected[index]);
                            }
                        }

                        // Limit check
                        var account = Stencil.account();
                        if (
                            account.getFavoritesRemaining() < unfavoritedSelected.length
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {

                            // Logic
                            var accessor,
                                unfavoritedSelectedKeys = [],
                                category = Categories.account.favorites(areaType);
                            for (index in selected) {
                                if (selected[index].getAccessor().favorited() === false) {
                                    accessor = selected[index].getAccessor();
                                    accessor.favorite(areaType, false);
                                    unfavoritedSelectedKeys.push(accessor.get('key'));
                                }
                            }
                            category.featureObjects(unfavoritedSelectedKeys);

                            // UI
                            this._area.getNav().pulse();
                            this._toggleFavoriteState();
                            this._pulseFavoriteIcon();
                        }
                    }
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'right'
            });
        },

        /**
         * _setupUnfavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupUnfavoriteEvent: function() {
            this.on({
                'unfavorite': function(event, $anchor) {
                    var results = this._area.getActiveGroup().getActiveResults(),
                        currentCategory = results.getCategory(),
                        areaType = this._area.getType(),
                        favoritesCategory = Categories.account.favorites(areaType);
                    if (this._multipleSelected() === false) {
                        this._getAccessor().unfavorite(areaType, true);
                        this._toggleFavoriteState();
                        if (currentCategory === favoritesCategory) {
                            results.deselectAll();
                            this.triggerHandler('close');
                        }
                    } else {
                        var selected = this._getSelected(),
                            category = favoritesCategory,
                            featuredSelectedKeys = [],
                            index,
                            accessor;
                        for (index in selected) {
                            accessor = selected[index].getAccessor();
                            accessor.unfavorite(areaType, false);
                            featuredSelectedKeys.push(accessor.get('key'));
                        }
                        category.unfeatureObjects(featuredSelectedKeys);

                        // UI
                        this._toggleFavoriteState();
                        if (currentCategory === favoritesCategory) {
                            results.deselectAll();
                            this.triggerHandler('close');
                        }
                    }
                }
            });
        },

        /**
         * _toggleFavoriteState
         * 
         * @access  protected
         * @return  void
         */
        _toggleFavoriteState: function() {
            var $favorite = this.find('[lookup="favorite"]'),
                $unfavorite = this.find('[lookup="unfavorite"]');
            $favorite.addClass('hidden');
            $unfavorite.addClass('hidden');
            if (this._selectedHaveBeenFavorited() === false) {
                $favorite.removeClass('hidden');
            } else {
                $unfavorite.removeClass('hidden');
            }
        },

        /**
         * _toggleMultipleCountTooltip
         * 
         * @access  protected
         * @return  void
         */
        _toggleMultipleCountTooltip: function() {
            var $h3 = this.find('h3');
            $h3.tooltip('destroy');
            if (this._multipleSelected() === true) {
                var count = this._getSelected().length,
                    areaType = this._area.getType(),
                    type = areaType,
                    tooltip = '';
                if (areaType === 'graphics') {
                    type = 'icons';
                }
                tooltip = (count) + ' ' + (type) + ' selected';
                $h3.attr('data-title', tooltip);
                $h3.attr('data-original-title', tooltip);
                this._element.tooltip({
                    html: true,
                    selector: 'h3[tooltip]',
                    container: App.getElement(),
                    placement: 'right'
                });
            }
        },

        /**
         * _updateSelectedCount
         * 
         * @access  protected
         * @return  void
         */
        _updateSelectedCount: function() {
            var count = this._getSelected().length;
            // this.find('h3').find('span').text(this._getSelected().length);
            this.find('h3').html(count);
        },

        /**
         * closable
         * 
         * @note    Works as a getter/setter
         * @access  public
         * @param   undefined|Boolean closable
         * @return  Boolean|void
         */
        closable: function(closable) {
            if (closable === undefined) {
                return this._closable === true;
            }
            this._closable = closable === true;
        },

        /**
         * getCollectionResults
         * 
         * @access  public
         * @return  CollectionResultsView
         */
        getCollectionResults: function() {
            return this._collectionResults;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._showing = false;
            this._element.addClass('hidden');
            if (this._$relative) {
                if (this._multipleSelected() === false) {
                    // this._getSelected()[0].deselect();
                    // this._$relative.removeClass('active');
                }
            }
        },

        /**
         * isShowing
         * 
         * @access  public
         * @return  Boolean
         */
        isShowing: function() {
            return this._showing === true;
        },

        /**
         * position
         * 
         * @access  public
         * @return  void
         */
        position: function() {
            this._positionWrapper();
            this._positionSecondary();
            this._positionCaret();
        },

        /**
         * secondary
         * 
         * @access  public
         * @var     Object
         */
        secondary: {

            /**
             * clearDelays
             * 
             * @access  public
             * @return  void
             */
            clearDelays: function() {
                var delayReferences = this.secondary.delayReferences,
                    index;
                for (index in delayReferences) {
                    TimeoutPool.clear(delayReferences[index]);
                }
            },

            /**
             * delayReferences
             * 
             * @access  public
             * @return  Array (default: [])
             */
            delayReferences: [],

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                this._element.removeClass('expanded');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                this._element.addClass('expanded');
            }
        },

        /**
         * setRelative
         * 
         * @access  public
         * @param   jQuery $relative
         * @return  void
         */
        setRelative: function($relative) {
            this._$relative = $relative;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._showing = true;
            this._toggleFavoriteState();
            this._element.removeClass('hidden');
            this._addCloseListeners();
            this._$relative.addClass('active');
            this._element.removeClass('multiple');
            this._toggleMultipleCountTooltip();
            this._updateSelectedCount();
            if (this._area.canHaveCollections() === true) {
                this.updateCollectionResultRowStates();
            }
            if (this._multipleSelected() === true) {
                this._element.addClass('multiple');
            }
        },

        /**
         * showBusyModalProgressMessaging
         * 
         * @access  public
         * @param   Number index
         * @param   Array arr
         * @return  void
         */
        showBusyModalProgressMessaging: function(index, arr) {
            var copy = App.getBusy().find('.copy').text(),
                replacement = '(' + (index + 1) + ' of ' + (arr.length) + ')';
            copy = copy.replace(/\([^\)]+\)/, replacement);
            App.getBusy().find('.copy').text(copy);
        },

        /**
         * updateCollectionResultRowStates
         * 
         * @access  public
         * @return  void
         */
        updateCollectionResultRowStates: function() {
            this._collectionResults.updateRowStates();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CollectionResultsView', function() {

    /**
     * ContextMenuCollectionResultsView
     * 
     * @extends CollectionResultsView
     */
    window.ContextMenuCollectionResultsView = CollectionResultsView.extend({

        /**
         * _childrenCanBeSorted
         * 
         * @access  protected
         * @var     false|Boolean (default: false)
         */
        _childrenCanBeSorted: false,

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'ContextMenuCollectionRow',
            view: 'ContextMenuCollectionRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ContextMenuCollectionResultsView')
         */
        _string: 'ContextMenuCollectionResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _setupCollection
         * 
         * Listeners for the move event against the collection, and when it
         * occurs, re-orders the rows to match the appropriate order.
         * 
         * This is more complicated than it seems it ought to be, because when
         * a sort happens, the <_children> array is not actually re-ordered.
         * So I need to loop through it to find the appropriate element that
         * has been moved, and use that as a starting point.
         * 
         * After that, I then need to iterate over next / prev calls to move
         * the element to where it should be.
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            this._super();
            var _this = this;
            this._collection.on({
                'move': function(event, categoryAccessor, newPosition, oldPosition) {
                    var findChild = function(accessor) {
                        var index,
                            child;
                        for (index in this._children) {
                            child = this._children[index];
                            if (child.getCategory() === accessor) {
                                return this._children[index];
                            }
                        }
                        throw new Error('Could not find child');
                    };
                    var child = findChild.apply(_this, [
                            this._accessors[newPosition]
                        ]),
                        index = 0;
                    if (newPosition > oldPosition) {
                        for (index; index < (newPosition - oldPosition); index++) {
                            child.getElement().insertAfter(
                                child.getElement().next()
                            );
                        }
                    } else {
                        for (index; index < (oldPosition - newPosition); index++) {
                            child.getElement().insertBefore(
                                child.getElement().prev()
                            );
                        }
                    }
                }
            });
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            var index;
            for (index in this._children) {
                this._children[index].disable();
            }
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            var index;
            for (index in this._children) {
                this._children[index].enable();
            }
        },

        /**
         * sort
         * 
         * @access  public
         * @return  void
         */
        sort: function() {
            if (Config.default('collectionSortOrder') === 'alphabetical') {
                var $inner = this.find('div.inner'),
                    selector = '> div.contextMenuCollectionRow';
                $inner.get(0).orderAlphabeticallyByText(selector);
            }
        },

        /**
         * updateRowStates
         * 
         * @access  public
         * @return  void
         */
        updateRowStates: function() {
            var index;
            for (index in this._children) {
                this._children[index].adjustState();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CollectionRowView', function() {

    /**
     * ContextMenuCollectionRowView
     * 
     * @extends CollectionRowView
     */
    window.ContextMenuCollectionRowView = CollectionRowView.extend({

        /**
         * _delays
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            sequential: {
                feature: 1750,
                unfeature: 650
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ContextMenuCollectionRowView')
         */
        _string: 'ContextMenuCollectionRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CategoryAccessor category
         * @param   ContextMenuCollectionResultsView contextMenuCollectionResults
         * @return  void
         */
        init: function(element, category, contextMenuCollectionResults) {
            this._super(element, category, contextMenuCollectionResults);
        },

        /**
         * _addRowListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRowListeners: function() {
            this._addNameChangeListener();
            this._addToggleListener();
        },

        /**
         * _addToggleListener
         * 
         * @access  protected
         * @return  void
         */
        _addToggleListener: function() {
            this.on({
                'toggle': function(event, $anchor) {
                    this.toggle();
                }
            });
        },

        /**
         * _getContextMenu
         * 
         * @access  protected
         * @return  ContextMenuView
         */
        _getContextMenu: function() {
            return this._getArea().getContextMenu();
        },

        /**
         * _getSelected
         * 
         * @access  protected
         * @return  Array
         */
        _getSelected: function() {
            var activeResults = this._getActiveResults();
            return activeResults.childrenSelected.all.apply(activeResults);
        },

        /**
         * _getStateClass
         * 
         * @access  protected
         * @return  String
         */
        _getStateClass: function() {
            var selected = this._getSelected(),
                $anchor = this.find('> a');
            if (selected.length === 1) {
                var accessor = selected[0].getAccessor();
                if (accessor.featuredInCategory(this._category) === true) {
                    return 'checked';
                }
                return 'idle';
            }
            var index,
                accessor,
                count = 0;
            for (index in selected) {
                accessor = selected[index].getAccessor();
                if (accessor.featuredInCategory(this._category) === true) {
                    count++;
                }
            }
            if (count === 0) {
                return 'idle';
            }
            if (count === selected.length) {
                return 'checked';
            }
            return 'partial';
        },

        /**
         * actions
         * 
         * @access  public
         * @var     Object
         */
        actions: {

            /**
             * batch
             * 
             * @access  public
             * @var     Object
             */
            batch: {

                /**
                 * feature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                feature: function(callback) {
                    var selected = this._getSelected(),
                        category = this._category,
                        unfeaturedSelectedKeys = [],
                        index,
                        accessor;
                    for (index in selected) {
                        if (selected[index].getAccessor().featuredInCategory(category) === false) {
                            accessor = selected[index].getAccessor();
                            accessor.feature(category, false);
                            unfeaturedSelectedKeys.push(accessor.get('key'));
                        }
                    }
                    this._category.featureObjects(unfeaturedSelectedKeys);
                    callback.apply(this);
                },

                /**
                 * unfeature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                unfeature: function(callback) {
                    var selected = this._getSelected(),
                        category = this._category,
                        featuredSelectedKeys = [],
                        index,
                        accessor;
                    for (index in selected) {
                        accessor = selected[index].getAccessor();
                        accessor.unfeature(category, false);
                        featuredSelectedKeys.push(accessor.get('key'));
                    }
                    this._category.unfeatureObjects(featuredSelectedKeys);
                    callback.apply(this);
                }
            },

            /**
             * proxy
             * 
             * @access  public
             * @var     Object
             */
            proxy: {

                /**
                 * feature
                 * 
                 * Manages whether a batch request or series of single requests
                 * are made for a feature action. This is determined by checking
                 * whether any of the selected objects are a resource, in which
                 * case the feature requests must be done independently (since
                 * the Categories server-side controller can't accommodate
                 * resources).
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                feature: function(callback) {
                    var selected = this._getSelected(),
                        method = this.actions.batch.feature,
                        index,
                        accessorTypeString;
                    for (index in selected) {
                        accessorTypeString = selected[index].getAccessor().toString();
                        if (
                            accessorTypeString === 'ResourceAccessor'
                            || accessorTypeString === 'QuoteResourceAccessor'
                        ) {
                            method = this.actions.sequential.feature;
                            break;
                        }
                    }
                    method.apply(this, [callback]);
                },

                /**
                 * unfeature
                 * 
                 * Manages whether a batch request or series of single requests
                 * are made for a unfeature action. This is determined by
                 * checking whether any of the selected objects are a resource,
                 * in which case the unfeature requests must be done
                 * independently (since the Categories server-side controller
                 * can't accommodate resources).
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                unfeature: function(callback) {
                    var selected = this._getSelected(),
                        method = this.actions.batch.unfeature,
                        index,
                        accessorTypeString;
                    for (index in selected) {
                        accessorTypeString = selected[index].getAccessor().toString()
                        if (
                            accessorTypeString === 'ResourceAccessor'
                            || accessorTypeString === 'QuoteResourceAccessor'
                        ) {
                            method = this.actions.sequential.unfeature;
                            break;
                        }
                    }
                    method.apply(this, [callback]);
                }
            },

            /**
             * sequential
             * 
             * @access  public
             * @var     Object
             */
            sequential: {

                /**
                 * feature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                feature: function(callback) {

                    // Retrieve accessors that can be featured
                    this._collectionResults.disable();
                    var selected = this._getSelected(),
                        category = this._category,
                        unfeaturedSelected = [],
                        index;
                    for (index in selected) {
                        if (selected[index].getAccessor().featuredInCategory(category) === false) {
                            unfeaturedSelected.push(selected[index]);
                        }
                    }

                    // 
                    var delay = this._delays.sequential.feature,
                        featureFunction = function(index) {
                            if (index < unfeaturedSelected.length) {
                                var accessor = unfeaturedSelected[index].getAccessor(),
                                    _this = this;
                                accessor.once({
                                    'model/feature': function(event) {
                                        featureFunction.delay(delay, _this, [index + 1]);
                                    }
                                });
                                accessor.feature(category);
                            } else {
                                callback.apply(this);
                                this._collectionResults.enable();
                            }
                        };
                    featureFunction.apply(this, [0]);
                },

                /**
                 * unfeature
                 * 
                 * @access  public
                 * @param   Function callback
                 * @return  void
                 */
                unfeature: function(callback) {
                    var selected = this._getSelected(),
                        category = this._category,
                        delay = this._delays.sequential.unfeature,
                        unfeatureFunction = function(index) {
                            if (index < selected.length) {
                                var accessor = selected[index].getAccessor(),
                                    _this = this;
                                accessor.once({
                                    'model/unfeature': function(event) {
                                        unfeatureFunction.delay(delay, _this, [index + 1]);
                                    }
                                });
                                accessor.unfeature(category);
                            } else {
                                callback.apply(this);
                            }
                        };
                    unfeatureFunction.apply(this, [0]);
                }
            }
        },

        /**
         * adjustState
         * 
         * @access  public
         * @return  void
         */
        adjustState: function() {
            var $anchor = this.find('> a'),
                stateClass = this._getStateClass();
            $anchor.removeClass('idle');
            $anchor.removeClass('partial');
            $anchor.removeClass('processing');
            $anchor.removeClass('checked');
            $anchor.addClass(stateClass);
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this._element.disable();
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            this._element.enable();
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            var $anchor = this.find('> a').first();
            if ($anchor.hasClass('idle') === true) {
                $anchor.removeClass('idle');
                $anchor.addClass('processing');
                this.disable();
                this.actions.proxy.feature.apply(this, [function() {
                    $anchor.removeClass('processing');
                    $anchor.addClass('checked');
                    $anchor.find('.checked').addClass('pulse');
                    (function() {
                        $anchor.find('.checked').removeClass('pulse');
                    }).delay(1200);
                    this.enable();
                }]);
            } else if ($anchor.hasClass('partial') === true) {
                $anchor.removeClass('partial');
                $anchor.addClass('processing');
                this.disable();
                this.actions.proxy.feature.apply(this, [function() {
                    $anchor.removeClass('processing');
                    $anchor.addClass('checked');
                    $anchor.find('.checked').addClass('pulse');
                    (function() {
                        $anchor.find('.checked').removeClass('pulse');
                    }).delay(1200);
                    this.enable();
                }]);
            } else if ($anchor.hasClass('checked') === true) {
                $anchor.removeClass('checked');
                $anchor.addClass('processing');
                this.disable();
                var closeContextMenu = function() {
                    var activeResults = this._getActiveResults();
                    if (activeResults.category() === true) {
                        if (this._category === activeResults.getCategory()) {
                            return true;
                        }
                    }
                    return false;
                };
                if (closeContextMenu.apply(this) === true) {
                    this._getContextMenu().triggerHandler('close');
                }
                this.actions.proxy.unfeature.apply(this, [function() {
                    $anchor.removeClass('processing');
                    $anchor.addClass('idle');
                    this.enable();
                    if (closeContextMenu.apply(this) === true) {
                        this._getActiveResults().deselectAll();
                    }
                }]);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * GroupView
     * 
     * @extends View
     */
    window.GroupView = View.extend({

        /**
         * _activeResults
         * 
         * @access  protected
         * @var     null|ResultsView (default: null)
         */
        _activeResults: null,

        /**
         * _area
         * 
         * @access  protected
         * @var     null|AreaView (default: null)
         */
        _area: null,

        /**
         * _children
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _children: {},

        /**
         * _drawProperties
         * 
         * Defines variables, like the template and View, that ought to be used
         * when drawing results.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _drawProperties: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GroupView')
         */
        _string: 'GroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._children = {};
            this._super(element, parent);
            this._area = area;
        },

        /**
         * getActiveResults
         * 
         * @access  public
         * @return  null|ResultsView
         */
        getActiveResults: function() {
            return this._activeResults;
        },

        /**
         * getArea
         * 
         * @access  public
         * @return  AreaView
         */
        getArea: function() {
            return this._area;
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String key
         * @return  ResultsView
         */
        getChild: function(key) {
            return this._children[key];
        },

        /**
         * getChildren
         * 
         * @access  public
         * @return  Array
         */
        getChildren: function() {
            return this._children;
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            return this._activeResults.getPath();
        },

        /**
         * setActiveResults
         * 
         * @access  protected
         * @param   ResultsView results
         * @return  void
         */
        setActiveResults: function(results) {
            this._activeResults = results;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._area.setActiveGroup(this);
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._area.show();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * HourglassView
     * 
     * @extends View
     */
    window.HourglassView = View.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'HourglassView')
         */
        _string: 'HourglassView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * JoystickView
     * 
     * @events  feature
     *          select
     *          favorite
     * @extends View
     */
    window.JoystickView = View.extend({

        /**
         * _listeners
         * 
         * @see     https://jsfiddle.net/Lg5QH/1/
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                dragend: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': function(event, $anchor) {
                        $anchor.css({
                            backgroundImage: 'none'
                        });
                        App.getStage().getContent().find('section.messages').addClass('mirage');
                        App.getStage().getContent().getMessages().addClass('hidden');
                    }
                },
                dragstart: {

                    /**
                     * (anonymous)
                     * 
                     * @note    The defining below of the bypass string in the
                     *          encoded data is because Safari (at least) seemed
                     *          to pass along more information, perhaps for
                     *          security reasons. So I needed a way to tell which
                     *          types[] array position was indeed what I wanted.
                     * @see     http://bit.ly/1O8GfCS
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': function(event, $anchor) {
                        var dataTransfer = event.originalEvent.dataTransfer,
                            $element = $anchor.closest('.thumb, .quote.row'),
                            accessor = $element.data('accessor'),
                            type = this._getType(),
                            encoded = JSON.stringify({
                                accessor: accessor.get('key'),
                                locked: $element.hasClass('locked'),
                                type: type
                            });

                        // Preload of SVG
                        if (type === 'graphic') {
                            this._preloadVector(accessor);
                        }

                        // Encoded the data and set it for the transfer
                        encoded = 'bypass' + (encoded);
                        dataTransfer.setData(encoded, '');
                        // $anchor.addClass('dragging');
                        if (type === 'quote') {
                            if (event.originalEvent.dataTransfer.setDragImage) {
                                var image = App.getEditor().getArea('quotes').getDragImage();
                                event.originalEvent.dataTransfer.setDragImage(
                                    image,
                                    (image.width / 2).round(0),
                                    (image.height / 2).round(0)
                                );
                            }
                        } else {
                            $anchor.css({
                                backgroundImage: $element.css('background-image')
                            });
                            $anchor.css({
                                backgroundSize: $element.css('background-size')
                            });
                        }

                        // Update the canvas message
                        App.getStage().getContent().find('section.messages').removeClass('mirage');
                        App.getStage().getContent().getMessages().addClass('hidden');
                        App.getStage().getContent().getMessage(type).removeClass('hidden');
                    }
                },
                mousedown: {

                    /**
                     * (anonymous)
                     * 
                     * This is useful for clearing out any highlighted text for
                     * when a drag is started. Otherwise, weird cases like this
                     * can happen if the user (likely accidentally) highlighted
                     * parts of the page when they start the drag:
                     * https://i.imgur.com/pLzGLrz.jpg
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': DataUtils.clearSelectedText
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * The logic below was intented to combat a bug that was
                     * randomly appearing. It was that every now and then,
                     * dragging an image resulted in the thumb not being visible
                     * in the "dragged" node. See screenshot:
                     * https://i.imgur.com/lIxw6DB.jpg
                     * 
                     * I believe this was happening because for whatever reason,
                     * the cache entry for the thumb was somehow getting
                     * invalidated (could be because I had the console open so
                     * much). So to deal with this, I devised the following
                     * logic that would simply preload the thumb (again) when
                     * the mouse entered the overlay. It worked, but I don't
                     * think it's neccessary, because with the console closed,
                     * I have no been able to reproduce it on dev.
                     * 
                     * UPDATE
                     * So I ran into this with the setDragImage logic above for
                     * quotes. In the case above, I was creating a new Image
                     * object and setting the src to the drag image I wanted to
                     * use. But what was happening was even if the image was in
                     * the browsers cache, it was possible a lookup would be
                     * done, which although it may only take 4ms, would result
                     * in the drag image not being set because the image needs
                     * to be available *immediately*.
                     * 
                     * So to get around this, I preload the drag image in the
                     * QuotesAreaView, and set a reference to it. Then I created
                     * a getter / lookup for that reference, and when setting
                     * the drag image above, I use that reference (since that's
                     * guarenteed not to perform any http request).
                     * 
                     * So if this bug does come up again, one way to deal with 
                     * it could be to create a reference to the image in each
                     * ThumbView, and use that reference as the drag image
                     * (instead of setting the background-image for the
                     * a.overlay node).
                     * 
                     * @see     http://stackoverflow.com/questions/8809876/can-i-get-divs-background-image-url
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a.overlay': function(event, $anchor) {
                        // var $element = $anchor.closest('.thumb, .quote.row'),
                        //     url = $element.css('background-image');
                        // url = url.replace('url(','').replace(')','').replace(/\"/gi, "");
                        // new Image().src = url;
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'JoystickView')
         */
        _string: 'JoystickView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupContextMenuEvent();
            this._setupFeatureEvent();
            this._setupPinEvent();
            this._setupSelectEvent();
            this._setupFavoriteEvent();
        },

        /**
         * _getType
         * 
         * @note    Used by event handles to send type details to <favorite> and
         *          <feature> methods in some accessors.
         * @note    Not elegant, but works for now.
         * @access  protected
         * @return  String
         */
        _getType: function() {
            var type = App.getEditor().getActiveArea().getType();
            if (type === 'graphics') {
                return 'graphic';
            }
            if (type === 'templates') {
                return 'template';
            }
            if (type === 'images') {
                return 'image';
            }
            if (type === 'quotes') {
                return 'quote';
            }
            if (type === 'uploads') {
                return 'upload';
            }
            return 'photo';
        },

        /**
         * _preloadVector
         * 
         * @access  protected
         * @param   Accessor accessor
         * @return  void
         */
        _preloadVector: function(accessor) {
            var preloadedVectors = Stencil.get('preloadedVectors'),
                vectorUrl = accessor.url('svg');
            if (accessor.toString() === 'AssetAccessor') {
                var key = (accessor.get('key')) + '.svg';
                vectorUrl = Images.cloudFront(key);
            }
            if (preloadedVectors === undefined) {
                preloadedVectors = [];
                Stencil.set('preloadedVectors', preloadedVectors);
            }
            if (ArrayUtils.contains(vectorUrl, preloadedVectors) === false) {
                preloadedVectors.push(vectorUrl);
                Stencil.set('preloadedVectors', preloadedVectors);
                var signature = {file: 'Joystick', line: 279};
                Stencil.ajax({
                    excludeDefaultData: true,
                    signature: signature,
                    cache: true,
                    crossDomain: true,
                    url: vectorUrl,
                    type: 'GET',
                    dataType: 'text'
                });
            }
        },

        /**
         * _setupContextMenuEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupContextMenuEvent: function() {
            this.on({
                'showContextMenu': function(event, $anchor) {
                    var $element = $anchor.closest('.thumb, .quote.row'),
                        view = $element.data('view');
                    view.getResults().deselectAll();
                    view.select();
                    view.showContextMenu();
                }
            });
        },

        /**
         * _setupFeatureEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupFeatureEvent: function() {
            this.on({
                'feature': function(event, $anchor) {
                    var $element = $anchor.closest('.thumb, .quote.row'),
                        accessor = $element.data('accessor'),
                        type = App.getEditor().getActiveArea().getType();
                    Modals.showApplyCategories(type, accessor);
                }
            });
        },

        /**
         * _setupPinEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupPinEvent: function() {
            this.on({
                'pin': function(event, $anchor) {
                    var $element = $anchor.closest('.thumb, .quote.row'),
                        accessor = $element.data('accessor'),
                        category = $element.data('view').getResults().getCategory();
                    accessor.pin(category);
                    // category.pin(accessor);
                }
            });
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor, nativeEvent) {
                    /**
                     * Shift + Click
                     * 
                     */
                    if (nativeEvent.shiftKey === true) {
                        var $element = $anchor.closest('.thumb, .quote.row'),
                            view = $element.data('view'),
                            results = view.getResults(),
                            childrenSelected = results.childrenSelected.all.apply(results);
                        if (childrenSelected.length === 0) {
                            var $range = $element.prevAll().addBack().reverse();
                            $range.each(function(index, element) {
                                $(element).data('view').select();
                                $(element).addClass('active-shift');
                            });
                        } else {
                            var $lastSelected = $element.parent().find('.active-last'),
                                $shiftSelected = $element.parent().find('.active-shift');
                            $shiftSelected.each(function(index, element) {
                                $(element).data('view').deselect();
                            });
                            if ($element[0] === $lastSelected[0]) {
                                $lastSelected.data('view').select();
                            } else {
                                $lastSelected.data('view').deselect();
                                var $range = $lastSelected.getRangeElements($element).reverse();
                                $range.each(function(index, element) {
                                    $(element).data('view').select();
                                    $(element).addClass('active-shift');
                                });
                            }
                            results.reClassifyChildren();
                        }
                    }
                    /**
                     * Command + Click
                     * 
                     */
                    else if (
                        (UserAgent.is.mac() === true && nativeEvent.metaKey === true)
                        || (UserAgent.is.mac() === false && nativeEvent.ctrlKey === true)
                    ) {
                        var $element = $anchor.closest('.thumb, .quote.row'),
                            view = $element.data('view'),
                            results = view.getResults();
                        $element.siblings().removeClass('active-shift');
                        view.toggle();
                        results.reClassifyChildren();
                    }
                    /**
                     * Click
                     * 
                     */
                    else {
                        var $element = $anchor.closest('.thumb, .quote.row');
                        if ($element.hasClass('active') === false) {
                            var accessor = $element.data('accessor'),
                                locked = $element.hasClass('locked'),
                                options = {};
                            if (accessor.getPlacementDestination !== undefined) {
                                options.destination = accessor.getPlacementDestination();
                            }
                            var accountDraftStillBeingCreated = function() {
                                if (Stencil.account().draft().data().settings.locked === undefined) {
                                    return true;
                                }
                                return false;
                            };
                            if (accountDraftStillBeingCreated() === false) {
                                accessor.select.apply(
                                    accessor,
                                    ['click', locked, options]
                                );
                                if ($element.data('view').showPreloadingSpinner) {
                                    $element.data('view').showPreloadingSpinner();
                                }
                            } else {
                                var msg = Stencil.getMessage('account.draft.processing');
                                App.getBusy().show(msg);
                                Stencil.account().once({
                                    'draft/create': function(event, draft) {
                                        App.getBusy().hide();
                                    }
                                });
                            }
                        }
                    }
                }
            });
        },

        /**
         * _setupFavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupFavoriteEvent: function() {
            this.on({
                'favorite': function(event, $anchor) {
                    var $element = $anchor.closest('.thumb, .quote.row'),
                        accessor = $element.data('accessor'),
                        areaType = App.getEditor().getActiveArea().getType();
                    if (
                        Account.max.favorites() === true
                        && User.admin() === false
                        && User.editor() === false
                    ) {
                        if (Account.plan('pro') === true) {
                            Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                        } else {
                            Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                        }
                    } else {
                        App.getEditor().getActiveArea().getNav().pulse();
                        accessor.favorite.apply(accessor, [areaType, true]);

                        // var $unfavorite = $element.find('a.unfavorite');
                        // $unfavorite.addClass('pulse');
                        // (function() {
                        //     $unfavorite.removeClass('pulse');
                        // }).delay(1200);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('GroupView', function() {

    /**
     * QueriesGroupView
     * 
     * @extends GroupView
     */
    window.QueriesGroupView = GroupView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QueriesGroupView')
         */
        _string: 'QueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   String query
         * @return  void
         */
        _drawChild: function(query) {
            var $results = DataUtils.render(this._drawProperties.template, {
                    fallback: this._drawProperties.fallback(),
                    query: query
                });
            $results.attr('query', query);
            $results.find('div.finished div.copy strong').text(query);
            this._element.append($results);
            this._children[query] = new window[this._drawProperties.view](
                $results,
                this,
                query
            );
            var _this = this;
            this._children[query].on({
                'destroy': function(event) {
                    delete _this._children[query];
                }
            });
        },

        /**
         * getChild
         * 
         * @access  public
         * @param   String query
         * @return  QueryResultsView
         */
        getChild: function(query) {
            if (this._super(query) === undefined) {
                this._drawChild(query);
            }
            return this._super(query);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResultsView', function() {

    /**
     * QueryResultsView
     * 
     * @extends ResultsView
     */
    window.QueryResultsView = ResultsView.extend({

        /**
         * _query
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _query: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QueryResultsView')
         */
        _string: 'QueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QueriesGroupView queriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, queriesGroup, query) {
            this._query = query;
            this._super(element, queriesGroup);
            this.on({
                'destroy': function(event) {
                    this._collection.empty();
                    this._element.remove();
                }
            });
        },

        /**
         * _setupExpireCheckInterval
         * 
         * @note    Currently only being used by GraphicQueryResultsView and
         *          PhotoQueryResultsView. QuoteQueryResultsView not using it
         *          since those results don't "time out".
         * @access  protected
         * @return  void
         */
        _setupExpireCheckInterval: function() {
            (function() {
                var now = Math.floor(Date.now() / 1000);
                if (this._expires < now) {
                    this._numberOfTimesReloaded++;
                    if (
                        this._numberOfTimesReloaded > this._maxNumberOfReloads
                    ) {
                        Stencil.alert('search.bug');
                        Stencil.kill();
                    } else {
                        this._lastLoadStats = false;
                        this._expires = now + this._secondsUntilReload;
                        this._collection.empty();
                        this.trackLoad();
                        this.load();
                    }
                }
            }).interval(250, this);
        },

        /**
         * getQuery
         * 
         * @access  public
         * @return  String
         */
        getQuery: function() {
            return this._query;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                nav = area.getNav(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                path = this.getPath();
            App.getSidebar().updatePath(area, path);
            nav.showResultsLabel();
            $search.val(this._query);
            if (
                UserAgent.is.tablet() === false
                && UserAgent.is.ie() === false
            ) {
                $search.focus();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SelectableElementView', function() {

    /**
     * QuoteRowView
     * 
     * @extends SelectableElementView
     */
    window.QuoteRowView = SelectableElementView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteRowView')
         */
        _string: 'QuoteRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AssetAccessor|ResourceAccessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._addRowListeners();
        },

        /**
         * _addRowListeners
         * 
         * @access  protected
         * @return  void
         */
        _addRowListeners: function() {
            var areaType = this._getAreaType();
            this.on({
                'unfavorite': function(event) {
                    this._accessor.unfavorite(areaType, true);
                },
                'unfeature': function(event, category) {
                    Modals.showApplyCategories(areaType, this._accessor);
                }
            });
        },

        /**
         * _getAreaType
         * 
         * @access  protected
         * @return  String
         */
        _getAreaType: function() {
            return this._results.getGroup().getArea().getType();
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            var $active = this.find('div.active');
            $active.css({
                'lineHeight': this._element.outerHeight() + 'px'
            });
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QuoteRowView', function() {

    /**
     * ChildQuoteRowView
     * 
     * @extends QuoteRowView
     */
    window.ChildQuoteRowView = QuoteRowView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChildQuoteRowView')
         */
        _string: 'ChildQuoteRowView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === Categories.account.favorites('quotes')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === Categories.account.favorites('quotes')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ContextMenuView', function() {

    /**
     * ResourceContextMenuView
     * 
     * @extends ContextMenuView
     */
    window.ResourceContextMenuView = ContextMenuView.extend({

        /**
         * _delays
         * 
         * Overwriting parent delays for multiple to ensure partners don't get
         * spammed by requests that are too close together.
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            multiple: {
                delete: 650,
                favorite: {
                    category: 650,
                    results: 1750
                },
                trailing: 750,
                unfavorite: 650
            }
        },

        /**
         * _maxSequentialResourceActions
         * 
         * @access  protected
         * @var     Number (default: 5)
         */
        _maxSequentialResourceActions: 5,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResourceContextMenuView')
         */
        _string: 'ResourceContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView|PhotosAreaView|QuotesAreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
        },

        /**
         * _atLeastOneSelectedIsLocked
         * 
         * @access  protected
         * @return  Boolean
         */
        _atLeastOneSelectedIsLocked: function() {
            var selected = this._getSelected(),
                index;
            for (index in selected) {
                if (selected[index].getElement().hasClass('locked') === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * _getFavoritesCategory
         * 
         * @access  protected
         * @return  CategoryAccessor
         */
        _getFavoritesCategory: function() {
            var areaType = this._area.getType();
            return Categories.account.favorites(areaType);
        },

        /**
         * _getMultipleDelay
         * 
         * @access  protected
         * @param   String action
         * @return  Number
         */
        _getMultipleDelay: function(action) {
            if (action === 'favorite') {
                var results = this._area.getActiveGroup().getActiveResults();
                if (results.category() === true) {
                    return this._delays.multiple[action].category;
                }
                return this._delays.multiple[action].results;
            }
            return this._super(action);
        },

        /**
         * _setupFavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupFavoriteEvent: function() {
            this.on({
                'favorite': function(event, $anchor) {
                    if (this._multipleSelected() === false) {
                        if (
                            Account.max.favorites() === true
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {
                            var areaType = this._area.getType();
                            this._area.getNav().pulse();
                            this._getAccessor().favorite(areaType, true);
                            this._toggleFavoriteState();
                            this._toggleMultipleCountTooltip();
                            this._pulseFavoriteIcon();
                        }
                    } else {

                        // Get ones that can be favorited
                        var selected = this._getSelected(),
                            unfavoritedSelected = [],
                            index;
                        for (index in selected) {
                            if (selected[index].getAccessor().favorited() === false) {
                                unfavoritedSelected.push(selected[index]);
                            }
                        }

                        // Limit check
                        var account = Stencil.account();
                        if (
                            account.getFavoritesRemaining() < unfavoritedSelected.length
                            && User.admin() === false
                            && User.editor() === false
                        ) {
                            if (Account.plan('pro') === true) {
                                Stencil.navigate('/app/upgrade/unlimited/favorites?clean=1');
                            } else {
                                Stencil.navigate('/app/upgrade/pro/favorites?clean=1');
                            }
                        } else {

                            // Let's do this!
                            var callback = function(index) {
                                if (index < unfavoritedSelected.length) {
                                    this.showBusyModalProgressMessaging(
                                        index,
                                        unfavoritedSelected
                                    );
                                    var accessor = unfavoritedSelected[index].getAccessor(),
                                        delay = this._getMultipleDelay('favorite'),
                                        areaType = this._area.getType(),
                                        _this = this;
                                    accessor.once({
                                        'model/feature': function(event) {
                                            if ((index + 1) >= unfavoritedSelected.length) {
                                                delay = _this._getMultipleDelay('trailing');
                                            }
                                            callback.delay(delay, _this, [index + 1]);
                                            // // if ((index + 1) < unfavoritedSelected.length) {
                                            //     callback.delay(delay, callback, [index + 1]);
                                            // // } else {
                                            // //     callback(index + 1);
                                            // // }
                                        }
                                    });
                                    accessor.favorite(areaType, true);
                                } else {
                                    this._toggleFavoriteState();
                                    this._toggleMultipleCountTooltip();
                                    this._pulseFavoriteIcon();
                                    App.getBusy().hide();
                                    this.closable(true);
                                    // var results = this._area.getActiveGroup().getActiveResults();
                                    // results.deselectAll();
                                }
                            };

                            // UI
                            this._area.getNav().pulse();
                            var msg = this._getBusyMessage('favorite');
                            App.getBusy().show(msg);
                            this.closable(false);
                            callback.apply(this, [0]);
                        }
                    }
                }
            });
        },

        /**
         * _setupUnfavoriteEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupUnfavoriteEvent: function() {
            this.on({
                'unfavorite': function(event, $anchor) {
                    var results = this._getView().getResults(),
                        areaType = this._area.getType();
                    if (this._multipleSelected() === false) {
                        this._getAccessor().unfavorite(areaType, true);
                        this._toggleFavoriteState();
                        this._toggleMultipleCountTooltip();
                        if (results.category() === true) {
                            var currentCategory = results.getCategory(),
                                favoritesCategory = this._getFavoritesCategory();
                            if (currentCategory === favoritesCategory) {
                                results.deselectAll();
                                this.triggerHandler('close');
                            }
                        }
                    } else {
                        var selected = this._getSelected(),
                            delay = this._getMultipleDelay('unfavorite'),
                            callback = function(index) {
                                if (index < selected.length) {
                                    this.showBusyModalProgressMessaging(
                                        index,
                                        selected
                                    );
                                    var accessor = selected[index].getAccessor(),
                                        _this = this;
                                    accessor.once({
                                        'model/unfeature': function(event) {
                                            if ((index + 1) >= selected.length) {
                                                delay = _this._getMultipleDelay('trailing');
                                            }
                                            callback.delay(delay, _this, [index + 1]);
                                            // // if ((index + 1) < selected.length) {
                                            //     callback.delay(delay, callback, [index + 1]);
                                            // // } else {
                                            // //     callback(index + 1);
                                            // // }
                                        }
                                    });
                                    accessor.unfavorite(areaType, true);
                                } else {
                                    this._toggleFavoriteState();
                                    this._toggleMultipleCountTooltip();
                                    App.getBusy().hide();
                                    this.closable(true);
                                    if (results.category() === true) {
                                        var currentCategory = results.getCategory(),
                                            favoritesCategory = this._getFavoritesCategory();
                                        if (currentCategory === favoritesCategory) {
                                            results.deselectAll();
                                            this.triggerHandler('close');
                                        }
                                    }
                                }
                            };

                        // UI
                        if (results.category() === true) {
                            var currentCategory = results.getCategory(),
                                favoritesCategory = this._getFavoritesCategory();
                            if (currentCategory === favoritesCategory) {
                                this.triggerHandler('close');
                            }
                        }
                        var msg = this._getBusyMessage('unfavorite');
                        App.getBusy().show(msg);
                        this.closable(false);
                        callback.apply(this, [0]);
                    }
                }
            });
        },

        /**
         * _toggleCollectionTooltips
         * 
         * @access  protected
         * @return  void
         */
        _toggleCollectionTooltips: function() {
            this._destroyTooltips();
            var $viewCollections = this.find('[lookup="viewCollections"]');
            $viewCollections.enable();
            if (this._atLeastOneSelectedIsLocked() === true) {
                var tooltip = this._tooltips.collections.single;
                if (this._multipleSelected() === true) {
                    tooltip = this._tooltips.collections.multiple;
                }
                $viewCollections.attr('data-title', tooltip);
                $viewCollections.attr('data-original-title', tooltip);
                this._setupTooltips();
                $viewCollections.disable();
            } else {
                if (this._multipleSelected() === true) {
                    var results = this._area.getActiveGroup().getActiveResults();
                    if (results.category() === false) {
                        var maxSequentialResourceActions = this._maxSequentialResourceActions;
                        if (this._getSelected().length > maxSequentialResourceActions) {
                            var tooltip = this._tooltips.collections.limit;
                            tooltip = tooltip.replace('###', maxSequentialResourceActions);
                            $viewCollections.attr('data-title', tooltip);
                            $viewCollections.attr('data-original-title', tooltip);
                            this._setupTooltips();
                            $viewCollections.disable();
                        }
                    }
                }
            }
        },

        /**
         * _toggleFavoriteState
         * 
         * @access  protected
         * @return  void
         */
        _toggleFavoriteState: function() {
            this._super();
            this._destroyTooltips();
            var $unfavorite = this.find('[lookup="unfavorite"]'),
                $favorite = this.find('[lookup="favorite"]');
            $unfavorite.enable();
            $favorite.enable();
            if (this._atLeastOneSelectedIsLocked() === true) {
                var tooltips = {
                    favorite: this._tooltips.favorite.single,
                    unfavorite: this._tooltips.unfavorite.single
                };
                if (this._multipleSelected() === true) {
                    tooltips = {
                        favorite: this._tooltips.favorite.multiple,
                        unfavorite: this._tooltips.unfavorite.multiple
                    };
                }
                $unfavorite.attr('data-title', tooltips.unfavorite);
                $unfavorite.attr('data-original-title', tooltips.unfavorite);
                $favorite.attr('data-title', tooltips.favorite);
                $favorite.attr('data-original-title', tooltips.favorite);
                this._setupTooltips();
                $unfavorite.disable();
                $favorite.disable();
            } else {
                if (this._multipleSelected() === true) {
                    var results = this._area.getActiveGroup().getActiveResults();
                    if (results.category() === false) {
                        var maxSequentialResourceActions = this._maxSequentialResourceActions;
                        if (this._getSelected().length > maxSequentialResourceActions) {
                            var tooltip = this._tooltips.favorite.limit;
                            tooltip = tooltip.replace('###', maxSequentialResourceActions);
                            $favorite.attr('data-title', tooltip);
                            $favorite.attr('data-original-title', tooltip);
                            this._setupTooltips();
                            $favorite.disable();
                        }
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ResultsView
     * 
     * @extends View
     */
    window.ResultsView = View.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _children
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _children: [],

        /**
         * _childrenSelected
         * 
         * @access  protected
         * @var     Array (default: [])
         */
        _childrenSelected: [],

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|FeaturesCollection (default: null)
         */
        _collection: null,

        /**
         * _drawProperties
         * 
         * Defines the template and View that ought to be used when drawing a
         * a child (right now, either a thumb or quote row).
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _drawProperties: {},

        /**
         * _infiniteScrollThreshold
         * 
         * Number of pixels below the bottom of the scrollable area at which
         * point another load is triggered
         * 
         * @access  protected
         * @var     Number (default: 350)
         */
        _infiniteScrollThreshold: 350,

        /**
         * _loaded
         * 
         * Whether an initial load has been triggered.
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll).
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * Tracks whether or not there is more data to be loaded.
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _more: true,

        /**
         * _scrollEvents
         * 
         * @access  protected
         * @var     Object
         */
        _scrollEvents: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._infiniteScrollThreshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            },

            /**
             * plugin
             * 
             * @access  private
             * @param   jQuery event
             * @param   Number y
             * @param   Boolean top
             * @param   Boolean bottom
             * @return  void
             */
            plugin: function(event, y, top, bottom) {
                var $inner = this._element.find('div.inner');
                bottom = y > ($inner.outerHeight() - this._element.outerHeight() - this._infiniteScrollThreshold);
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load();
                        }
                    }
                }
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ResultsView')
         */
        _string: 'ResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GroupView group
         * @return  void
         */
        init: function(element, group) {
            this._children = [];
            this._childrenSelected = [];
            this._group = group;
            this._super(element);
            this._addInfiniteScrollEvents();
            this._setupAuthLocking();
            this._setupResults();
            this._setupTooltips();
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scrollEvents.native.proxy(this);
            if (UserAgent.supports.css.scrollbars() === false) {
                check = this._scrollEvents.plugin.proxy(this);
            }
            this.addScrollEvent(check);
        },

        /**
         * _addLoadedListener
         * 
         * The logic for this is as follows:
         * If you're navigating to your favorite-photos, we should only block
         * the whole div.results area if there are no results already loaded
         * into that area. The case where there are already results loaded is if
         * for example you do a search and favorite one of the results before
         * having navigated to /app/photos/favorites.
         * 
         * This shouldn't cause an issue with QueryResultsView views since
         * they'll always be empty.
         * 
         * @access  protected
         * @return  void
         */
        _addLoadedListener: function() {
            if (this._loaded === false) {
                if (this.getNumberOfResults() === 0) {
                    this.once({
                        'loaded': function(event) {
                            var length = this._collection.length();
                            if (length === 0) {
                                this.hourglass();
                            } else {
                                this._onResultsReady(function() {
                                    this.hourglass();
                                });
                            }
                        }
                    });
                    this.hourglass();
                }
                this.trackLoad();
                this.load();
            }
        },

        /**
         * _drawChild
         * 
         * @access  protected
         * @param   Accessor accessor
         * @param   Number position
         * @return  View
         */
        _drawChild: function(accessor, position) {
            var $element = DataUtils.render(this._drawProperties.template, {
                accessor: accessor,
                locked: this._locked(position),
                results: this
            });
            if (position === 0) {
                this._element.find('div.inner').prepend($element);
            } else {
                this._element.find('div.inner').append($element);
            }
            var child = new window[this._drawProperties.view](
                $element,
                accessor,
                this
            );
            this._children.push(child);
            $element.data('accessor', accessor);
            $element.data('view', child);
            return child;
        },

        /**
         * _hasScrollBar
         * 
         * @access  protected
         * @return  Boolean
         */
        _hasScrollBar: function() {
            var $results = this.find('div.results').first();
            if (UserAgent.supports.css.scrollbars() === true) {
                return $results.get(0).scrollHeight > $results.height();
            }
            return this._$scrollbar.data('jsp').getIsScrollableV() === true;
        },

        /**
         * _locked
         * 
         * Returns whether or not a specific result should be locked, based on
         * the config settings for this section, and how many previous results
         * have been written.
         * 
         * @access  protected
         * @param   Number position
         * @return  Boolean
         */
        _locked: function(position) {
            if (
                User.admin() === true
                || User.editor() === true
                || Account.upgraded() === true
            ) {
                return false;
            }
            var applicableResultsHash = [
                    'GraphicCategoryResultsView',
                    'GraphicQueryResultsView',
                    'PhotoCategoryResultsView',
                    'PhotoQueryResultsView'
                ];
            if (ArrayUtils.contains(this._string, applicableResultsHash) === true) {
                var maxFree = Config.default('maxFree'),
                    lookup = {
                        GraphicCategoryResultsView: maxFree.graphicFeatures,
                        GraphicQueryResultsView: maxFree.graphicResources,
                        PhotoCategoryResultsView: maxFree.photoFeatures,
                        PhotoQueryResultsView: maxFree.photoResources
                    };
                if ((position + 1) > lookup[this._string]) {
                    return true;
                }
                return false;
            }
            return false;
        },

        /**
         * _makeScrollable
         * 
         * @note    It's important to set the _$scrollbar value to null, since
         *          it should no longer be available after a destroy event has
         *          been triggered.
         * @see     http://jquery-custom-scrollbar.rocketmind.pl/
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            this._$scrollbar.bind({
                'jsp-scroll-y': function(event, y, top, bottom) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                }
            });

            // Resizing
            var resize = function() {
                $element.data('jsp').reinitialise();
            };
            $(window).resize(resize);
            this.on({
                'destroy': function(event) {
                    this._$scrollbar = null;
                    $(window).unbind('resize', resize);
                }
            });
        },

        /**
         * _onResultsReady
         * 
         * This method triggers the callback once we're sure that at least one
         * thumb has been loaded (and is therefore visible to the user).
         * 
         * The intention with this is to lower the perceived time that it takes
         * for results to load. Before doing this, the hourglass spinner would
         * be hidden as soon as the server responded back with the data, but the
         * div.results area would remain empty, since images (naturally) take
         * longer to load than raw data. This was especially noticable on slower
         * connections (eg. while travelling, and thus, in places where internet
         * isn't as reliable).
         * 
         * Check out the other _onResultsReady methods in other ResultsView
         * child-classes to see how those are handled.
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            var interval = (function() {
                var selectors = [
                        '.lazy.loaded',
                        '.lazy.error'
                    ],
                    selector = selectors.join(',');
                if (this.find(selector).length > 0) {
                    IntervalPool.clear(interval);
                    this.hourglass();
                }
            }).interval(50, this);
        },

        /**
         * _setupAuthLocking
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthLocking: function() {
            var _this = this;
            User.once({
                'login': function(event, user) {
                    if (
                        User.admin() === true
                        || User.editor() === true
                        || Account.upgraded() === true
                    ) {
                        _this.find('.locked').removeClass('locked');
                    }
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this.find('.locked').removeClass('locked');
                }
            });
        },

        /**
         * _setupResults
         * 
         * @access  protected
         * @return  void
         */
        _setupResults: function() {
            var $results = this.find('.results');
            if (UserAgent.supports.css.scrollbars() === false) {
                this._makeScrollable($results);
            } else {
                $results.scroll(function(event) {
                    var el = document.elementFromPoint(App.getX(), App.getY()),
                        $el = $(el);
                    if ($el.hasClass('thumb') === true || $el.hasClass('row') === true) {
                        $el.trigger('mouseenter');
                    }
                });
            }
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                delay: {
                    show: 300,
                    hide: 0
                },
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * _showHideFinishedState
         * 
         * Shows the finished state if no more results have been found, and
         * there's a scrollbar visible to the user.
         * 
         * @access  protected
         * @param   Number limit
         * @return  void
         */
        _showHideFinishedState: function(limit) {
            if (this._more === false) {
                if (this._hasScrollBar() === true) {
                    this.find('div.status.finished').removeClass('hidden');
                    this.refreshScrollbar();
                }
            }
        },

        /**
         * addScrollEvent
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        addScrollEvent: function(callback) {
            var $results = this.find('div.results').first(),
                listener = 'scroll';
            if (UserAgent.supports.css.scrollbars() === false) {
                listener = 'jsp-scroll-y';
            }
            $results.bind(listener, callback);
        },

        /**
         * category
         * 
         * Returns whether or not this ResultView represents a category.
         * 
         * @access  public
         * @return  Boolean
         */
        category: function() {
            return this.getCategory !== undefined;
        },

        /**
         * childrenSelected
         * 
         * @access  public
         * @var     Object
         */
        childrenSelected: {

            /**
             * add
             * 
             * @access  public
             * @param   View child
             * @return  void
             */
            add: function(child) {
                this._childrenSelected.push(child);
            },

            /**
             * all
             * 
             * @access  public
             * @return  Array
             */
            all: function() {
                return this._childrenSelected;
            },

            /**
             * contains
             * 
             * @access  public
             * @param   View child
             * @return  Boolean
             */
            contains: function(child) {
                return this._childrenSelected.indexOf(child) !== -1;
            },

            /**
             * remove
             * 
             * @access  public
             * @param   View child
             * @return  void
             */
            remove: function(child) {
                var childrenSelected = this._childrenSelected,
                    index = childrenSelected.indexOf(child);
                if (index !== -1) {
                    // console.log('removed');
                    childrenSelected.splice(index, 1);
                }
            }
        },

        /**
         * deselectAll
         * 
         * @access  public
         * @return  void
         */
        deselectAll: function() {
            // var index = 0,
            //     length = this._children.length;
            // while (index < length) {
            //     this._children[index].deselect();
            //     index++;
            // }
            var index = 0,
                length = this._children.length;
            while (index < length) {
                this._children[index].deselect();
                index++;
            }
            index = this._childrenSelected.length;
            while (index--) {
                this._childrenSelected[index].deselect();
            }
        },

        /**
         * getChildren
         * 
         * @access  public
         * @return  Array
         */
        getChildren: function() {
            return this._children;
        },

        /**
         * getCollection
         * 
         * @access  public
         * @return  Collection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * getGroup
         * 
         * @access  public
         * @return  GroupView
         */
        getGroup: function() {
            return this._group;
        },

        /**
         * getNumberOfResults
         * 
         * @access  public
         * @return  Number
         */
        getNumberOfResults: function() {
            return this._collection.all().length;
        },

        /**
         * lazyLoadChildren
         * 
         * @note    <loading> class used below to ensure no duplicate calls made
         *          to lazy load assets incase a collection <update> event fires
         *          twice.
         * @note    <waiting> class is used below in cases where there are
         *          hundreds of assets. In those cases, 50 will be drawn upon
         *          load, but the last X won't be loaded, because they're so far
         *          below the threshold value for preloading. Without the
         *          <waiting> class, an infinite-scroll could trigger an
         *          additional collection:update event, which could result in
         *          multiple lazy events beyond attached to the element. When
         *          that happens, things bust :(
         * @access  public
         * @return  void
         */
        lazyLoadChildren: function() {
            var _this = this,
                $elements = this.find(
                    '.lazy:not(.loading):not(.loaded):not(.waiting)'
                );
            $elements.addClass('waiting');
            $elements.lazyload({
                threshold: 500,
                container: this._element.find('.results').first(),
                effect: 'fadeIn',
                effect_speed: 400,
                appear: function(remaining, settings) {
                    $(this).addClass('loading');
                },
                error: function(remaining, settings, img) {
                    var src = img.src;
                    $elements.filter('[data-original="' + (src) + '"]').addClass('error');
                },
                load: function(remaining, settings, img) {
                    $(this).addClass('loaded');
                    $(this).removeClass('loading');
                    $(this).removeClass('waiting');
                    $(this).removeAttr('data-original');
                    var drawCallback = _this._drawProperties.drawCallback;
                    if (drawCallback !== undefined) {
                        var scope = $(this).data('view');
                        drawCallback.apply(scope);
                    }
                }
            });
        },

        /**
         * reClassifyChildren
         * 
         * @access  public
         * @return  void
         */
        reClassifyChildren: function() {
            var $elements = this.find('[class*="active-n-"]'),
                toSort = [];
            if ($elements.length > 0) {
                $elements.each(function(index, element) {
                    var $element = $(element),
                        count = $element.attr('class').match(/active-n-([0-9]+)/)[1];
                    toSort.push([
                        $element,
                        count.toInt()
                    ]);
                });
                toSort.sort(function(a, b) {
                    return a[1] - b[1];
                });
                $(toSort).each(function(index, entry) {
                    var $element = $(entry[0]);
                    $element.removeClass(function(index, className) {
                        return className.match(/(active-n-[0-9]+)/).shift();
                    });
                    $element.addClass('active-n-' + (index));
                });
                $(toSort[toSort.length - 1][0]).addClass('active-last');
            }
        },

        /**
         * refreshScrollbar
         * 
         * Refreshes the DOM created scrollbar if the browser doesn't natively
         * support scrollbar styling, if the scrollbar is defined, and a
         * reference to the DOM created scrollbar could be found.
         * 
         * There was a massive edge-case bug whereby if a ResultsView was
         * destroyed (via the destroy event trigger), this method was still
         * being called if the maximum number of seconds for a ResultView was
         * reached.
         * 
         * Specifically, if the user searched for more than 10 terms, the
         * destroy event would get triggered in the ResourcesSearchView
         * instance. However the timer was still going to refresh the results
         * (to ensure that any photo/vector paths were still usable), and the
         * below logic would get triggered, but wasn't checking whether the DOM
         * created scrollbar was still available (it wasn't, because it was
         * removed as can be seen here: https://i.imgur.com/Vz1qGma.png).
         * 
         * So now I'm doing two things to be sure:
         * 1) in the destroy listener defined in this class, I re-set the
         * _$scrollbar to null once this ResultsView is destroyed
         * 2) I check to make sure the _$scrollbar and it's associated DOM
         * created scrollbar, are valid references.
         * 
         * @access  public
         * @return  Boolean
         */
        refreshScrollbar: function() {
            if (UserAgent.supports.css.scrollbars() === true) {
                return false;
            }
            if (this._$scrollbar === null) {
                return false
            }
            if (this._$scrollbar.data('jsp') === undefined) {
                return false
            }
            this._$scrollbar.data('jsp').reinitialise();
            return true;
        },

        /**
         * removeScrollEvent
         * 
         * @access  public
         * @param   Function callback
         * @return  void
         */
        removeScrollEvent: function(callback) {
            var $results = this.find('div.results').first(),
                listener = 'scroll';
            if (UserAgent.supports.css.scrollbars() === false) {
                listener = 'jsp-scroll-y';
            }
            $results.unbind(listener, callback);
        },

        // /**
        //  * removeChild
        //  * 
        //  * @access  public
        //  * @param   Accessor accessor
        //  * @return  void
        //  */
        // removeChild: function(accessor) {
        //     var index;
        //     for (index in this._children) {
        //         if (this._children[index].getAccessor() === accessor) {
        //             this._children[index].remove();
        //             this._children.splice(index, 1);
        //             break;
        //         }
        //     }
        // },

        /**
         * scrollToTop
         * 
         * @access  public
         * @return  void
         */
        scrollToTop: function() {
            var $results = this.find('.results');
            if ($results.scrollTop() !== 0) {
                $results.animate({scrollTop: 0}, 'fast');
            }
        },

        /**
         * selectAll
         * 
         * @access  public
         * @return  void
         */
        selectAll: function() {
            var index = 0,
                length = this._children.length;
            for (index; index < length; ++index) {
                this._children[index].deselect();
            }
            index = length;
            while (index--) {
                this._children[index].select();
                this._children[index].getElement().addClass('active-shift');
            }
            this.reClassifyChildren();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._group.setActiveResults(this);
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._group.show();
            this.triggerHandler('menu/close');
            this.refreshScrollbar();
            this._addLoadedListener();
        },

        /**
         * showHideEmptyState
         * 
         * Shows or hides the appropriate section depending on whether the
         * collection is empty.
         * 
         * @access  public
         * @return  void
         */
        showHideEmptyState: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty').addClass('hidden');
            if (this._collection.all().length === 0) {
                this.find('.results').addClass('hidden');
                this.find('.messaging,.empty').removeClass('hidden');
            }
        },

        /**
         * trackLoad
         * 
         * Tracks that results are being loaded. Centralized here because it's
         * being used in multuple places, and due to a jScrollPane bug (which
         * happens when via this ResultsView.refreshScrollbar method), it needs
         * to occur before any jScrollPane logic gets executed.
         * 
         * @access  public
         * @return  void
         */
        trackLoad: function() {
            this._loaded = true;
            this._loading = true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * SelectableElementView
     * 
     * @extends View
     */
    window.SelectableElementView = View.extend({

        /**
         * _accessor
         * 
         * @access  protected
         * @var     null|Accessor (default: null)
         */
        _accessor: null,

        /**
         * _results
         * 
         * @access  protected
         * @var     null|ResultsView (default: null)
         */
        _results: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SelectableElementView')
         */
        _string: 'SelectableElementView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._accessor = accessor;
            this._results = results;
            this._super(element);
            this._addContextMenuListener();
        },

        /**
         * _addContextMenuListener
         * 
         * @access  protected
         * @return  void
         */
        _addContextMenuListener: function() {
            var _this = this;
            this._element.on({
                contextmenu: function(event) {
                    event.preventDefault();
                    if ($(this).hasClass('active') === false) {
                        _this.getResults().deselectAll();
                    }
                    _this.select();
                    _this.showContextMenu();
                }
            });
        },

        /**
         * _getRightMostSelectedChild
         * 
         * @access  protected
         * @return  jQuery
         */
        _getRightMostSelectedChild: function() {
            var $element = this._element,
                leftOffset = $element.offset().left,
                topOffset = $element.offset().top,
                results = this._results,
                childrenSelected = results.childrenSelected.all.apply(results),
                index,
                child,
                childLeftOffset,
                childTopOffset;
            for (index in childrenSelected) {
                child = childrenSelected[index];
                childLeftOffset = child.getElement().offset().left;
                childTopOffset = child.getElement().offset().top;
                if (
                    childLeftOffset > leftOffset
                    && childTopOffset === topOffset
                ) {
                    leftOffset = childLeftOffset;
                    $element = child.getElement();
                }
            }
            return $element;
        },

        /**
         * deselect
         * 
         * @access  public
         * @return  void
         */
        deselect: function() {
            var results = this._results,
                selected = results.childrenSelected.contains.apply(
                    results,
                    [this]
                );
// console.log('a. deselecting');
            if (selected === true) {
// console.log('deselecting');
                results.childrenSelected.remove.apply(results, [this]);
                this._element.removeClass('active-shift');
                this._element.removeClass('active-last');
                this._element.removeClass('active');
                this._element.removeClass(function(index, className) {
                    return className.match(/(active-n-[0-9]+)/).shift();
                });
            }
        },

        /**
         * getAccessor
         * 
         * @access  public
         * @return  Accessor
         */
        getAccessor: function() {
            return this._accessor;
        },

        /**
         * getContextMenu
         * 
         * @access  public
         * @return  ContextMenuView
         */
        getContextMenu: function() {
            return this._results.getGroup().getArea().getContextMenu();
        },

        /**
         * getResults
         * 
         * @access  public
         * @return  ResultsView
         */
        getResults: function() {
            return this._results;
        },

        /**
         * hideContextMenu
         * 
         * @access  public
         * @return  void
         */
        hideContextMenu: function() {
            this.getContextMenu().triggerHandler('close');
        },

        /**
         * select
         * 
         * @access  public
         * @return  void
         */
        select: function() {
            var results = this._results,
                selected = results.childrenSelected.contains.apply(
                    results,
                    [this]
                );
            if (selected === false) {
                this._element.siblings().removeClass('active-last');
                this._element.addClass('active-last');
                this._element.addClass('active');
                var selected = this._element.siblings('.active');
                this._element.addClass('active-n-' + (selected.length));
                results.childrenSelected.add.apply(results, [this]);
            }
        },

        /**
         * showContextMenu
         * 
         * @access  public
         * @return  void
         */
        showContextMenu: function() {
            var contextMenu = this.getContextMenu(),
                $relative = this._getRightMostSelectedChild();
            contextMenu.setRelative($relative);
            contextMenu.show();
            contextMenu.position();
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  Boolean Whether the thumb was selected or not
         */
        toggle: function() {
            var results = this._results,
                selected = results.childrenSelected.contains.apply(
                    results,
                    [this]
                );
            if (selected === false) {
                this.select();
                return true;
            }
            this.deselect();
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SelectableElementView', function() {

    /**
     * ThumbView
     * 
     * @extends SelectableElementView
     */
    window.ThumbView = SelectableElementView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ThumbView')
         */
        _string: 'ThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._addThumbListeners();
        },

        /**
         * _addThumbListeners
         * 
         * @access  protected
         * @return  void
         */
        _addThumbListeners: function() {
            var areaType = this._getAreaType();
            this.on({
                'unfavorite': function(event) {
                    this._accessor.unfavorite(areaType, true);
                },
                'unfeature': function(event, category) {
                    Modals.showApplyCategories(areaType, this._accessor);
                },
                'unpin': function(event) {
                    var category = this._results.getCategory();
                    this._accessor.unpin(category);
                }
            });
        },

        /**
         * _getAreaType
         * 
         * @access  protected
         * @return  String
         */
        _getAreaType: function() {
            return this._results.getGroup().getArea().getType();
        },

        /**
         * showPreloadingSpinner
         * 
         * @todo    Include logic that the spinner only shows up if it takes at
         *          least 25ms. If that's the case, show the spinner for at least
         *          125ms (to prevent that flicker-experience).
         * @todo    Fix below note, and test by throttling
         * @note    There is a possible bug here for people with slow internet
         *          connections. Specifically, if they click on a thumbnail, and
         *          wait, but it takes too long, they may click on another. When
         *          that happens, they'll notice two different spinners visible.
         *          When the first one that was clicked finally comes back and
         *          triggers the <refresh> event on the background image drawing,
         *          it'll remove the the spinning class, and spinner element,
         *          from both thumbs. A way around this would be to remove the
         *          previous spinner UI (the class and element), if any, whenever
         *          a thumb is clicked. Don't think it's needed at the moment,
         *          though.
         * @note    This method isn't triggered by clicking on a logo, since
         *          logos don't make use of the Joystick view
         * @access  public
         * @param   undefined|Object options
         * @return  void
         */
        showPreloadingSpinner: function(options) {

            /**
             * Draw the spinner inside the thumb, and add the class to the thumb
             * so that it can hide children that shouldn't be shown while the
             * associated image-url is being loaded into the canvas.
             */
            var _this = this,
                canvas = Canvases.Preview,
                areaType = this._getAreaType(),
                $spinner = $('<div class="spinner">' +
                    '<div class="icon fa fa-refresh fa-spin"></div>' +
                    '</div>'
                );
            this._element.append($spinner);
            this._element.addClass('spinning');

            /**
             * If the graphics tab is focused, grab the last layer in the array,
             * and wait for it to be drawn before removing the spinner. This is
             * to detect a successful draw, at which point the spinner is
             * removed.
             * 
             * @todo    Add in support for watermarks
             */
            if (areaType === 'graphics') {
                var layer = canvas.getImage().getImageDocument().getLayers(false).slice(
                    -1
                ).pop();
                layer.getDrawing().once({
                    'draw': function(event) {
                        _this._element.removeClass('spinning');
                        $spinner.remove();
                    }
                });
            }
            /**
             * If the photos tab is focused, grab the photo image layer, and
             * wait for it to be refreshed before removing the spinner. I wait
             * for a refresh rather than a draw here, since the background image
             * layer is always already drawn.
             */
            else if (areaType === 'photos') {
                if (options !== undefined && options.destination === 'foreground') {
                    var layer = canvas.getImage().getImageDocument().getLayers(false).slice(
                        -1
                    ).pop();
                    layer.getDrawing().once({
                        'draw': function(event) {
                            _this._element.removeClass('spinning');
                            $spinner.remove();
                        }
                    });
                } else {
                    canvas.getBackgroundBitmapImageLayer().getDrawing().once({
                        'refresh': function(event) {
                            _this._element.removeClass('spinning');
                            $spinner.remove();
                        }
                    });
                }
            }
            /**
             * Otherwise likely images / templates tab
             */
            else {
                canvas.once({
                    'render': function(event) {
                        _this._element.removeClass('spinning');
                        $spinner.remove();
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * GraphicThumbView
     * 
     * @extends ThumbView
     */
    window.GraphicThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicThumbView')
         */
        _string: 'GraphicThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === Categories.account.favorites('graphics')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _pin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _pin: function(category) {
            this._element.siblings().removeClass('pin');
            this._element.addClass('pin');
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'pin': function(event, category) {
                    _this._pin.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                },
                'unpin': function(event, category) {
                    _this._unpin.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === Categories.account.favorites('graphics')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * _unpin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unpin: function(category) {
            this._element.removeClass('pin');
            this._results.getChildren()[0].getElement().addClass('pin');
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * ImageThumbView
     * 
     * @extends ThumbView
     */
    window.ImageThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageThumbView')
         */
        _string: 'ImageThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor imageAccessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, imageAccessor, results) {
            this._super(element, imageAccessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === Categories.account.favorites('images')) {
                this._element.addClass('favorite');
            }
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'preload': function(event) {
                    var url = this.url('thumb');
                    _this._element.css({
                        'background-image': 'url(\'' + (url) + '\')'
                    });
                    _this._results._drawProperties.drawCallback.apply(_this);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === Categories.account.favorites('images')) {
                this._element.removeClass('favorite');
            }
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * PhotoThumbView
     * 
     * @extends ThumbView
     */
    window.PhotoThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoThumbView')
         */
        _string: 'PhotoThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, accessor, results) {
            this._super(element, accessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === Categories.account.favorites('photos')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _pin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _pin: function(category) {
            this._element.siblings().removeClass('pin');
            this._element.addClass('pin');
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'pin': function(event, category) {
                    _this._pin.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                },
                'unpin': function(event, category) {
                    _this._unpin.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === Categories.account.favorites('photos')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * _unpin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unpin: function(category) {
            this._element.removeClass('pin');
            this._results.getChildren()[0].getElement().addClass('pin');
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * TemplateThumbView
     * 
     * @extends ThumbView
     */
    window.TemplateThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _imageHandlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _imageHandlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateThumbView')
         */
        _string: 'TemplateThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplateAccessor templateAccessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, templateAccessor, results) {
            this._super(element, templateAccessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
            this._accessor.reference('image').on(this._imageHandlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === Categories.account.favorites('templates')) {
                this._element.addClass('favorite');
            } else if (category.belongsToAccount() === false) {
                this._element.addClass('feature');
            }
        },

        /**
         * _pin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _pin: function(category) {
            this._element.siblings().removeClass('pin');
            this._element.addClass('pin');
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
            this._accessor.reference('image').off(this._imageHandlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'pin': function(event, category) {
                    _this._pin.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                },
                'unpin': function(event, category) {
                    _this._unpin.apply(_this, [category]);
                }
            };
            this._imageHandlers = {
                'preload': function(event) {
                    var url = this.url('thumb');
                    _this._element.css({
                        'background-image': 'url(\'' + (url) + '\')'
                    });
                    _this._results._drawProperties.drawCallback.apply(_this);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === Categories.account.favorites('templates')) {
                this._element.removeClass('favorite');
            }
            if (this._accessor.globalCategoriesFeaturedIn().length === 0) {
                this._element.removeClass('feature');
            }
        },

        /**
         * _unpin
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unpin: function(category) {
            this._element.removeClass('pin');
            this._results.getChildren()[0].getElement().addClass('pin');
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ThumbView', function() {

    /**
     * UploadThumbView
     * 
     * @extends ThumbView
     */
    window.UploadThumbView = ThumbView.extend({

        /**
         * _handlers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _handlers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadThumbView')
         */
        _string: 'UploadThumbView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadAccessor uploadAccessor
         * @param   ResultsView results
         * @return  void
         */
        init: function(element, uploadAccessor, results) {
            this._super(element, uploadAccessor, results);
            this._setupHandlers();
            this._addAccessorListeners();
        },

        /**
         * _addAccessorListeners
         * 
         * @access  protected
         * @return  void
         */
        _addAccessorListeners: function() {
            this._accessor.on(this._handlers);
        },

        /**
         * _favorite
         * 
         * @access  protected
         * @return  void
         */
        _favorite: function() {
            this._element.addClass('favorite');
        },

        /**
         * _feature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _feature: function(category) {
            if (category === Categories.account.favorites('uploads')) {
                this._element.addClass('favorite');
            }
        },

        /**
         * _removeListeners
         * 
         * @access  protected
         * @return  void
         */
        _removeListeners: function() {
            this._accessor.off(this._handlers);
        },

        /**
         * _setupHandlers
         * 
         * @access  protected
         * @return  void
         */
        _setupHandlers: function() {
            var _this = this;
            this._handlers = {
                'favorite/ui': function(event) {
                    _this._favorite();
                },
                'feature': function(event, category) {
                    _this._feature.apply(_this, [category]);
                },
                'unfeature': function(event, category) {
                    _this._unfeature.apply(_this, [category]);
                }
            };
        },

        /**
         * _unfeature
         * 
         * @access  protected
         * @param   CategoryAccessor category
         * @return  void
         */
        _unfeature: function(category) {
            if (category === Categories.account.favorites('uploads')) {
                this._element.removeClass('favorite');
            }
        },

        /**
         * remove
         * 
         * This is abstracted out to prevent the joystick from being removed
         * from the DOM. When this happened, event delegation/proxying busted.
         * 
         * @see     https://api.jquery.com/remove/
         * @see     https://api.jquery.com/detach/
         * @access  public
         * @return  void
         */
        remove: function() {
            this.find('.joystick').detach();
            this._element.remove();
            this._removeListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SelectableElementView', function() {

    /**
     * WatermarkView
     * 
     * @extends SelectableElementView
     */
    window.WatermarkView = SelectableElementView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * Fired when a watermark is turned on.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="checkbox"]:checked': function(event, $input) {
                        this._accessor.set({
                            'settings.active': 1
                        });
                        this._accessor.save(['settings.active']);
                        this._accessor.addToCanvas(true);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Fired when a watermark is turned off.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="checkbox"]:not(:checked)': function(event, $input) {
                        this._accessor.set({
                            'settings.active': 0
                        });
                        this._accessor.save(['settings.active']);
                        this._accessor.removeFromCanvas();
                    }
                },
                mouseover: {
                    'label': function(event, $label) {
                        this._accessor.preloadDrawingImage();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkView')
         */
        _string: 'WatermarkView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarkUploadAccessor watermark
         * @param   WatermarkCategoryResultsView watermarkCategoryResults
         * @return  void
         */
        init: function(element, watermark, watermarkCategoryResults) {
            this._super(element, watermark, watermarkCategoryResults);
            this._addSelectListener();
            var _this = this;
            this._accessor.on({
                'change/settings.active': function(event, active) {
                    _this.find('[type="checkbox"]').prop(
                        'checked',
                        active.toInt() === 1
                    );
                },
                'delete': function(event) {
                    _this._element.remove();
                }
            });
        },

        /**
         * _addContextMenuListener
         * 
         * @access  protected
         * @return  void
         */
        _addContextMenuListener: function() {
            this._super();
            this.on({
                'showContextMenu': function(event, $anchor) {
                    this.getResults().deselectAll();
                    this.select();
                    this.showContextMenu();
                }
            });
        },

        /**
         * _addSelectListener
         * 
         * @access  protected
         * @return  void
         */
        _addSelectListener: function() {
            this._element.on({
                'click': function(event) {
                    /**
                     * Shift + Click
                     * 
                     */
                    if (event.shiftKey === true) {
                        event.preventDefault();
                        var $element = $(this),
                            view = $element.data('view'),
                            results = view.getResults(),
                            childrenSelected = results.childrenSelected.all.apply(results);
                        if (childrenSelected.length === 0) {
                            var $range = $element.prevAll().addBack().reverse();
                            $range.each(function(index, element) {
                                $(element).data('view').select();
                                $(element).addClass('active-shift');
                            });
                        } else {
                            var $lastSelected = $element.parent().find('.active-last'),
                                $shiftSelected = $element.parent().find('.active-shift');
                            $shiftSelected.each(function(index, element) {
                                $(element).data('view').deselect();
                            });
                            if ($element[0] === $lastSelected[0]) {
                                $lastSelected.data('view').select();
                            } else {
                                $lastSelected.data('view').deselect();
                                var $range = $lastSelected.getRangeElements($element).reverse();
                                $range.each(function(index, element) {
                                    $(element).data('view').select();
                                    $(element).addClass('active-shift');
                                });
                            }
                            results.reClassifyChildren();
                        }
                    }
                    /**
                     * Command + Click
                     * 
                     */
                    else if (
                        (UserAgent.is.mac() === true && event.metaKey === true)
                        || (UserAgent.is.mac() === false && event.ctrlKey === true)
                    ) {
                        event.preventDefault();
                        var $element = $(this),
                            view = $element.data('view'),
                            results = view.getResults();
                        $element.siblings().removeClass('active-shift');
                        view.toggle();
                        results.reClassifyChildren();
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QueryResultsView', function() {

    /**
     * TimedQueryResultsView
     * 
     * Helper class (but never directly instantiated) to provide certain types
     * of query searches (eg. photos and graphics) with the properties and
     * methods they need to properly reload queries once they need to be
     * reload.
     * 
     * This only needs to exist because some gateways (at the time of
     * documentation, The Noun Project and Pixabay) have asset links expire
     * after a certain amount of time.
     * 
     * @extends QueryResultsView
     */
    window.TimedQueryResultsView = QueryResultsView.extend({

        /**
         * _expires
         * 
         * @access  protected
         * @var     null|Number (default: null)
         */
        _expires: null,

        /**
         * _lastLoadStats
         * 
         * This keeps track of the gateways to skip over incase all the results
         * have already been found for them.
         * 
         * @access  protected
         * @var     false|Object (default: false)
         */
        _lastLoadStats: false,

        /**
         * _maxNumberOfReloads
         * 
         * The maximum number of times a query can be reloaded (to prevent a bug
         * whereby requests were coming in thousands-of-times from one machine).
         * I believe this may have been happening due to a machine-clock issue,
         * since the interval below runs every 250ms, and that may have been
         * causing an unreasonable number of requests to get triggered.
         * 
         * @access  protected
         * @var     Number (default: 10)
         */
        _maxNumberOfReloads: 10,

        /**
         * _numberOfTimesReloaded
         * 
         * Tracks the number of times the query has been reloaded (which
         * happens based on the expiry dates of the returned resources).
         * 
         * @access  protected
         * @var     Number (default: 0)
         */
        _numberOfTimesReloaded: 0,

        /**
         * _secondsUntilReload
         * 
         * Currently set to a default value of one hour, but child classes
         * override this value due to the differences in how the gateways work.
         * 
         * @access  protected
         * @var     Number
         */
        _secondsUntilReload: (1 * 60 * 60),

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TimedQueryResultsView')
         */
        _string: 'TimedQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicQueriesGroupView|PhotoQueriesGroupView queriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, queriesGroup, query) {
            this._super(element, queriesGroup, query);
            this._expires = Math.floor(Date.now() / 1000) + this._secondsUntilReload;
            this._setupExpireCheckInterval();
        },

        /**
         * _setupExpireCheckInterval
         * 
         * @note    Currently only being used by GraphicQueryResultsView and
         *          PhotoQueryResultsView. QuoteQueryResultsView not using it
         *          since those results don't "time out".
         * @access  protected
         * @return  void
         */
        _setupExpireCheckInterval: function() {
            (function() {
                var now = Math.floor(Date.now() / 1000);
                if (this._expires < now) {
                    this._numberOfTimesReloaded++;
                    if (
                        this._numberOfTimesReloaded > this._maxNumberOfReloads
                    ) {
                        Stencil.alert('search.bug');
                        Stencil.kill();
                    } else {
                        this._lastLoadStats = false;
                        this._expires = now + this._secondsUntilReload;
                        this._collection.empty();
                        this.trackLoad();
                        this.load();
                    }
                }
            }).interval(250, this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ContextMenuView', function() {

    /**
     * UGCContextMenuView
     * 
     * @extends ContextMenuView
     */
    window.UGCContextMenuView = ContextMenuView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UGCContextMenuView')
         */
        _string: 'UGCContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView|WatermarksAreaView|UploadsAreaView area
         * @return  void
         */
        init: function(element, area) {
            this._super(element, area);
            this._setupDownloadMultipleEvent();
            this._setupDownloadSingleEvent();
        },

        /**
         * _maxParallelDownloads
         * 
         * @access  protected
         * @return  Number
         */
        _maxParallelDownloads: function() {
            return Config.get('defaults').maxParallelDownloads.toInt();
        },

        /**
         * _setupDownloadMultipleEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupDownloadMultipleEvent: function() {
            this.on({
                'download/multiple': function(event, $anchor) {
                    this.triggerHandler('close');
                    var selected = this._getSelected(),
                        accessor,
                        accessors = [],
                        index,
                        multipleDownloadSettings = this._multipleDownloadSettings;
                    for (index in selected) {
                        accessor = selected[index].getAccessor();
                        accessors.push(accessor);
                    }
                    var msgKey = 'downloads.multiple.pending',
                        msg = Stencil.getMessage(msgKey);
                    App.getBusy().show(msg);
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                    var onceUploaded = function(callback) {
                        var index,
                            accessor,
                            wait = false;
                        for (index in accessors) {
                            accessor = accessors[index];
                            if (accessor.get('uploaded').toInt() === 0) {
                                wait = true;
                                break;
                            }
                        }
                        if (wait === true) {
                            onceUploaded.delay(150, window, [callback]);
                        } else {
                            callback(accessors);
                        }
                    };
                    onceUploaded(function(accessors) {
                        var path = multipleDownloadSettings.path,
                            cookieKey = multipleDownloadSettings.cookieKey,
                            alertKeys = multipleDownloadSettings.alertKeys,
                            alertKey = alertKeys.multiple,
                            index,
                            keys = [];
                        for (index in accessors) {
                            keys.push(accessors[index].get('key'));
                        }
                        path = path + '?' + jQuery.param({
                            data: {
                                keys: keys
                            }
                        });
                        Stencil.once({
                            'redirect/complete': function(event) {
                                App.getBusy().hide();
                                if (UserAgent.is.electron() === true) {
                                    Stencil.alert(alertKey);
                                }
                            }
                        });
                        DownloadUtils.attemptDownload(path, cookieKey);
                    });
                }
            });
        },

        /**
         * _setupDownloadSingleEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupDownloadSingleEvent: function() {
            this.on({
                'download/single': function(event, $anchor) {
                    var multipleDownloadSettings = this._multipleDownloadSettings,
                        alertKeys = multipleDownloadSettings.alertKeys,
                        alertKey = alertKeys.single;
                    this.triggerHandler('close');
                    this._getAccessor().download(true);
                    Stencil.once({
                        'redirect/complete': function(event) {
                            if (UserAgent.is.electron() === true) {
                                Stencil.alert(alertKey);
                            }
                        }
                    });
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _toggleDownloadTooltips
         * 
         * @access  protected
         * @return  void
         */
        _toggleDownloadTooltips: function() {
            this._destroyTooltips();
            var $download = this.find('[lookup="download/multiple"]');
            $download.enable();
            if (this._multipleSelected() === true) {
                var results = this._area.getActiveGroup().getActiveResults(),
                    maxParallelDownloads = this._maxParallelDownloads();
                if (this._getSelected().length > maxParallelDownloads) {
                    var tooltip = this._tooltips.download.limit;
                    tooltip = tooltip.replace('###', maxParallelDownloads);
                    $download.attr('data-title', tooltip);
                    $download.attr('data-original-title', tooltip);
                    this._setupTooltips();
                    $download.disable();
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleDownloadTooltips();
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('DropzoneView', function() {

    /**
     * WatermarksDropzoneView
     * 
     * @events  complete
     * @extends DropzoneView
     */
    window.WatermarksDropzoneView = DropzoneView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.prompt': function(event, $div) {
                        if (Services.check('aws') === false) {
                            Stencil.alert('service.aws');
                        } else {

                            // Pro user
                            if (
                                Account.upgraded() === true
                                || User.admin() === true
                                || User.editor() === true
                            ) {
                                var $file = this.find('input[type="file"]');
                                !this._uploading && $file.trigger('click');
                            }
                            // Upsell
                            else {
                                Stencil.navigate('/app/upgrade/pro/logos?clean=1');
                            }
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarksDropzoneView')
         */
        _string: 'WatermarksDropzoneView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @return  void
         */
        init: function(element, type) {
            this._super(element, type);
        },

        /**
         * availableForUpload
         * 
         * @access  public
         * @return  Boolean
         */
        availableForUpload: function() {

            // S3 is disabled
            if (Services.check('aws') === false) {
                Stencil.alert('service.aws');
                return false;
            }

            // Upgraded/admin user
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                if (this._uploading === true) {
                    return false;
                }
                return true;
            }

            // Guest/free user
            Stencil.navigate('/app/upgrade/pro/logos?clean=1');
            return false;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceContextMenuView', function() {

    /**
     * GraphicContextMenuView
     * 
     * @extends ResourceContextMenuView
     */
    window.GraphicContextMenuView = ResourceContextMenuView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicContextMenuView')
         */
        _string: 'GraphicContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            collections: {
                single: 'Please upgrade<br />to add this icon<br />to a collection',
                limit: 'You can only add up to ### icons<br />from a search to a collection at once',
                multiple: 'Please upgrade<br />to add these icons<br />to a collection'
            },
            favorite: {
                single: 'Please upgrade<br />to favorite this icon',
                limit: 'You can only favorite up to ###<br />icons from a search at once',
                multiple: 'Please upgrade<br />to favorite these icons'
            },
            unfavorite: {
                single: 'Please upgrade<br />to unfavorite this icon',
                multiple: 'Please upgrade<br />to unfavorite these icons'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @return  void
         */
        init: function(element, graphicsArea) {
            this._super(element, graphicsArea);
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
            this._setupViewIconSet();
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    var locked = this._$relative.hasClass('locked');
                    this._getAccessor().select('click', locked, {});
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _setupViewIconSet
         * 
         * @access  protected
         * @return  void
         */
        _setupViewIconSet: function() {
            this.on({
                'viewIconSet': function(event, $anchor) {
                    this.triggerHandler('close');
                    var $anchor = this._$relative.find('a.set'),
                        href = $anchor.attr('href');
                    Stencil.navigate(href);
                }
            });
        },

        /**
         * _toggleIconSetState
         * 
         * @access  protected
         * @return  void
         */
        _toggleIconSetState: function() {
            var $viewIconSet = this.find('[lookup="viewIconSet"]');
            $viewIconSet.addClass('hidden');
            if (this._multipleSelected() === false) {
                if (this._$relative.hasClass('partOfIconSet') === true) {
                    $viewIconSet.removeClass('hidden');
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleIconSetState();
            this._toggleCollectionTooltips();
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UGCContextMenuView', function() {

    /**
     * ImageContextMenuView
     * 
     * @extends UGCContextMenuView
     */
    window.ImageContextMenuView = UGCContextMenuView.extend({

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### images?',
                one: 'Are you sure you want to delete this image?'
            }
        },

        /**
         * _multipleDownloadSettings
         * 
         * @access  protected
         * @var     Object
         */
        _multipleDownloadSettings: {
            alertKeys: {
                multiple: 'clients.electron.images.download.multiple.complete',
                single: 'clients.electron.images.download.single.complete'
            },
            cookieKey: 'images.downloads.multiple.started',
            path: '/images/download'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageContextMenuView')
         */
        _string: 'ImageContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            download: {
                limit: 'You can only download up to ### images at once'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView imagesArea
         * @return  void
         */
        init: function(element, imagesArea) {
            this._super(element, imagesArea);
            this._setupConfirmDeleteEvent();
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupShareEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _preloadShareImage
         * 
         * @access  protected
         * @return  void
         */
        _preloadShareImage: function() {
            App.preloadShareModalStaticAssets();
            var image = this._getAccessor(),
                key = 'image.' + (image.get('key')) + '.preloaded',
                preloaded = Stencil.get(key);
            if (preloaded === undefined) {
                Stencil.set(key, true);
                Images.preload([image.getSrc()]);
            }
        },

        /**
         * _setupDownloadSingleEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupDownloadSingleEvent: function() {
            this.on({
                'download/single': function(event, $anchor) {
                    var multipleDownloadSettings = this._multipleDownloadSettings,
                        alertKeys = multipleDownloadSettings.alertKeys,
                        alertKey = alertKeys.single;
                    this.triggerHandler('close');
                    var mime = this._getAccessor().get('mime');
                    this._getAccessor().download(mime, false, false, false, false, true);
                    Stencil.once({
                        'redirect/complete': function(event) {
                            if (UserAgent.is.electron() === true) {
                                Stencil.alert(alertKey);
                            }
                        }
                    });
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {});
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _setupShareEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupShareEvent: function() {
            this.on({
                'share': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().share();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            if (this._multipleSelected() === false) {
                this._preloadShareImage();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceContextMenuView', function() {

    /**
     * PhotoContextMenuView
     * 
     * @extends ResourceContextMenuView
     */
    window.PhotoContextMenuView = ResourceContextMenuView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoContextMenuView')
         */
        _string: 'PhotoContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            collections: {
                single: 'Please upgrade<br />to add this photo<br />to a collection',
                limit: 'You can only add up to ### photos<br />from a search to a collection at once',
                multiple: 'Please upgrade<br />to add these photos<br />to a collection'
            },
            favorite: {
                single: 'Please upgrade<br />to favorite this photo',
                limit: 'You can only favorite up to ###<br />photos from a search at once',
                multiple: 'Please upgrade<br />to favorite these photos'
            },
            unfavorite: {
                single: 'Please upgrade<br />to unfavorite this photo',
                multiple: 'Please upgrade<br />to unfavorite these photos'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @return  void
         */
        init: function(element, photosArea) {
            this._super(element, photosArea);
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    var locked = this._$relative.hasClass('locked'),
                        options = {
                            autoSelect: true,
                            destination: $anchor.attr('destination')
                        };
                    this._getAccessor().select('click', locked, options);
                    this._getView().showPreloadingSpinner(options);
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleCollectionTooltips();
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ResourceContextMenuView', function() {

    /**
     * QuoteContextMenuView
     * 
     * @extends ResourceContextMenuView
     */
    window.QuoteContextMenuView = ResourceContextMenuView.extend({

        /**
         * _delays
         * 
         * Overwriting parent delays for multiple to ensure partners don't get
         * spammed by requests that are too close together.
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {
            multiple: {
                delete: 650,
                favorite: {
                    category: 650,
                    results: 650
                },
                trailing: 750,
                unfavorite: 650
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteContextMenuView')
         */
        _string: 'QuoteContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @return  void
         */
        init: function(element, quotesArea) {
            this._super(element, quotesArea);
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {});
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _toggleFavoriteState
         * 
         * @access  protected
         * @return  void
         */
        _toggleFavoriteState: function() {
            var $favorite = this.find('[lookup="favorite"]'),
                $unfavorite = this.find('[lookup="unfavorite"]');
            $favorite.addClass('hidden');
            $unfavorite.addClass('hidden');
            if (this._selectedHaveBeenFavorited() === false) {
                $favorite.removeClass('hidden');
            } else {
                $unfavorite.removeClass('hidden');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ContextMenuView', function() {

    /**
     * TemplateContextMenuView
     * 
     * @extends ContextMenuView
     */
    window.TemplateContextMenuView = ContextMenuView.extend({

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### templates?',
                one: 'Are you sure you want to delete this template?'
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateContextMenuView')
         */
        _string: 'TemplateContextMenuView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplatesAreaView templatesArea
         * @return  void
         */
        init: function(element, templatesArea) {
            this._super(element, templatesArea);
            this._setupConfirmDeleteEvent();
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _selectedAreOwned
         * 
         * @access  protected
         * @return  Boolean
         */
        _selectedAreOwned: function() {
            var selected = this._getSelected(),
                index = 0;
            for (index; index < selected.length; ++index) {
                if (selected[index].getAccessor().owned() === false) {
                    return false;
                }
            }
            return true;
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {});
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _toggleDeleteState
         * 
         * @access  protected
         * @return  void
         */
        _toggleDeleteState: function() {
            var $delete = this.find('[lookup="delete"]'),
                $divider = $delete.prev();
            $delete.addClass('hidden');
            $divider.addClass('hidden');
            if (this._selectedAreOwned() === true) {
                $delete.removeClass('hidden');
                $divider.removeClass('hidden');
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._toggleDeleteState();
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UGCContextMenuView', function() {

    /**
     * UploadContextMenuView
     * 
     * @extends UGCContextMenuView
     */
    window.UploadContextMenuView = UGCContextMenuView.extend({

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### uploads?',
                one: 'Are you sure you want to delete this upload?'
            }
        },

        /**
         * _multipleDownloadSettings
         * 
         * @access  protected
         * @var     Object
         */
        _multipleDownloadSettings: {
            alertKeys: {
                multiple: 'clients.electron.uploads.download.multiple.complete',
                single: 'clients.electron.uploads.download.single.complete'
            },
            cookieKey: 'uploads.downloads.multiple.started',
            path: '/uploads/download'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadContextMenuView')
         */
        _string: 'UploadContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            download: {
                limit: 'You can only download up to ### uploads at once'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadsAreaView uploadsArea
         * @return  void
         */
        init: function(element, uploadsArea) {
            this._super(element, uploadsArea);
            this._setupConfirmDeleteEvent();
            this._setupFavoriteEvent();
            this._setupSelectEvent();
            this._setupUnfavoriteEvent();
        },

        /**
         * _setupSelectEvent
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectEvent: function() {
            this.on({
                'select': function(event, $anchor) {
                    this.triggerHandler('close');
                    this._getAccessor().select('click', false, {
                        autoSelect: true,
                        destination: $anchor.attr('destination')
                    });
                    this._getView().showPreloadingSpinner();
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('UGCContextMenuView', function() {

    /**
     * WatermarkContextMenuView
     * 
     * @extends UGCContextMenuView
     */
    window.WatermarkContextMenuView = UGCContextMenuView.extend({

        /**
         * _messages
         * 
         * @access  protected
         * @var     Object
         */
        _messages: {
            delete: {
                multiple: 'Are you sure you want to delete these ### logos / ' +
                    'watermarks?',
                one: 'Are you sure you want to delete this logo / watermark?'
            }
        },

        /**
         * _multipleDownloadSettings
         * 
         * @access  protected
         * @var     Object
         */
        _multipleDownloadSettings: {
            alertKeys: {
                multiple: 'clients.electron.watermarks.download.multiple.complete',
                single: 'clients.electron.watermarks.download.single.complete'
            },
            cookieKey: 'uploads.downloads.multiple.started',
            path: '/uploads/download'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkContextMenuView')
         */
        _string: 'WatermarkContextMenuView',

        /**
         * _tooltips
         * 
         * @access  protected
         * @var     Object
         */
        _tooltips: {
            download: {
                limit: 'You can only download up to ### logos / watermarks ' +
                    'at once'
            }
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarksAreaView watermarksArea
         * @return  void
         */
        init: function(element, watermarksArea) {
            this._super(element, watermarksArea);
            this._setupConfirmDeleteEvent();
            this._setupToggleEvents();
        },

        /**
         * _setupToggleEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupToggleEvents: function() {
            this.on({
                'toggle/on toggle/off': function(event, $anchor) {
                    var $checkbox = this._$relative.find('input[type="checkbox"]');
                    $checkbox.prop('checked', !$checkbox.prop('checked'));
                    $checkbox.trigger('change');
                    this._toggleActiveState();
                },
                'toggle/on': function(event, $anchor) {
                    this.triggerHandler('close');
                    var results = this._area.getActiveGroup().getActiveResults();
                    results.deselectAll();
                }
            });
        },

        /**
         * _toggleActiveState
         * 
         * @access  protected
         * @return  void
         */
        _toggleActiveState: function() {
            var accessor = this._getAccessor();
            this.find('[lookup="toggle/on"]').addClass('hidden');
            this.find('[lookup="toggle/off"]').addClass('hidden');
            if (accessor.setting('active').toInt() === 1) {
                this.find('[lookup="toggle/off"]').removeClass('hidden');
            } else {
                this.find('[lookup="toggle/on"]').removeClass('hidden');
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            if (this._multipleSelected() === false) {
                this._toggleActiveState();
            }
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * EditorView
     * 
     * @extends View
     */
    window.EditorView = View.extend({

        /**
         * _activeArea
         * 
         * @access  protected
         * @var     undefined|AreaView (default: undefined)
         */
        _activeArea: undefined,

        /**
         * _areas
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _areas: {},

        /**
         * _joystick
         * 
         * @access  protected
         * @var     null|JoystickView (default: null)
         */
        _joystick: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $target
                     * @return  void
                     */
                    'div.thumb, div.quote.row': function(event, $target) {
                        this.showParticle($target);
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $target
                     * @return  void
                     */
                    'div.thumb, div.quote.row': function(event, $target) {
                        this.hideParticle($target);
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'EditorView')
         */
        _string: 'EditorView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._drawGraphics();
            this._drawImages();
            this._drawJoystick();
            this._drawPhotos();
            this._drawQuotes();
            this._drawTemplates();
            this._drawUploads();
            this._drawWatermarks();
        },

        /**
         * _drawGraphics
         * 
         * @access  protected
         * @return  void
         */
        _drawGraphics: function() {
            var $graphics = DataUtils.render('GraphicsArea');
            this.find('> div.inner > div.wrapper').append($graphics);
            this._areas.graphics = new GraphicsAreaView($graphics);
        },

        /**
         * _drawImages
         * 
         * @access  protected
         * @return  void
         */
        _drawImages: function() {
            var $images = DataUtils.render('ImagesArea');
            this.find('> div.inner > div.wrapper').append($images);
            this._areas.images = new ImagesAreaView($images);
        },

        /**
         * _drawJoystick
         * 
         * @access  protected
         * @return  void
         */
        _drawJoystick: function() {
            var $joystick = DataUtils.render('Joystick');
            this.find('> div.inner > div.wrapper').append($joystick);
            this._joystick = new JoystickView($joystick);
        },

        /**
         * _drawPhotos
         * 
         * @access  protected
         * @return  void
         */
        _drawPhotos: function() {
            var $photos = DataUtils.render('PhotosArea');
            this.find('> div.inner > div.wrapper').append($photos);
            this._areas.photos = new PhotosAreaView($photos);
        },

        /**
         * _drawQuotes
         * 
         * @access  protected
         * @return  void
         */
        _drawQuotes: function() {
            var $quotes = DataUtils.render('QuotesArea');
            this.find('> div.inner > div.wrapper').append($quotes);
            this._areas.quotes = new QuotesAreaView($quotes);
        },

        /**
         * _drawTemplates
         * 
         * @access  protected
         * @return  void
         */
        _drawTemplates: function() {
            var $templates = DataUtils.render('TemplatesArea');
            this.find('> div.inner > div.wrapper').append($templates);
            this._areas.templates = new TemplatesAreaView($templates);
        },

        /**
         * _drawUploads
         * 
         * @access  protected
         * @return  void
         */
        _drawUploads: function() {
            var $uploads = DataUtils.render('UploadsArea', {
                accept: Config.default('imageUploadMimeTypes')
            });
            this.find('> div.inner > div.wrapper').append($uploads);
            this._areas.uploads = new UploadsAreaView($uploads);
        },

        /**
         * _drawWatermarks
         * 
         * @access  protected
         * @return  void
         */
        _drawWatermarks: function() {
            var $watermarks = DataUtils.render('WatermarksArea', {
                accept: Config.default('imageUploadMimeTypes')
            });
            this.find('> div.inner > div.wrapper').append($watermarks);
            this._areas.watermarks = new WatermarksAreaView($watermarks);
        },

        /**
         * getActiveArea
         * 
         * @note    It's possible that this method is called before an active
         *          area has been set. For example, if the user lands here
         *          somewhow, no area will have been set as active:
         *          https://i.imgur.com/0p6z2xu.png
         * @access  public
         * @return  AreaView|undefined
         */
        getActiveArea: function() {
            return this._activeArea;
        },

        /**
         * getArea
         * 
         * @access  public
         * @param   String type
         * @return  AreaView
         */
        getArea: function(type) {
            return this._areas[type];
        },

        /**
         * getAreas
         * 
         * @access  public
         * @return  Object
         */
        getAreas: function() {
            return this._areas;
        },

        /**
         * getJoystick
         * 
         * @access  public
         * @return  JoystickView
         */
        getJoystick: function() {
            return this._joystick;
        },

        /**
         * hideParticle
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        hideParticle: function($element) {
            $element.removeClass('hover');
        },

        /**
         * setActiveArea
         * 
         * @access  protected
         * @param   AreaView area
         * @return  void
         */
        setActiveArea: function(area) {
            this._activeArea = area;
        },

        /**
         * showParticle
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        showParticle: function($element) {
            $element.siblings().removeClass('hover');
            $element.addClass('hover');
            $element.append(this._joystick.getElement());
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoriesGroupView', function() {

    /**
     * GraphicCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.GraphicCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'GraphicCategoryResults',
            view: 'GraphicCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicCategoriesGroupView')
         */
        _string: 'GraphicCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @return  void
         */
        init: function(element, graphicsArea) {
            this._super(element, graphicsArea);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/icons/search/shape
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._activeResults === null) {
                return Categories.global.featured('graphics').getPath();
            }
            return this._super();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.removeClass('queried');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QueriesGroupView', function() {

    /**
     * GraphicQueriesGroupView
     * 
     * @extends QueriesGroupView
     */
    window.GraphicQueriesGroupView = QueriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            fallback: function() {
                var searchTerms = ['Fruit', 'People', 'Share', 'Arrow'],
                    term = searchTerms[
                        Math.floor(Math.random() * searchTerms.length)
                    ];
                return {
                    copy: term,
                    link: '/app/icons/search/' + term.toLowerCase()
                };
            },
            template: 'GraphicQueryResults',
            view: 'GraphicQueryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicQueriesGroupView')
         */
        _string: 'GraphicQueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @return  void
         */
        init: function(element, graphicsArea) {
            this._super(element, graphicsArea);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.addClass('queried');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoriesGroupView', function() {

    /**
     * ImageCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.ImageCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'ImageCategoryResults',
            view: 'ImageCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageCategoriesGroupView')
         */
        _string: 'ImageCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView imagesArea
         * @return  void
         */
        init: function(element, imagesArea) {
            this._super(element, imagesArea);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoriesGroupView', function() {

    /**
     * PhotoCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.PhotoCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'PhotoCategoryResults',
            view: 'PhotoCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoCategoriesGroupView')
         */
        _string: 'PhotoCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @return  void
         */
        init: function(element, photosArea) {
            this._super(element, photosArea);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/photos/search/people
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._activeResults === null) {
                return Categories.global.featured('photos').getPath();
            }
            return this._super();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.removeClass('queried');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QueriesGroupView', function() {

    /**
     * PhotoQueriesGroupView
     * 
     * @extends QueriesGroupView
     */
    window.PhotoQueriesGroupView = QueriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            fallback: function() {
                var searchTerms = ['Skiing', 'Nature', 'Beach', 'Puppies'],
                    term = searchTerms[
                        Math.floor(Math.random() * searchTerms.length)
                    ];
                return {
                    copy: term,
                    link: '/app/photos/search/' + term.toLowerCase()
                };
            },
            template: 'PhotoQueryResults',
            view: 'PhotoQueryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoQueriesGroupView')
         */
        _string: 'PhotoQueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @return  void
         */
        init: function(element, photosArea) {
            this._super(element, photosArea);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.addClass('queried');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoriesGroupView', function() {

    /**
     * QuoteCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.QuoteCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'QuoteCategoryResults',
            view: 'QuoteCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteCategoriesGroupView')
         */
        _string: 'QuoteCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @return  void
         */
        init: function(element, quotesArea) {
            this._super(element, quotesArea);
        },

        /**
         * getPath
         * 
         * Returns the path of the last active category section. The reason
         * there's a check here for a null active property is because it is
         * possible for a user to land directly in the app via a path like:
         * /app/quotes/search/people
         * 
         * When that happens, there will not have been an active category before
         * hand; thus, need to dynamically grab the default category (which will
         * create the appropriate section), and _then_ grab the path.
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            if (this._activeResults === null) {
                return Categories.global.featured('quotes').getPath();
            }
            return this._super();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.removeClass('queried');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QueriesGroupView', function() {

    /**
     * QuoteQueriesGroupView
     * 
     * @extends QueriesGroupView
     */
    window.QuoteQueriesGroupView = QueriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            fallback: function() {
                var searchTerms = ['Love', 'Success', 'Freedom', 'Friendship'],
                    term = searchTerms[
                        Math.floor(Math.random() * searchTerms.length)
                    ];
                return {
                    copy: term,
                    link: '/app/quotes/search/' + term.toLowerCase()
                };
            },
            template: 'QuoteQueryResults',
            view: 'QuoteQueryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteQueriesGroupView')
         */
        _string: 'QuoteQueriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @return  void
         */
        init: function(element, quotesArea) {
            this._super(element, quotesArea);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var resourceSearch = this._area.getResourceSearch(),
                $search = resourceSearch.find('input.search'),
                $parent = $search.parent();
            $search.val('');
            $parent.removeClass('active');
            $parent.addClass('queried');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoriesGroupView', function() {

    /**
     * TemplateCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.TemplateCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'TemplateCategoryResults',
            view: 'TemplateCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateCategoriesGroupView')
         */
        _string: 'TemplateCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplatesAreaView templatesArea
         * @return  void
         */
        init: function(element, templatesArea) {
            this._super(element, templatesArea);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoriesGroupView', function() {

    /**
     * UploadCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.UploadCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'UploadCategoryResults',
            view: 'UploadCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadCategoriesGroupView')
         */
        _string: 'UploadCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadsAreaView uploadsArea
         * @return  void
         */
        init: function(element, uploadsArea) {
            this._super(element, uploadsArea);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoriesGroupView', function() {

    /**
     * WatermarkCategoriesGroupView
     * 
     * @extends CategoriesGroupView
     */
    window.WatermarkCategoriesGroupView = CategoriesGroupView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'WatermarkCategoryResults',
            view: 'WatermarkCategoryResultsView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkCategoriesGroupView')
         */
        _string: 'WatermarkCategoriesGroupView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarksAreaView watermarksArea
         * @return  void
         */
        init: function(element, watermarksArea) {
            this._super(element, watermarksArea);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaNavView', function() {

    /**
     * GraphicAreaNavView
     * 
     * @extends AreaNavView
     */
    window.GraphicAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicAreaNavView')
         */
        _string: 'GraphicAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicsAreaView graphicsArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, graphicsArea, categories) {
            this._super(element, graphicsArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                Categories.account.favorites('graphics')
            );
            this.addCategoryCountChangeListener(
                Categories.global.featured('graphics')
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaNavView', function() {

    /**
     * ImageAreaNavView
     * 
     * @extends AreaNavView
     */
    window.ImageAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageAreaNavView')
         */
        _string: 'ImageAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImagesAreaView imagesArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, imagesArea, categories) {
            this._super(element, imagesArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                Categories.account.favorites('images')
            );
            this.addCategoryCountChangeListener(
                Categories.account.list('images')
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaNavView', function() {

    /**
     * PhotoAreaNavView
     * 
     * @extends AreaNavView
     */
    window.PhotoAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoAreaNavView')
         */
        _string: 'PhotoAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotosAreaView photosArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, photosArea, categories) {
            this._super(element, photosArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                Categories.account.favorites('photos')
            );
            this.addCategoryCountChangeListener(
                Categories.global.featured('photos')
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaNavView', function() {

    /**
     * QuoteAreaNavView
     * 
     * @extends AreaNavView
     */
    window.QuoteAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteAreaNavView')
         */
        _string: 'QuoteAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuotesAreaView quotesArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, quotesArea, categories) {
            this._super(element, quotesArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                Categories.account.favorites('quotes')
            );
            this.addCategoryCountChangeListener(
                Categories.global.featured('quotes')
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaNavView', function() {

    /**
     * TemplateAreaNavView
     * 
     * @extends AreaNavView
     */
    window.TemplateAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateAreaNavView')
         */
        _string: 'TemplateAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplatesAreaView templatesArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, templatesArea, categories) {
            this._super(element, templatesArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                Categories.account.favorites('templates')
            );
            this.addCategoryCountChangeListener(
                Categories.global.featured('templates')
            );
            this.addCategoryCountChangeListener(
                Categories.account.list('templates')
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaNavView', function() {

    /**
     * UploadAreaNavView
     * 
     * @extends AreaNavView
     */
    window.UploadAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadAreaNavView')
         */
        _string: 'UploadAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   UploadsAreaView uploadsArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, uploadsArea, categories) {
            this._super(element, uploadsArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                Categories.account.favorites('uploads')
            );
            this.addCategoryCountChangeListener(
                Categories.account.list('uploads')
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AreaNavView', function() {

    /**
     * WatermarkAreaNavView
     * 
     * @extends AreaNavView
     */
    window.WatermarkAreaNavView = AreaNavView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkAreaNavView')
         */
        _string: 'WatermarkAreaNavView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   WatermarksAreaView watermarksArea
         * @param   Array categories
         * @return  void
         */
        init: function(element, watermarksArea, categories) {
            this._super(element, watermarksArea, categories);
        },

        /**
         * _setupCountListeners
         * 
         * @access  protected
         * @return  void
         */
        _setupCountListeners: function() {
            this._super();
            this.addCategoryCountChangeListener(
                Categories.account.list('watermarks')
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoryResultsView', function() {

    /**
     * GraphicCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.GraphicCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'GraphicThumb',
            view: 'GraphicThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicCategoryResultsView')
         */
        _string: 'GraphicCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   GraphicCategoriesGroupView graphicCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, graphicCategoriesGroup, category) {
            this._collection = new GraphicFeaturesCollection();
            this._super(element, graphicCategoriesGroup, category);
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.toString() === 'ResourceAccessor') {
                        if (accessor.saved() === true) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        if (accessor.get('uploaded').toInt() === 1) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    }
                    _this._drawChild(accessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').graphics.categories;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search');
            $search.blur();
            if (this._category.get('featured').toInt() === 1) {
                if (
                    UserAgent.is.tablet() === false
                    && UserAgent.is.ie() === false
                ) {
                    $search.focus();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('TimedQueryResultsView', function() {

    /**
     * GraphicQueryResultsView
     * 
     * @noto    In the past, I've noticed TNP sometimes caching search requests.
     *          For example, I (Oliver) do a search for "love" at 7:30pm EST and
     *          get a collection of icons that are set to expire at 8:30pm EST.
     *          Then Adam does a search at 8:20pm EST, and because the search
     *          may come back as a part of a cached result set, his icons are
     *          set to expire 10 minutes later.
     *          
     *          As of 18 July 2017, this is still the case. 
     *          
     *          To deal with this, when this QueryResultsView is instantiated, I
     *          set the _expires property to the appropriate timestamp taking
     *          into consideration the _secondsUntilReload value.
     *          
     *          However, after that, each time I add a resource to the
     *          collection, I set the _expires variable to the lowest possible
     *          expiry timestamp, to ensure that at the earliest required point
     *          in time, the result set is reloaded.
     *          
     *          Here's a sample SVG link:
     *          https://d30y9cdsu7xlg0.cloudfront.net/noun-svg/215288.svg?Expires=1452645199&Signature=cGU10SmwvHMJc4drNz-eavJO2RQwqXPuursIR74nzdtTAo~LHmdsBgbq49dJfQbWzfn-0ee93gqvK8ZT9L7uwiL38jkDEEmuWIOGOFUIlu95EyhY1l-BnXcCB0TTKVFUGd8jfF9kYDo6iC27PoANo43-RuVWtIOoBtjwvYu9R3E_&Key-Pair-Id=APKAI5ZVHAXN65CHVU2Q
     * @extends TimedQueryResultsView
     */
    window.GraphicQueryResultsView = TimedQueryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'GraphicThumb',
            view: 'GraphicThumbView'
        },

        /**
         * _secondsUntilReload
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons). Set to this value because at present, The Noun
         * Project expires links after 1 hour, though their documentation states
         * 24 hours :/
         * 
         * There is the possible case whereby a user searches for something that
         * only results in non-expiring results (eg. EmojiOne emojis). In that
         * case, it seems the reload will happen regardless after one hour. Not
         * ideal, but oh well.
         * 
         * @see     http://api.thenounproject.com/documentation.html
         * @see     https://i.imgur.com/mOrzOwT.png
         * @access  protected
         * @var     Number
         */
        _secondsUntilReload: (1 * 60 * 60) - 60,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GraphicQueryResultsView')
         */
        _string: 'GraphicQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   GraphicQueriesGroupView graphicQueriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, graphicQueriesGroup, query) {
            this._collection = new GraphicResourcesCollection();
            this._super(element, graphicQueriesGroup, query);
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    var svg = accessor.get('urls').svg,
                        expires;
                    if (svg.match(/Expires\=([0-9]+)/) !== null) {
                        expires = svg.match(/Expires\=([0-9]+)/).pop().toInt();
                        _this._expires = Math.min(_this._expires, expires);
                    }
                    _this._drawChild(accessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var path = '/app/icons/search/' + encodeURIComponent(this._query);
            return path;
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {

            // Refresh the scrollbar if it's needed
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').graphics.results;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }

            // Service check
            if (Services.check('theNounProject') === false) {
                this._collection.triggerHandler('list');
                this.find('.messaging,.empty,.disabled').addClass('hidden');
                this.find('.messaging,.disabled').removeClass('hidden');
            } else {
                this._collection.list({
                    lastLoadStats: this._lastLoadStats,
                    limit: limit,
                    // multiple: 1,
                    offset: numberOfResults,
                    query: this._query,
                    type: 'graphics'
                }, function(response) {
                    _this._loading = false;
                    _this._more = response.data.more;
                    _this._lastLoadStats = response.data.stats;
                    _this._showHideFinishedState(limit);
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoryResultsView', function() {

    /**
     * ImageCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.ImageCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            drawCallback: function() {
                var $element = this.getElement();
                if ($element.hasClass('loaded') === true) {
                    $element.addClass('backgroundTransparentFallback');
                    var currentBackgroundImageValue = $element.css('background-image'),
                        transparentBackgroundImageValue = 'url(\'' + (window.STATIC) + '/app/static/images/backgrounds/checkered.png\')';
                    // transparentBackgroundImageValue = transparentBackgroundImageValue.replace(/^([^,]*)(,)([^,]*)(,)(.*)$/, '$1$2$3');
                    $element.css({
                        backgroundImage: (currentBackgroundImageValue) + ', ' +
                            transparentBackgroundImageValue
                    });
                }
            },
            template: 'ImageThumb',
            view: 'ImageThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageCategoryResultsView')
         */
        _string: 'ImageCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   ImageCategoriesGroupView imageCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, imageCategoriesGroup, category) {
            this._collection = new ImageFeaturesCollection();
            this._super(element, imageCategoriesGroup, category);
            var _this = this;
            this._collection.on({
                'add': function(event, imageAccessor, position) {
                    if (imageAccessor.get('uploaded').toInt() === 1) {
                        category.syncedFeatures.add.apply(category, [imageAccessor]);
                    }
                    var child = _this._drawChild(imageAccessor, position);
                    _this._drawProperties.drawCallback.apply(child);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, imageAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === imageAccessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [imageAccessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').images.categories;

            // Start at the beginning if first accessor is being uploaded atm
            if (numberOfResults === 1) {
                var first = this._collection.first();
                if (first.get('uploaded').toInt() === 0) {
                    numberOfResults = 0;
                }
            }
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoryResultsView', function() {

    /**
     * PhotoCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.PhotoCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'PhotoThumb',
            view: 'PhotoThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoCategoryResultsView')
         */
        _string: 'PhotoCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   PhotoCategoriesGroupView photoCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, photoCategoriesGroup, category) {
            this._collection = new PhotoFeaturesCollection();
            this._super(element, photoCategoriesGroup, category);
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.toString() === 'ResourceAccessor') {
                        if (accessor.saved() === true) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        if (accessor.get('uploaded').toInt() === 1) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    }
                    _this._drawChild(accessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').photos.categories;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search');
            $search.blur();
            if (this._category.get('featured').toInt() === 1) {
                if (
                    UserAgent.is.tablet() === false
                    && UserAgent.is.ie() === false
                ) {
                    $search.focus();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('TimedQueryResultsView', function() {

    /**
     * PhotoQueryResultsView
     * 
     * @extends TimedQueryResultsView
     */
    window.PhotoQueryResultsView = TimedQueryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'PhotoThumb',
            view: 'PhotoThumbView'
        },

        /**
         * _secondsUntilReload
         * 
         * The number of seconds before the query should be refreshed (for url
         * caching reasons). Set to this value because at present, Pixabay links
         * expire after 24 hours.
         * 
         * @see     https://pixabay.com/api/docs/
         * @see     https://i.imgur.com/484aa4c.png
         * @access  protected
         * @var     Number
         */
        _secondsUntilReload: (24 * 60 * 60) - 60,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PhotoQueryResultsView')
         */
        _string: 'PhotoQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   PhotoQueriesGroupView photoQueriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, photoQueriesGroup, query) {
            this._collection = new PhotoResourcesCollection();
            this._super(element, photoQueriesGroup, query);
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._drawChild(accessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            var path = '/app/photos/search/' + encodeURIComponent(this._query);
            return path;
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {

            // Refresh the scrollbar if it's needed
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').photos.results;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }

            // Gateway check
            var photoSearchRange = Config.default('photoSearchRange').toLowerCase(),
                photoSearchDefaultGateway = Config.default('photoSearchDefaultGateway').toLowerCase();
            if (photoSearchRange === 'single' && Services.check(photoSearchDefaultGateway) === false) {
                this._collection.triggerHandler('list');
                this.find('.messaging,.empty,.disabled').addClass('hidden');
                this.find('.messaging,.disabled').removeClass('hidden');
            } else {
                this._collection.list({
                    lastLoadStats: this._lastLoadStats,
                    limit: limit,
                    offset: numberOfResults,
                    query: this._query,
                    type: 'photos'
                }, function(response) {
                    _this._loading = false;
                    _this._more = response.data.more;
                    _this._lastLoadStats = response.data.stats;
                    _this._showHideFinishedState(limit);
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoryResultsView', function() {

    /**
     * QuoteCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.QuoteCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'QuoteRow',
            view: 'ChildQuoteRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteCategoryResultsView')
         */
        _string: 'QuoteCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   QuoteCategoriesGroupView quoteCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, quoteCategoriesGroup, category) {
            this._collection = new QuoteFeaturesCollection();
            this._super(element, quoteCategoriesGroup, category);
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.toString() === 'QuoteResourceAccessor') {
                        if (accessor.saved() === true) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    } else {
                        if (accessor.get('uploaded').toInt() === 1) {
                            category.syncedFeatures.add.apply(category, [accessor]);
                        }
                    }
                    _this._drawChild(accessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * _onResultsReady
         * 
         * @note    This executes right away because there's no images to lazy
         *          load.
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            callback.apply(this);
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').quotes.categories;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            var area = this._group.getArea(),
                resourceSearch = area.getResourceSearch(),
                $search = resourceSearch.find('input.search');
            $search.blur();
            if (this._category.get('featured').toInt() === 1) {
                if (
                    UserAgent.is.tablet() === false
                    && UserAgent.is.ie() === false
                ) {
                    $search.focus();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('QueryResultsView', function() {

    /**
     * QuoteQueryResultsView
     * 
     * @extends QueryResultsView
     */
    window.QuoteQueryResultsView = QueryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'QuoteRow',
            view: 'ChildQuoteRowView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'QuoteQueryResultsView')
         */
        _string: 'QuoteQueryResultsView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   QuoteQueriesGroupView quoteQueriesGroup
         * @param   String query
         * @return  void
         */
        init: function(element, quoteQueriesGroup, query) {
            this._collection = new QuoteResourcesCollection();
            this._super(element, quoteQueriesGroup, query);
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    _this._drawChild(accessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * _onResultsReady
         * 
         * @note    This executes right away because there's no images to lazy
         *          load.
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            callback.apply(this);
        },

        /**
         * getPath
         * 
         * @access  public
         * @return  String
         */
        getPath: function() {
            return '/app/quotes/search/' + encodeURIComponent(this._query);
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').quotes.results;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }

            // Gateway check
            if (Services.check('quotes') === false) {
                this._collection.triggerHandler('list');
                this.find('.messaging,.empty,.disabled').addClass('hidden');
                this.find('.messaging,.disabled').removeClass('hidden');
            } else {
                this._collection.list({
                    limit: limit,
                    offset: numberOfResults,
                    query: this._query,
                    type: 'quotes'
                }, function(response) {
                    _this._loading = false;
                    _this._more = response.data.more;
                    _this._showHideFinishedState(limit);
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoryResultsView', function() {

    /**
     * TemplateCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.TemplateCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            drawCallback: function() {
                var $element = this.getElement();
                if ($element.hasClass('loaded') === true) {
                    $element.addClass('backgroundTransparentFallback');
                    var currentBackgroundImageValue = $element.css('background-image'),
                        transparentBackgroundImageValue = 'url(\'' + (window.STATIC) + '/app/static/images/backgrounds/checkered.png\')';
                    // transparentBackgroundImageValue = transparentBackgroundImageValue.replace(/^([^,]*)(,)([^,]*)(,)(.*)$/, '$1$2$3');
                    $element.css({
                        backgroundImage: (currentBackgroundImageValue) + ', ' +
                            transparentBackgroundImageValue
                    });
                }
            },
            template: 'TemplateThumb',
            view: 'TemplateThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplateCategoryResultsView')
         */
        _string: 'TemplateCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   TemplateCategoriesGroupView templateCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, templateCategoriesGroup, category) {
            this._collection = new TemplateFeaturesCollection();
            this._super(element, templateCategoriesGroup, category);
            var _this = this;
            this._collection.on({
                'add': function(event, templateAccessor, position) {
                    if (templateAccessor.reference('image').get('uploaded').toInt() === 1) {
                        category.syncedFeatures.add.apply(category, [templateAccessor]);
                    }
                    var child = _this._drawChild(templateAccessor, position);
                    _this._drawProperties.drawCallback.apply(child);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, templateAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === templateAccessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [templateAccessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').templates.categories;

            // Start at the beginning if first accessor is being uploaded atm
            if (numberOfResults === 1) {
                var first = this._collection.first().reference('image');
                if (first.get('uploaded').toInt() === 0) {
                    numberOfResults = 0;
                }
            }
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoryResultsView', function() {

    /**
     * UploadCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.UploadCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'UploadThumb',
            view: 'UploadThumbView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UploadCategoryResultsView')
         */
        _string: 'UploadCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   UploadCategoriesGroupView uploadCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, uploadCategoriesGroup, category) {
            this._collection = new UploadFeaturesCollection();
            this._super(element, uploadCategoriesGroup, category);
            var _this = this;
            this._collection.on({
                'add': function(event, uploadAccessor, position) {
                    _this._drawChild(uploadAccessor, position);
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, uploadAccessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === uploadAccessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [uploadAccessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').uploads.categories;

            // Start at the beginning if individual uploaded
            if (numberOfResults === 1) {
                numberOfResults = 0;
            }
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CategoryResultsView', function() {

    /**
     * WatermarkCategoryResultsView
     * 
     * @extends CategoryResultsView
     */
    window.WatermarkCategoryResultsView = CategoryResultsView.extend({

        /**
         * _drawProperties
         * 
         * @access  protected
         * @var     Object
         */
        _drawProperties: {
            template: 'WatermarkThumb',
            view: 'WatermarkView'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkCategoryResultsView')
         */
        _string: 'WatermarkCategoryResultsView',

        /**
         * init
         * 
         * @note    Collection should be created before parent constructor called
         *          to ensure it doesn't cause any issues with setting up the
         *          sort logic
         * @access  public
         * @param   jQuery element
         * @param   WatermarkCategoriesGroupView watermarkCategoriesGroup
         * @param   CategoryAccessor category
         * @return  void
         */
        init: function(element, watermarkCategoriesGroup, category) {
            this._collection = new WatermarkFeaturesCollection();
            this._super(element, watermarkCategoriesGroup, category);
            this._setupAuthReloading();
            var _this = this;
            this._collection.on({
                'add': function(event, accessor, position) {
                    if (accessor.get('usable').toInt() === 1) {
                        _this._drawChild(accessor, position);
                    }
                },
                'list': function(event) {
                    _this.showHideEmptyState();
                    _this.triggerHandler('loaded');
                    _this.find('div.status.loading').addClass('hidden');
                    _this.refreshScrollbar();
                },
                'remove': function(event, accessor) {
                    var children = _this.getChildren(),
                        index;
                    for (index in children) {
                        if (children[index].getAccessor() === accessor) {
                            children[index].remove();
                            children.splice(index, 1);
                            category.features.remove.apply(category, [accessor]);
                            break;
                        }
                    }
                },
                'update': function(event) {// Needed to accommodate one-offs
                    _this.showHideEmptyState();
                    _this.lazyLoadChildren();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * _onResultsReady
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _onResultsReady: function(callback) {
            var interval = (function() {
                var selectors = [
                        '.watermark.loaded label.lazy'
                    ],
                    selector = selectors.join(',');
                if (this.find(selector).length > 0) {
                    IntervalPool.clear(interval);
                    this.hourglass();
                }
            }).interval(50, this);
        },

        /**
         * _setupAuthReloading
         * 
         * Adds additional signup/upgrade events since watermarks are behind a
         * pay-wall. No other section has different UI states based on being a
         * guest, free user and upgaded user in the way that AllWatermarks does.
         * 
         * @access  protected
         * @return  void
         */
        _setupAuthReloading: function() {
            var _this = this;
            User.once({
                'login': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
            User.once({
                'signup': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
            Account.once({
                'upgrade': function(event, user) {
                    _this._loaded = false;
                    _this._collection.empty();
                }
            });
        },

        /**
         * lazyLoadChildren
         * 
         * @note    <loading> class used below to ensure no duplicate calls made
         *          to lazy load assets incase a collection <update> event fires
         *          twice. To reproduce this, comment out the <loading> class
         *          lines below, reload browser from Background filters tab,
         *          upload an image, and switch to the uploads tab.
         * @note    <waiting> class is used below in cases where there are
         *          hundreds of assets. In those cases, 50 will be drawn upon
         *          load, but the last X won't be loaded, because they're so far
         *          below the threshold value for preloading. Without the
         *          <waiting> class, an infinite-scroll could trigger an
         *          additional collection:update event, which could result in
         *          multiple lazy events beyond attached to the element. When
         *          that happens, things bust :(
         * @access  public
         * @return  void
         */
        lazyLoadChildren: function() {
            var $elements = this.find(
                '.watermark:not(.loading):not(.loaded):not(.waiting) .lazy'
            );
            $elements.parent().addClass('waiting');
            $elements.lazyload({
                threshold: 500,
                container: this._element.find('.results').first(),
                effect: 'fadeIn',
                appear: function(remaining, settings) {
                    $(this).parent().addClass('loading');
                },
                load: function(remaining, settings) {
                    $(this).parent().addClass('loaded');
                    $(this).parent().removeClass('loading');
                    $(this).parent().removeClass('waiting');
                    $(this).removeAttr('data-original');
                }
            });
        },

        /**
         * load
         * 
         * @access  public
         * @return  void
         */
        load: function() {
            var _this = this,
                numberOfResults = this.getNumberOfResults(),
                limit = Config.default('objectsPerPage').watermarks.categories;
            if (numberOfResults !== 0) {
                this.find('div.status.loading').removeClass('hidden');
                this.refreshScrollbar();
            }
            this._collection.list({
                category: this._category.get('key'),
                limit: limit,
                offset: numberOfResults
            }, function(response) {
                _this._loading = false;
                _this._more = response.data.more;
                _this._showHideFinishedState(limit);
            });
        },

        /**
         * showHideEmptyState
         * 
         * Could not think of a good name for this method. It show/hides the
         * appropriate elements based on whether the collection contains any
         * objects or not.
         * 
         * @access  public
         * @return  void
         */
        showHideEmptyState: function() {
            this.find('.results').removeClass('hidden');
            this.find('.messaging,.empty,.guest,.free').addClass('hidden');
            if (
                Account.upgraded() === true
                || User.admin() === true
                || User.editor() === true
            ) {
                if (this._collection.usable().length === 0) {
                    this.find('.results').addClass('hidden');
                    this.find('.messaging,.empty').removeClass('hidden');
                }
            } else {
                this.find('.results').addClass('hidden');
                if (Account.guest() === true) {
                    this.find('.messaging,.guest').removeClass('hidden');
                } else if (Account.free() === true) {
                    this.find('.messaging,.free').removeClass('hidden');
                } else {
                    // Should never get here
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('FormView', function() {

    /**
     * AppFormView
     * 
     * @extends FormView
     */
    window.AppFormView = FormView.extend({

        /**
         * _fallback
         * 
         * @access  protected
         * @var     String (default: 'Something went wrong. Please try again.')
         */
        _fallback: 'Something went wrong. Please try again',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * This detects the client being focused on a submission
                     * element, and pressing either the enter key or space key
                     * to trigger submission.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        if (event.which === 13 || event.which === 32) {
                            event.preventDefault();
                            this.triggerHandler('submit');
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AppFormView')
         */
        _string: 'AppFormView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'submitted': function(event) {
                    this.clearErrors();
                    this.find('a.button').addClass('busy');
                    this.find('a.button').disable();
                },
                'returned': function(event) {
                    this.find('a.button').removeClass('busy');
                },
                'returned/failed': function(event, response) {
                    this.find('a.button').enable();
                    var error = this.getError(response);
                    this.showError(error);
                },
                'returned/shit': function(event, response) {
                    this.find('a.button').enable();
                    var error = this.getError(response);
                    this.showError(error);
                },
                'returned/succeeded': function(event, response) {
                    this.find('a.button').addClass('done');
                    (function() {
                        this.find('a.button').removeClass('done');
                        this.find('a.button').enable();
                    }).delay(2000, this);
                    // }, this._timeout);
                }
            });
        },

        /**
         * setErrorMessage
         * 
         * @access  protected
         * @param   String msg
         * @return  void
         */
        setErrorMessage: function(msg) {
            var $callout = this.find('.callout.errors');
            $callout.find('p').html(msg);
        },

        /**
         * showError
         * 
         * @access  protected
         * @param   Object error
         * @return  void
         */
        showError: function(error) {
            if (error.code) {
                Track.event('Form Error', {
                    _code: error.code
                });
            }
            this.setErrorMessage(error.message);
            var $callout = this.find('.callout.errors');
            $callout.removeClass('hidden');
            error.input && error.input.focus();
        },

        /**
         * clearErrors
         * 
         * @access  public
         * @return  void
         */
        clearErrors: function() {
            this.find('div.callout.errors').addClass('hidden');
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this._super();
            this.find('select').disable();
            this.find('select').selectpicker('refresh');
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            this._super();
            this.find('select').enable();
            this.find('select').selectpicker('refresh');
        },

        /**
         * getError
         * 
         * @access  public
         * @param   Object response
         * @return  Object
         */
        getError: function(response) {
            var error = response && response.failedRules && response.failedRules[0]
                    && response.failedRules[0].error,
                message = this._fallback,
                input = this._element.focusable(),
                code = false;
            if (error) {
                message = error.message || message;
                code = error.code || false;
                if (error.input) {
                    input = this.find('[name="' + (error.input) + '"]');
                }
            }
            return {
                code: code,
                message: message,
                input: input
            };
        },

        /**
         * setFallback
         * 
         * @access  public
         * @param   String message
         * @return  void
         */
        setFallback: function(message) {
            this._fallback = message;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AppFormView', function() {

    /**
     * CreditCardAppFormView
     * 
     * @see     https://stripe.com/docs/testing
     *          https://stripe.com/docs/stripe.js
     *          https://dashboard.stripe.com/fraud/rules
     * @events  card/submit
     *          card/submitted
     *          card/returned
     *          card/returned/failed
     *          card/returned/succeeded
     * @testing Visa 4242424242424242
     *          Visa 4012888888881881
     *          MasterCard 5555555555554444
     *          MasterCard 5105105105105100
     *          American Express 378282246310005
     *          American Express 371449635398431
     *          Discover 6011111111111117
     *          Discover 6011000990139424
     *          Diners Club 30569309025904
     *          Diners Club 38520000023237
     *          JCB 3530111333300000
     *          JCB 3566002020360505
     * @testing Fails 4000000000000341 (passes checks, but can't be charged)
     *          Fails 4000000000000002
     *          Fails 4000000000000119
     *          Fails 4000000000000101 (cvc)
     *          Fails 4000000000000127 (cvc)
     *          Fails 4000000000000036 (zip code)
     * @extends AppFormView
     */
    window.CreditCardAppFormView = AppFormView.extend({

        /**
         * _acceptable
         * 
         * @access  protected
         * @var     Array
         */
        _acceptable: [
            'Visa',
            'MasterCard',
            'American Express',
            'Discover Card',
            'Diners Club',
            'JCB'
        ],

        /**
         * _listeners
         * 
         * Overrides the FormView parent listeners to trigger the card handlers
         * before the 'native' ones
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="card/submit"]': function(event, $element) {
                        if (event.which === 13 || event.which === 32) {
                            event.preventDefault();
                            this.triggerHandler('card/submit');
                        }
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('card/submit');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                        this.triggerHandler('card/submit');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CreditCardAppFormView')
         */
        _string: 'CreditCardAppFormView',

        /**
         * _timeout
         * 
         * This is used for both the token posting and form posting.
         * 
         * @access  protected
         * @var     Number (default: 1250)
         */
        _timeout: 1250,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);

            // Stripe
            Scripts.load('stripe');
            this._setInputRestrictions();

            // Logic
            this.on({
                'card/submit': function(event) {
                    var _this = this;
                    App.getBusy().show();
                    Scripts.load('stripe', function() {
                        App.getBusy().hide();
                        _this._getStripeToken();
                    });
                },
                'card/returned': this.enable
            });

            // UI
            this.on({
                'card/submitted': function(event) {
                    this.clearErrors();
                    this.find('a.button').addClass('busy');
                    this.find('a.button').disable();
                },
                'card/returned/failed': function(event, error) {
                    this.find('a.button').removeClass('busy');
                    this.find('a.button').enable();
                    this.showError(error);
                },
                'card/returned/succeeded': function(event, response) {
                    this.find('input[name="data[token]"]').val(response.id);
                    this.triggerHandler('submit');
                },
                'returned/succeeded': function(event, response) {
                    this.find('[data-stripe]').val('');
                }
            });
        },

        /**
         * _setInputRestrictions
         * 
         * @access  protected
         * @return  void
         */
        _setInputRestrictions: function() {
            var $number = this.find('[data-stripe="number"]'),
                $cvc = this.find('[data-stripe="cvc"]'),
                $expiry = this.find('[data-stripe="expiry"]');
            $number.payment('formatCardNumber');
            $cvc.payment('formatCardCVC');
            $expiry.payment('formatCardExpiry');
        },

        /**
         * _getStripeToken
         * 
         * @access  protected
         * @return  void
         */
        _getStripeToken: function() {
            if (this._enabled === true) {
                this.disable();
                this.triggerHandler('card/submitted');
                var $number = this.find('[data-stripe="number"]'),
                    number = $number.val(),
                    $zip = this.find('[data-stripe="zip"]'),
                    zip = $zip.val(),
                    $name = this.find('[data-stripe="name"]'),
                    name = $name.val();
                if (this._supportedCreditCard(number) === false) {
                    var message = 'Please enter a ';
                    message += this._acceptable.join(', ');
                    message = message.replace(/, ([^,]+)$/, ' or $1') + ' ';
                    message += 'credit card number';
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned']
                    );
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned/failed', [{
                            message: message,
                            input: $number
                        }]]
                    );
                } else if (name === '') {
                    var message = 'Please enter the name as it appears on ' +
                        'the card';
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned']
                    );
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned/failed', [{
                            message: message,
                            input: $name
                        }]]
                    );
                } else if (zip === '') {
                    var message = 'Please enter the zip or postal code ' +
                        'associated with this card';
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned']
                    );
                    this.triggerHandler.delay(
                        this._timeout,
                        this,
                        ['card/returned/failed', [{
                            message: message,
                            input: $zip
                        }]]
                    );
                } else {
                    var $expiry = this.find('[data-stripe="expiry"]'),
                        expiry = $expiry.payment('cardExpiryVal'),
                        $cvc = this.find('[data-stripe="cvc"]'),
                        cvc = $cvc.val(),
                        $zip = this.find('[data-stripe="zip"]'),
                        zip = $zip.val(),
                        month = '',
                        year = '';
                    if (!isNaN(expiry.month)) {
                        month = expiry.month;
                    }
                    if (!isNaN(expiry.year)) {
                        year = expiry.year;
                    }
                    var _this = this;
                    Stripe.card.createToken({
                        number: number,
                        cvc: cvc,
                        exp_month: month,
                        exp_year: year,
                        name: name,
                        address_zip: zip
                    }, function(status, response) {
                        _this.triggerHandler.delay(
                            _this._timeout,
                            _this,
                            ['card/returned']
                        );
                        if (status === 200) {
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['card/returned/succeeded', [response]]
                            );
                        } else {
                            var error = _this.getStripeError(response);
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['card/returned/failed', [error]]
                            );
                        }
                    });
                }
            }
        },

        /**
         * getStripeError
         * 
         * @access  protected
         * @param   Object response
         * @return  Object
         */
        getStripeError: function(response) {
            var $number = this.find('[data-stripe="number"]'),
                $cvc = this.find('[data-stripe="cvc"]'),
                $zip = this.find('[data-stripe="zip"]'),
                $expiry = this.find('[data-stripe="expiry"]'),
                $input = $number;
            if (response.error.param === 'cvc') {
                $input = $cvc;
            } else if (response.error.param === 'address_zip') {
                $input = $zip;
            } else if (response.error.param === 'exp_month') {
                $input = $expiry;
            } else if (response.error.param === 'exp_year') {
                $input = $expiry;
            }
            return {
                message: response.error.message,
                input: $input
            };
        },

        /**
         * _supportedCreditCard
         * 
         * @access  protected
         * @param   String number
         * @return  Boolean
         */
        _supportedCreditCard: function(number) {
            var type = Stripe.card.cardType(number);
            if (ArrayUtils.contains(type, this._acceptable) === false) {
                return false;
            }
            return true;
        },

        /**
         * setAcceptableCards
         * 
         * @access  public
         * @param   Array cards
         * @return  void
         */
        setAcceptableCards: function(cards) {
            this._acceptable = cards;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FormView
     * 
     * @events  submit
     *          submitted
     *          returned
     *          returned/shit
     *          returned/failed
     *          returned/succeeded
     * @extends View
     */
    window.FormView = View.extend({

        /**
         * _enabled
         * 
         * @access  protected
         * @var     Boolean (default: true)
         */
        _enabled: true,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('submit');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FormView')
         */
        _string: 'FormView',

        /**
         * _timeout
         * 
         * @access  protected
         * @var     Number (default: 1500)
         */
        _timeout: 1500,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'submit': this._submit,
                'returned': this.enable
            });
        },

        /**
         * _submit
         * 
         * @note    I serialize the form object before disabling to ensure I can
         *          access any disabled inputs
         * @access  protected
         * @return  void
         */
        _submit: function() {
            if (this._enabled === true) {
                this.triggerHandler('submitted');
                if (this._enabled === true) {
                    var serialized = this._element.serializeObject(),
                        _this = this;
                    this.disable();
                    Stencil.ajax({
                        signature: {file: 'Form', line: 113},
                        url: this._element.attr('action'),
                        type: this._element.attr('method'),
                        data: function(csrf) {
                            serialized.csrf = csrf;
                            return serialized;
                        },
                        error: function(xhr, status, error) {
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['returned']
                            );
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['returned/shit']
                            );
                        },
                        success: function(response) {
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                ['returned']
                            );
                            var listener = 'returned/failed';
                            if (response.success === true) {
                                listener = 'returned/succeeded';
                            }
                            _this.triggerHandler.delay(
                                _this._timeout,
                                _this,
                                [listener, [response]]
                            );
                        }
                    });
                }
            }
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this._enabled = false;
            var selector = [
                // 'input[type="checkbox"]',
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).blur();
            this.find(selector).attr('readonly', true);
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            this._enabled = true;
            var selector = [
                // 'input[type="checkbox"]',
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).attr('readonly', false);
        },

        /**
         * setTimeout
         * 
         * @access  public
         * @param   Number milliseconds
         * @return  void
         */
        setTimeout: function(milliseconds) {
            this._timeout = milliseconds;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CancelAccountModalView
     * 
     * @extends ModalView
     */
    window.CancelAccountModalView = ModalView.extend({

        /**
         * _account
         * 
         * @access  protected
         * @var     AccountAccessor|null
         */
        _account: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CancelAccountModalView')
         */
        _string: 'CancelAccountModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AccountAccessor account
         * @return  void
         */
        init: function(element, account) {
            this._super(element);
            this._account = account;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var modal = Modals.get('Admin'),
                        section = modal.getSection('users'),
                        path = section.getPath();
                    Stencil.navigate(path);
                }
            });
            this.on({
                'later': function(event) {
                    var msg = Stencil.getMessage('admin.cancel.delay');
                    App.getBusy().show(msg);
                    var disapproveLastCommission = false,
                        $disapproveLastCommission = element.find(
                            '[name="disapproveLastCommission"]'
                        );
                    if ($disapproveLastCommission.length > 0) {
                        disapproveLastCommission = $disapproveLastCommission[0].checked;
                    }
                    this._account.cancel(
                        true,
                        disapproveLastCommission,
                        function(data) {
                            (function() {
                                location.reload();
                            }).delay(30 * 1000);
                        }
                    );
                    this.triggerHandler('leave');
                },
                'now': function(event) {
                    var msg = Stencil.getMessage('admin.cancel.delay');
                    App.getBusy().show(msg);
                    var disapproveLastCommission = false,
                        $disapproveLastCommission = element.find(
                            '[name="disapproveLastCommission"]'
                        );
                    if ($disapproveLastCommission.length > 0) {
                        disapproveLastCommission = $disapproveLastCommission[0].checked;
                    }
                    this._account.cancel(
                        false,
                        disapproveLastCommission,
                        function(data) {
                            (function() {
                                location.reload();
                            }).delay(30 * 1000);
                        }
                    );
                    this.triggerHandler('leave');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AdminModalView
     * 
     * @extends ModalView
     */
    window.AdminModalView = ModalView.extend({

        /**
         * _sections
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _sections: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AdminModalView')
         */
        _string: 'AdminModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCategories();
            this._setupCoupons();
            this._setupDashboard();
            this._setupImages();
            this._setupPromoSets();
            this._setupUsers();
            this.on({
                'categories/add': function(event) {
                    Stencil.navigate('/app/admin/categories/add');
                },
                'coupons/add': function(event) {
                    Stencil.navigate('/app/admin/coupons/add');
                },
                'promoSets/add': function(event) {
                    Stencil.navigate('/app/admin/promoSets/add');
                },
                'users/search': function(event) {
                    Stencil.navigate('/app/admin/users/search');
                }
            });
        },

        /**
         * _setupCategories
         * 
         * @access  protected
         * @return  void
         */
        _setupCategories: function() {
            var $categories = this.find('section.categories');
            this._sections.categories = new AdminCategoriesView(
                $categories,
                this
            );
        },

        /**
         * _setupCoupons
         * 
         * @access  protected
         * @return  void
         */
        _setupCoupons: function() {
            var $coupons = this.find('section.coupons');
            this._sections.coupons = new AdminCouponsView($coupons, this);
        },

        /**
         * _setupDashboard
         * 
         * @todo!   Do not have dashboard.html contain all links; have them be
         *          sent down from the server upon navigation.
         * @access  public
         * @return  void
         */
        _setupDashboard: function() {
            var $dashboard = this.find('section.dashboard');
            this._sections.dashboard = new AdminDashboardView($dashboard, this);
        },

        /**
         * _setupImages
         * 
         * @access  protected
         * @return  void
         */
        _setupImages: function() {
            var $images = this.find('section.images');
            this._sections.images = new AdminImagesView($images, this);
        },

        /**
         * _setupPromoSets
         * 
         * @access  protected
         * @return  void
         */
        _setupPromoSets: function() {
            var $promoSets = this.find('section.promoSets');
            this._sections.promoSets = new AdminPromoSetsView($promoSets, this);
        },

        /**
         * _setupUsers
         * 
         * @access  protected
         * @return  void
         */
        _setupUsers: function() {
            var $users = this.find('section.users');
            this._sections.users = new AdminUsersView($users, this);
        },

        /**
         * getSection
         * 
         * @access  public
         * @param   String section
         * @return  SectionView
         */
        getSection: function(section) {
            return this._sections[section];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AlertModalView
     * 
     * @extends ModalView
     */
    window.AlertModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AlertModalView')
         */
        _string: 'AlertModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Object settings
         * @return  void
         */
        init: function(element, settings) {
            this._super(element);
            this._settings = settings;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        },

        /**
         * getSettings
         * 
         * @access  public
         * @return  Object
         */
        getSettings: function() {
            return this._settings;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AssetsReimportModalView
     * 
     * @extends ModalView
     */
    window.AssetsReimportModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AssetsReimportModalView')
         */
        _string: 'AssetsReimportModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupForm();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/dashboard');
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on({
                'returned/succeeded': function(event, response) {
                    this.find('input').first().focus();
                    this.find('input').first().select();
                    StencilBooter.log(response.data);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AuthModalView
     * 
     * @extends ModalView
     */
    window.AuthModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _redirect
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _redirect: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AuthModalView')
         */
        _string: 'AuthModalView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   false|String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element);
            this._type = type;
            this._redirect = redirect;
            this._form = new AppFormView(this.find('form'));
        },

        /**
         * _flow
         * 
         * Manages the flow after a user is authenticated (either via a login or
         * signup redemption modal).
         * 
         * Worth noting: throughout auth flows (including in Promo.js and
         * Checkout.js), I always trigger the modal's leave-event, rather than
         * close, because it ensures that the user is sent back to the
         * location-path they were on before.
         * 
         * The exception to this is below: when a redirect parameter is
         * available, I simply close the modal (by triggering it's close-event).
         * This prevents an extra navigation event from happening, which is
         * useful since it prevents an unnecessary navigational-record, and
         * if the user landed directly in the app (eg. getstencil.com/checkout,
         * which redirects to login / signup before going on to the Checkout
         * modal), it prevents loading /app until _after_ they have been
         * authenticated and upgraded. Preventing /app from loading is
         * desirable, since that fires off a request for featured images, which
         * would result in using a bunch of bandwidth (and memory) when it is
         * not yet needed.
         * 
         * @access  public
         * @return  void
         */
        _flow: function() {
            if (this._type === 'curtain') {
                if (this._redirect === false) {
                    this._element.addClass('transition');
                    (function() {
                        App.getElement().removeClass('curtain');
                        this.triggerHandler('leave');
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/countdown?clean=1&onboard');
                        }
                    // }).delay(1800, this);
                    }).delay(0, this);
                } else {
                    // this.triggerHandler('leave');
                    this.triggerHandler('close');
                    var path = this._redirect;
                    // path += '?curtain';
                    Stencil.navigate(path);
                }
            } else {
                // this.triggerHandler('leave');
                if (this._redirect !== false) {
                    this.triggerHandler('close');
                    Stencil.navigate(this._redirect);
                } else {
                    this.triggerHandler('leave');
                    if (this._type === 'save') {
                        Footer.triggerHandler('save');
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/onboard?clean=1');
                        }
                    } else if (this._type === 'checkout') {
                        Stencil.navigate('/app/checkout/unlimited');
                    } else if (this._type === 'upgrade') {
                        // Stencil.navigate('/app/checkout/unlimited');
                        Stencil.navigate('/app/plans');
                    } else {
                        if (this._string === 'SignupModalView') {
                            Stencil.navigate('/app/countdown?clean=1&onboard');
                        } else {
                            Stencil.get('user').showLegacyWelcome();
                        }
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * BrowserModalView
     * 
     * @extends ModalView
     */
    window.BrowserModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BrowserModalView')
         */
        _string: 'BrowserModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * BusyModalView
     * 
     * @extends ModalView
     */
    window.BusyModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BusyModalView')
         */
        _string: 'BusyModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * show
         * 
         * @access  public
         * @param   undefined|false|String copy
         * @param   undefined|false|String exception
         * @return  void
         */
        show: function(copy, exception) {
            if (copy === undefined || copy === false) {
                this.find('div.copy').html('');
            } else {
                this.find('div.copy').html(copy);
            }
            if (exception === undefined || exception === false) {
                this.find('div.exception').html('');
            } else {
                this.find('div.exception').html(exception);
            }
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CacheRefreshModalView
     * 
     * @extends ModalView
     */
    window.CacheRefreshModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CacheRefreshModalView')
         */
        _string: 'CacheRefreshModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupForm();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/dashboard');
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on({
                'returned/succeeded': function(event, response) {
                    this.find('input').first().focus();
                    this.find('input').first().select();
                    StencilBooter.log(response.data);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AddCategoryModalView
     * 
     * @extends ModalView
     */
    window.AddCategoryModalView = ModalView.extend({

        /**
         * _adminModal
         * 
         * Reference to the open admin modal so that events can be paused on it
         * while an action is happening
         * 
         * @access  protected
         * @var     null|SettingsModalView (default: null)
         */
        _adminModal: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddCategoryModalView')
         */
        _string: 'AddCategoryModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element);
            this._adminModal = adminModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/categories');
                }
            });
            this._setupDropdowns();
            this._setupForm();
            this._setupTooltips();
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            this.find('select').selectpicker({
                dropupAuto: false
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this._adminModal.pause();
                    _this.pause();
                }
            });
            this._form.on({
                'returned': function(event) {
                    _this._adminModal.unpause();
                    _this.unpause();
                }
            });
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Category added');
                    var collection = _this._adminModal.getSection('categories')._collection;
                    collection.map(response.data.object, false);
                    Stencil.navigate('/app/admin/categories');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ApplyCategoriesModalView
     * 
     * @extends ModalView
     */
    window.ApplyCategoriesModalView = ModalView.extend({

        /**
         * _accessor
         * 
         * @access  protected
         * @var     null|Accessor (default: null)
         */
        _accessor: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ApplyCategoriesModalView')
         */
        _string: 'ApplyCategoriesModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Accessor accessor
         * @return  void
         */
        init: function(element, accessor) {
            this._super(element);
            this._accessor = accessor;
            this._setupCheckboxes();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
        },

        /**
         * _setupCheckboxes
         * 
         * @access  protected
         * @return  void
         */
        _setupCheckboxes: function() {
            var accessor = this._accessor,
                $checkboxes = this.find('input[type="checkbox"]');
            $checkboxes.on({
                'change': function(event) {
                    var key = $(this).attr('id'),
                        category = Stencil.getAccessor(key),
                        checked = $(this).is(':checked');
                    if (checked === true) {
                        if (accessor.get('class') === 'resource') {
                            Stencil.once({
                                'resource/feature/complete': function(event) {
                                    App.getBusy().hide();
                                }
                            });
                        } else {
                            accessor.once({
                                'feature/complete': function(event) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                        var msg = Stencil.getMessage('admin.categories.apply');
                        App.getBusy().show(msg);
                        accessor.feature(category);
                    } else {
                        accessor.unfeature(category);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CheckoutModalView
     * 
     * @todo    Add in a tooltip/question-mark icon for when a coupon is added,
     *          but the coupon does not apply to both intervals (monthly and
     *          annually). Something so that when they toggle away, they get
     *          messaging informing them why the coupon they might be expecting
     *          isn't showing up.
     * @extends ModalView
     */
    window.CheckoutModalView = ModalView.extend({

        /**
         * _coupon
         * 
         * @access  protected
         * @var     null|CouponAccessor (default: null)
         */
        _coupon: null,

        /**
         * _events
         * 
         * @access  protected
         * @var     Object
         */
        _events: {

            /**
             * detect
             * 
             * @access  private
             * @param   jQuery event
             * @param   jQuery $input
             * @return  void
             */
            detect: function(event, $input) {
                var $wrapper = this.find('div.cards'),
                    $imgs = $wrapper.find('img');
                if ($input.hasClass('identified') === true) {
                    $imgs.addClass('faded');
                    if ($input.hasClass('visa') === true) {
                        $wrapper.find('.visa').removeClass('faded');
                    } else if ($input.hasClass('mastercard') === true) {
                        $wrapper.find('.mastercard').removeClass('faded');
                    } else if ($input.hasClass('amex') === true) {
                        $wrapper.find('.amex').removeClass('faded');
                    } else {
                        $wrapper.find('.unknown').removeClass('faded');
                    }
                } else {
                    $imgs.removeClass('faded');
                }
            }
        },

        /**
         * _form
         * 
         * @access  protected
         * @var     null|CreditCardAppFormView (default: null)
         */
        _form: null,

        /**
         * _interval
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _interval: 'monthly',

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keyup: {
                    '[data-stripe="number"]': this._events.detect
                },
                click: {
                    '.toggler:not([disabled])': function(event, $toggler) {
                        event.preventDefault();
                        if ($toggler.hasClass('monthly')) {
                            Track.event('Checkout interval switch', {
                                _interval: 'annually'
                            });
                            this.interval('annually');
                        } else {
                            Track.event('Checkout interval switch', {
                                _interval: 'monthly'
                            });
                            this.interval('monthly');
                        }
                    }
                }
            });
        },

        /**
         * _plan
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _plan: null,

        /**
         * _promotions
         * 
         * @access  protected
         * @var     Array
         */
        _promotions: {
            monthly: {
                refund: {
                    icon: 'fa-certificate',
                    copy: '7-Day Money Back',
                    tooltip: 'Cancel any time within 7 days to get a full refund.'
                }
            },
            annually: {
                refund: {
                    icon: 'fa-certificate',
                    copy: '7-Day Money Back',
                    tooltip: 'Cancel any time within 7 days to get a full refund.'
                },
                auto: {
                    icon: 'fa-calendar',
                    copy: 'Yearly Discount ([rate]% off)'
                }
            }
        },

        /**
         * _rates
         * 
         * @access  protected
         * @var     Object
         */
        _rates: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CheckoutModalView')
         */
        _string: 'CheckoutModalView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String plan
         * @param   String type
         * @return  void
         */
        init: function(element, plan, type) {
            this._super(element);
            this._type = type;
            this._trackCheckoutView();

            // Get the rates
            var rates = Account.rates.raw();
            this._rates = {
                pro: {
                    monthly: {
                        account: rates.monthly.pro,
                        current: rates.monthly.pro
                    },
                    annually: {
                        account: rates.annually.pro,
                        current: rates.annually.pro
                    }
                },
                unlimited: {
                    monthly: {
                        account: rates.monthly.unlimited,
                        current: rates.monthly.unlimited
                    },
                    annually: {
                        account: rates.annually.unlimited,
                        current: rates.annually.unlimited
                    }
                }
            };

            // Plan + create card form
            this._plan = plan;
            this._form = new CreditCardAppFormView(this.find('form'));
            if (User.blockedFromCheckout() === true) {
                this._form.unbind('card/submit');
                this._form.on({
                    'card/submit': function(event) {
                        Stencil.alert('users.checkout.blocked');
                    }
                });
            }
            this._form.setTimeout(0);
            this._form.setAcceptableCards([
                'Visa',
                'MasterCard',
                'American Express'
            ]);

            // Pausing/unpausing
            this._form.on({
                'card/submitted': this.pause.proxy(this),
                'card/returned': this.unpause.proxy(this),
                'submitted': this.pause.proxy(this),
                'returned': this.unpause.proxy(this),
                'coupon/remove': this.removeCoupon.proxy(this)
            });

            // Success
            var _this = this;
            this._form.unbind('returned/failed');
            this._form.on({
                'returned/failed': function(event, response) {
                    if (response.error && response.error.code) {
                        Track.event('Checkout failed', {
                            _errorCode: response.error.code
                        });
                    }
                    this.find('a.button').enable();
                    if (response.failedRules) {
                        var error = this.getError(response);
                        this.showError(error);
                    } else {
                        this.showError(response.error);
                    }
                },
                'returned/succeeded': function(event, response) {
                    var accountData = response.data.account,
                        userData = response.data.user;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    Stencil.account().merge(accountData);
                    Stencil.get('user').merge(userData);
                    var stripe = response.data.checkout.stripe;
                    User.upgrade(stripe);
                    var path = Stencil.account().getUpgradedPath();
                    if (_this._type !== 'curtain') {
                        _this.triggerHandler('leave');
                        Stencil.navigate(path);
                    } else {
                        _this._element.addClass('transition');
                        (function() {
                            App.getElement().removeClass('curtain');
                            _this.triggerHandler('leave');
                            Stencil.navigate(path);
                        // }).delay(1800);
                        }).delay(0);
                    }
                }
            });

            // Calculate yearly discount rate
            var rate = (1 - (this._rates[this._plan].annually.account /
                (this._rates[this._plan].monthly.account * 12)
            )) * 100;
            this._promotions.annually.auto.copy = 'Yearly Discount (' +
                Math.round(rate) + '% off)';

            // Tooltips
            this._setupTooltips();

            // Let's do this
            this.interval('annually');

            // Clean up (because of how extend.js works, need to clear vars)
            this.removeCoupon();
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * _trackCheckoutView
         * 
         * @access  protected
         * @return  void
         */
        _trackCheckoutView: function() {
            var user = Stencil.get('user');
            user.push('hasSeenCheckout', 1);
        },

        /**
         * getPlan
         * 
         * @access  public
         * @return  String
         */
        getPlan: function() {
            return this._plan;
        },

        /**
         * getType
         * 
         * @access  public
         * @return  null|String
         */
        getType: function() {
            return this._type;
        },

        /**
         * interval
         * 
         * @access  public
         * @param   String interval
         * @return  void
         */
        interval: function(interval) {
            var $interval = this.find('input[name="data[interval]"]'),
                $coupon = this.find('input[name="data[coupon]"]');
            $interval.val(interval);
            $coupon.val('');
            this.find('.toggler').removeClass('monthly');
            this.find('.toggler').removeClass('annually');
            this.find('.toggler').addClass(interval);
            this._interval = interval;
            if (this._coupon) {
                if (this._coupon.get('interval') === 'both') {
                    $coupon.val(this._coupon.get('code'));
                } else {
                    if (this._coupon.get('interval') === interval) {
                        $coupon.val(this._coupon.get('code'));
                    }
                }
            }
            this.refresh();
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._super();
            this.find('div.toggler').disable();
            this.find('section.actions a').disable();
            this.find('section.actions').addClass('invisible');
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            this.update.button.apply(this);
            this.update.explanation.apply(this);
            this.update.promotions.apply(this);
            this.update.rate.after.apply(this);
            this.update.rate.before.apply(this);
        },

        /**
         * removeCoupon
         * 
         * @access  public
         * @return  void
         */
        removeCoupon: function() {
            var $coupon = this.find('input[name="data[coupon]"]');
            $coupon.val('');
            this.find('aside section.actions .add').removeClass('hidden');
            this.find('aside section.actions .remove').addClass('hidden');
            this._coupon = null;
            delete this._promotions.monthly.trial;
            delete this._promotions.annually.trial;
            delete this._promotions.monthly.discount;
            delete this._promotions.annually.discount;
            this._rates[this._plan].monthly.current = this._rates[this._plan].monthly.account;
            this._rates[this._plan].annually.current = this._rates[this._plan].annually.account;
            this.refresh();
        },

        /**
         * setCoupon
         * 
         * @access  public
         * @param   CouponAccessor coupon
         * @return  void
         */
        setCoupon: function(coupon) {

            // UI
            // this.find('[name="data[coupon]"]').val(coupon.get('key'));
            this.find('aside section.actions .add').addClass('hidden');
            this.find('aside section.actions .remove').removeClass('hidden');

            // Data
            this._coupon = coupon;
            this.find('input[name="data[coupon]"]').val(coupon.get('code'));

            // Interval
            if (this._coupon.get('interval') !== 'both') {
                this.interval(this._coupon.get('interval'));
            }

            // Trial
            var promotion;
            delete this._promotions.monthly.trial;
            delete this._promotions.annually.trial;
            if (this._coupon.get('trial').toInt() !== 0) {
                var days = this._coupon.get('trial');
                promotion = {
                    icon: 'fa-clock-o',
                    copy: (days) + ' Day Free Trial Applied',
                    tooltip: 'You will not be charged until your trial expires'
                };
                if (this._coupon.get('interval') === 'both') {
                    this._promotions.monthly.trial = promotion;
                    this._promotions.annually.trial = promotion;
                } else {
                    this._promotions[this._coupon.get('interval')].trial = promotion;
                }
            }

            // Discount
            delete this._promotions.monthly.discount;
            delete this._promotions.annually.discount;
            if (
                this._coupon.get('amount').toInt() !== 0
                || this._coupon.get('percentage').toInt() !== 0
            ) {
                // Cleanup
                promotion = {};

                // Amount
                if (this._coupon.get('amount').toInt() !== 0) {
                    if (this._coupon.get('frequency') === 'continuous') {
                        promotion = {
                            icon: 'fa-tag',
                            copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                ' Discount Applied'
                        };
                    } else {
                        if (this._coupon.get('duration').toInt() === 1) {
                            promotion = {
                                icon: 'fa-tag',
                                copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                    ' Discount Applied (for 1st [interval])'
                            };
                        } else {
                            promotion = {
                                icon: 'fa-tag',
                                copy: '$' + (this._coupon.get('amount').centsToDollars(true)) +
                                    ' Discount Applied (for first ' +
                                    (this._coupon.get('duration')) + ' [interval]s)'
                            };
                        }
                    }
                }
                // Percentage
                else {
                    if (this._coupon.get('frequency') === 'continuous') {
                        promotion = {
                            icon: 'fa-tag',
                            copy: (this._coupon.get('percentage')) +'% Discount ' +
                                'Applied'
                        };
                    } else {
                        if (this._coupon.get('duration').toInt() === 1) {
                            promotion = {
                                icon: 'fa-tag',
                                copy: (this._coupon.get('percentage')) +'% Discount ' +
                                    'Applied (for 1st [interval])'
                            };
                        } else {
                            promotion = {
                                icon: 'fa-tag',
                                copy: (this._coupon.get('percentage')) +'% Discount ' +
                                    'Applied (for first ' +
                                    (this._coupon.get('duration')) + ' [interval]s)'
                            };
                        }
                    }
                }

                // Let's do this
                if (this._coupon.get('interval') === 'both') {
                    this._promotions.monthly.discount = jQuery.extend({}, promotion);
                    this._promotions.monthly.discount.copy = this._promotions.monthly.discount.copy.replace(
                        '[interval]', 'month'
                    );
                    this._promotions.annually.discount = jQuery.extend({}, promotion);
                    this._promotions.annually.discount.copy = this._promotions.annually.discount.copy.replace(
                        '[interval]', 'year'
                    );
                } else {
                    var interval = this._coupon.get('interval');
                    this._promotions[interval].discount = jQuery.extend({}, promotion);
                    this._promotions[interval].discount.copy = this._promotions[interval].discount.copy.replace(
                        '[interval]',
                        (interval === 'monthly' ? 'month' : 'year')
                    );
                }

                // Discount data
                if (this._coupon.get('amount').toInt() !== 0) {
                    if (this._coupon.get('interval') === 'both') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account - this._coupon.get('amount'));
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account - this._coupon.get('amount'));
                    } else if (this._coupon.get('interval') === 'monthly') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account - this._coupon.get('amount'));
                    } else if (this._coupon.get('interval') === 'annually') {
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account - this._coupon.get('amount'));
                    }
                } else if (this._coupon.get('percentage').toInt() !== 0) {
                    var rate = 1 - (this._coupon.get('percentage').toInt() / 100);
                    if (this._coupon.get('interval') === 'both') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account * rate);
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account * rate);
                    } else if (this._coupon.get('interval') === 'monthly') {
                        this._rates[this._plan].monthly.current = (this._rates[this._plan].monthly.account * rate);
                    } else if (this._coupon.get('interval') === 'annually') {
                        this._rates[this._plan].annually.current = (this._rates[this._plan].annually.account * rate);
                    }
                }
            }


            // Refresh UI
            this.refresh();
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._super();
            this.find('div.toggler').enable();
            this.find('section.actions a').enable();
            this.find('section.actions').removeClass('invisible');
        },

        /**
         * update
         * 
         * @access  public
         * @var     Object
         */
        update: {

            /**
             * button
             * 
             * @access  public
             * @return  void
             */
            button: function() {
                var copy = 'Upgrade to PRO';
                if (this._plan === 'unlimited') {
                    copy = 'Upgrade to UNLIMITED';
                }
                if (
                    this._coupon
                    && this._coupon.get('trial')
                    && this._coupon.get('trial').toInt() !== 0
                ) {
                    if (
                        this._coupon.get('interval') === 'both'
                        || this._coupon.get('interval') === this._interval
                    ) {
                        copy = 'Start free trial';
                    }
                }
                this.find('a.button .copy').text(copy);
            },

            /**
             * explanation
             * 
             * @access  public
             * @return  void
             */
            explanation: function() {

                /**
                 * Amount
                 * 
                 */

                // Charge amount + interval
                var plan = this._plan,
                    amount = this._rates[this._plan][this._interval].current,
                    explanation = 'You\'ll be charged [$' +
                        (amount.centsToDollars(true)) + '] ';
                if (this._interval === 'monthly') {
                    explanation += '[/mo]';
                } else if (this._interval === 'annually') {
                    explanation += '[/yr]';
                }

                /**
                 * Conditions
                 * 
                 */
                if (this._coupon && this._coupon.get('key')) {
                    if (
                        this._coupon.get('frequency') === 'limited'
                        && (
                            this._coupon.get('interval') === 'both' ||
                            this._coupon.get('interval') === this._interval
                        )
                    ) {
                        var shorter = this._interval === 'monthly'
                                ? 'mo'
                                : 'yr',
                            longer = shorter === 'mo' ? 'month' : 'year';
                        if (this._coupon.get('duration').toInt() === 1) {
                            explanation += ' ';
                            explanation += '(for the 1st ' + (longer) + '; ' +
                                '$X /' + (shorter) + ' after that)';
                        } else {
                            explanation += ' ';
                            explanation += '(for the first ' +
                                (this._coupon.get('duration')) + ' ' + (longer) +
                                's; $X /' + (shorter) + ' after that)';
                        }

                        // Amount
                        explanation = explanation.replace(
                            '$X',
                            '$'  + (this._rates[this._plan][this._interval].account.centsToDollars(true))
                        );
                    }
                }

                /**
                 * Trial
                 * 
                 */

                // Trial
                var when;
                if (
                    this._coupon
                    && this._coupon.get('trial')
                    && this._coupon.get('trial').toInt() !== 0
                ) {
                    if (
                        this._coupon.get('interval') === 'both'
                        || this._coupon.get('interval') === this._interval
                    ) {
                        when = moment().add(this._coupon.get('trial'), 'days').format(
                            'MMMM Do, YYYY'
                        );
                        explanation += ' when your trial ends on [' + (when) + ']';
                    }
                }

                // Trailing period
                explanation += '[.]';

                /**
                 * Formatting
                 * 
                 */

                // Replacements
                explanation = explanation.replace(/\[/g, '<strong>');
                explanation = explanation.replace(/\]/g, '</strong>');

                /**
                 * DOM Update
                 * 
                 */

                // DOM
                this.find('div.explanation').html(explanation);
            },

            /**
             * promotions
             * 
             * @access  public
             * @return  void
             */
            promotions: function() {
                var _this = this;
                this._element.find('section.promotions').empty();
                jQuery.each(this._promotions[this._interval],
                    function(index, promotion) {
                        var $promotion = DataUtils.render('CheckoutPromotion', {
                            icon: promotion.icon,
                            copy: promotion.copy,
                            tooltip: promotion.tooltip || false
                        });
                        _this._element.find('section.promotions').append(
                            $promotion
                        );
                    }
                );
            },

            /**
             * rate
             * 
             * @access  public
             * @var     Object
             */
            rate: {

                /**
                 * after
                 * 
                 * @access  public
                 * @return  void
                 */
                after: function() {
                    var $before = this.find('section.pricing div.after'),
                        $dollar = $before.find('.dollar'),
                        $cents = $before.find('.cents'),
                        $interval = $before.find('.interval'),
                        interval = this._interval,
                        breakdown,
                        dollar,
                        cents;
                    if (interval === 'monthly') {
                        breakdown = this._rates[this._plan].monthly.current;
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    } else {
                        breakdown = Math.round(this._rates[this._plan].annually.current / 12);
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    }
                },

                /**
                 * before
                 * 
                 * @note    This should always show pricing relative to monthly
                 *          rates
                 * @access  public
                 * @return  void
                 */
                before: function() {
                    var plan = this._plan,
                        $before = this.find('section.pricing div.before'),
                        $dollar = $before.find('.dollar'),
                        $cents = $before.find('.cents'),
                        $interval = $before.find('.interval'),
                        interval = this._interval,
                        breakdown,
                        dollar,
                        cents;
                    if (
                        interval === 'monthly'
                        && this._rates[this._plan].monthly.account === this._rates[this._plan].monthly.current
                    ) {
                        $dollar.text('');
                        $cents.text('');
                        $interval.text('');
                    } else {
                        breakdown = this._rates[this._plan].monthly.account;
                        dollar = breakdown.centsToDollars().match(/(.+)\./).pop();
                        cents = breakdown.centsToDollars().match(/\.(.+)/).pop();
                        $dollar.text('$' + (dollar));
                        $cents.text(cents);
                        $interval.text('/mo');
                    }
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ChromeExtensionInstalledModalView
     * 
     * @extends ModalView
     */
    window.ChromeExtensionInstalledModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChromeExtensionInstalledModalView')
         */
        _string: 'ChromeExtensionInstalledModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ConfirmModalView', function() {

    /**
     * ClearCanvasConfirmModalView
     * 
     * @events  yes
     *          no
     * @extends ConfirmModalView
     */
    window.ClearCanvasConfirmModalView = ConfirmModalView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {
                    'input[type="checkbox"]:checked': function(event, $input) {
                        Stencil.account().userAccount().push(
                            'settings.canvasClearWatermarks',
                            '1'
                        );
                    },
                    'input[type="checkbox"]:not(:checked)': function(event, $input) {
                        Stencil.account().userAccount().push(
                            'settings.canvasClearWatermarks',
                            '0'
                        );
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ClearCanvasConfirmModalView')
         */
        _string: 'ClearCanvasConfirmModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * clearWatermarks
         * 
         * Returns whether any drawn Watermark layers should be cleared from the
         * canvas.
         * 
         * @access  public
         * @return  Boolean
         */
        clearWatermarks: function() {
            var key = 'canvasClearWatermarks';
            return Stencil.account().userAccount() !== undefined
                && Stencil.account().userAccount().setting(key).toInt() === 1;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CreateCollectionModalView
     * 
     * @events  save
     * @extends ModalView
     */
    window.CreateCollectionModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CreateCollectionModalView')
         */
        _string: 'CreateCollectionModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned/failed': function(event) {
                    _this.unpause();
                },
                'returned/shit': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    _this.triggerHandler('save', [response.data.object]);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ConfirmModalView
     * 
     * @events  yes
     *          no
     * @extends ModalView
     */
    window.ConfirmModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConfirmModalView')
         */
        _string: 'ConfirmModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ConfirmMobileModalView
     * 
     * @extends ModalView
     */
    window.ConfirmMobileModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConfirmMobileModalView')
         */
        _string: 'ConfirmMobileModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, shareModal, image) {
            this._super(element);
            this._shareModal = shareModal;
            this._setupForm();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = image.getSharePath('instagram');
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.unbind('returned/succeeded');
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned/failed': function(event) {
                    _this.unpause();
                },
                'returned/shit': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event) {
                    this.find('a.button').addClass('busy');
                    this.disable();
                    var network = _this._shareModal.getNetwork('instagram'),
                        form = network.getForm();
                    form.triggerHandler('submit');
                    form.once({
                        'returned/succeeded': function(event, response) {
                            var modal = Modals.get('ImageSent');
                            modal.find('h1.first').addClass('hidden');
                            modal.find('h1.second').removeClass('hidden');
                        }
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ConnectionsModalView
     * 
     * @extends ModalView
     */
    window.ConnectionsModalView = ModalView.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|Collection (default: null)
         */
        _collection: null,

        /**
         * _network
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _network: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ConnectionsModalView')
         */
        _string: 'ConnectionsModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String network
         * @return  void
         */
        init: function(element, network) {
            this._super(element);
            this._collection = Stencil.account().collection('connections');
            var _this = this;
            this._collection.on({
                'remove': function(event, accessor) {
                    _this.refresh();
                }
            });
            this._network = network;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/settings/social');
                }
            });
            this._drawConnections();
            if (UserAgent.supports.css.scrollbars() === false) {
                this._setupScrollbars();
            }
        },

        /**
         * _drawConnection
         * 
         * @access  protected
         * @param   ConnectionAccessor connection
         * @param   Number position
         * @return  void
         */
        _drawConnection: function(connection, position) {
            var $list = this.find('div.list');
                $connection = DataUtils.render('ConnectionRow', {
                    connection: connection
                });
            if (position === 0) {
                $list.prepend($connection);
            } else {
                $list.append($connection);
            }
            new ConnectionRowView($connection, connection);
        },

        /**
         * _drawConnections
         * 
         * @access  protected
         * @return  void
         */
        _drawConnections: function() {
            var _this = this,
                connections = this._collection.network(this._network);
            jQuery.each(connections, function(index, connection) {
                _this._drawConnection(connection, index);
            });
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
            // var resize = function() {
            //     $element.data('jsp').reinitialise();
            // };
            // $(window).resize(resize);
            // this.on({
            //     'destroy': function(event) {
            //         $(window).unbind('resize', resize);
            //     }
            // });
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbars: function() {
            var $list = this.find('div.list');
            this._makeScrollable($list);
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            if (UserAgent.supports.css.scrollbars() === false) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CookiesModalView
     * 
     * @extends ModalView
     */
    window.CookiesModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CookiesModalView')
         */
        _string: 'CookiesModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StickyModalView', function() {

    /**
     * CountdownModalView
     * 
     * @events  open/facebook/share
     * @extends StickyModalView
     */
    window.CountdownModalView = StickyModalView.extend({

        /**
         * _intervals
         * 
         * Keeps track of tweet/follow windows to prevent a bug whereby clicking
         * the tweet/follow link multiple times result in multiple intervals*
         * being created, which results in multiple callbacks firing (which,
         * resulted in 3, 6, 9, 12+ images being added as bonus to the user).
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _intervals: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CountdownModalView')
         */
        _string: 'CountdownModalView',

        /**
         * init
         * 
         * Width is set explicitly below when no <aside> tag can be found
         * because of issues with detecting the width of the modal. The modal
         * width can't be set since it's variable. But when that's the case, the
         * position method in the parent can't tell how wide the content is
         * _right_ after it's inserted into the DOM. Therefore I need to set it
         * explicitly.
         * 
         * @access  public
         * @param   jQuery element
         * @param   String direction
         * @param   jQuery $relative
         * @param   jQuery $highlight
         * @return  void
         */
        init: function(element, direction, $relative, $highlight) {
            if (element.find('aside').length === 0) {
                element.find('.content').first().css({
                    width: 335
                });
            }
            this._super(element, direction, $relative, $highlight);
            Scripts.load('facebook');
            this.on({
                'open/facebook/share': this._showFacebookShare,
                'open/tweet': this._showTweet,
                'open/follow': this._showFollow
            });
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
        },

        /**
         * _getFacebookShareObject
         * 
         * @note    Specifying source attribute below shows slimmer preview:
         *          https://i.imgur.com/Ujfytbm.png
         * @see     http://stackoverflow.com/questions/20798314/using-facebooks-api-to-post-a-video-using-the-feed-dialog-fails
         * @access  protected
         * @return  Object
         */
        _getFacebookShareObject: function() {
            var share = Config.get('shares')['countdown.facebook'];
            return {
                display: 'popup',
                method: 'feed',
                name: share.title,
                description: share.description,
                link: share.url,
                picture: share.picture
            };
        },

        /**
         * _getTweetUrl
         * 
         * @access  protected
         * @return  String
         */
        _getTweetUrl: function() {
            var share = Config.get('shares')['countdown.twitter'],
                url = share.url,
                text = encodeURIComponent(share.message);
            return 'https://twitter.com/intent/tweet' +
                '?url=' + (url) +
                '&via=' + (share.via) +
                '&text=' + (text);
        },

        /**
         * _getTwitterFollowUrl
         * 
         * @access  protected
         * @return  String
         */
        _getTwitterFollowUrl: function() {
            return 'https://twitter.com/intent/follow?screen_name=getstencil';
        },

        /**
         * _listenForWindowClose
         * 
         * @note    Chrome/Safari handle parent existence checks different
                    Chrome has it set to null; Safari has it set to undefined
         * @access  protected
         * @param   String type
         * @param   Object win
         * @param   Function callback
         * @return  void
         */
        _listenForWindowClose: function(type, win, callback) {
            if (this._intervals[type] !== undefined) {
                IntervalPool.clear(this._intervals[type]);
                delete this._intervals[type];
            }
            var check = function() {
                // var parent = win.parent;
                // var parent = win.opener;
                if (win.closed === true) {
                // if (parent === null || parent === undefined) {
                    IntervalPool.clear(this._intervals[type]);
                    delete this._intervals[type];
                    callback();
                }
            };
            this._intervals[type] = check.interval(500, this);
        },

        /**
         * _showFacebookShare
         * 
         * @access  protected
         * @return  void
         */
        _showFacebookShare: function() {
            if (Scripts.loaded('facebook') === false) {
                App.waitFor('facebook');
            } else {
                var _this = this;
                FB.ui(
                    this._getFacebookShareObject(),
                    function(response) {
                        if (response !== undefined) {
                            _this._successfulShare();
                        }
                    }
                );
            }
        },

        /**
         * _showFollow
         * 
         * @access  protected
         * @return  void
         */
        _showFollow: function() {
            var win = window.open(
                this._getTwitterFollowUrl(),
                'Follow',
                'width=552, height=522'
            );
            this._listenForWindowClose(
                'follow',
                win,
                this._successfulFollow.proxy(this)
            );
        },

        /**
         * _showTweet
         * 
         * @access  protected
         * @return  void
         */
        _showTweet: function() {
            var win = window.open(
                this._getTweetUrl(),
                'Tweet',
                'width=552, height=522'
            );
            this._listenForWindowClose(
                'tweet',
                win,
                this._successfulTweet.proxy(this)
            );
        },

        /**
         * _successfulFollow
         * 
         * @access  protected
         * @param   Object obj
         * @return  void
         */
        _successfulFollow: function(obj) {
            var account = Stencil.account();
            account.set({
                followBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['followBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        },

        /**
         * _successfulTweet
         * 
         * @access  protected
         * @param   Object obj
         * @return  void
         */
        _successfulTweet: function(obj) {
            var account = Stencil.account();
            account.set({
                tweetBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['tweetBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        },

        /**
         * _successfulShare
         * 
         * @access  protected
         * @return  void
         */
        _successfulShare: function() {
            var account = Stencil.account();
            account.set({
                shareBonus: 1,
                bonusImages: account.get('bonusImages').toInt() + 3
            });
            account.save(['shareBonus', 'bonusImages']);
            this.triggerHandler('close');
            Stencil.navigate('/app/countdown?clean=1');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AddCouponModalView
     * 
     * @extends ModalView
     */
    window.AddCouponModalView = ModalView.extend({

        /**
         * _adminModal
         * 
         * Reference to the open admin modal so that events can be paused on it
         * while an action is happening
         * 
         * @access  protected
         * @var     null|AdminModalView (default: null)
         */
        _adminModal: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddCouponModalView')
         */
        _string: 'AddCouponModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element);
            this._adminModal = adminModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/coupons');
                }
            });
            this._setupDropdowns();
            this._setupForm();
            this._setupDatetimePicker();
            this._setupTooltips();
        },

        /**
         * _format
         * 
         * @access  protected
         * @return  void
         */
        _format: function() {

            // Format code
            this.find('[name="data[code]"]').val(
                this.find('[name="data[code]"]').val().toUpperCase()
            );

            // Format expiry
            var $expiry = this.find('#expiry'),
                expiry = $expiry.val(),
                mo = moment(expiry, 'MM/DD/YYYY h:mm A');
            this.find('[name="data[expiry]"]').val(
                mo.format('X')
            );

            // Format discount
            var $discount = this.find('#discount'),
                discount = $discount.val(),
                $amount = this.find('[name="data[amount]"]'),
                $percentage = this.find('[name="data[percentage]"]');
            if (discount.indexOf('$') !== -1) {
                discount = discount.replace('$', '');
                discount = discount.toFloat() * 100;
                $amount.val(discount);
            } else if (discount.indexOf('%') !== -1) {
                discount = discount.replace('%', '').toFloat();
                $percentage.val(discount);
            }

            // Format duration
            var $frequency = this.find('[name="data[frequency]"]'),
                $duration = this.find('#duration');
            if ($frequency.val() === 'limited') {
                this.find('[name="data[duration]"]').val(
                    $duration.val()
                );
            }
        },

        /**
         * _setupDatetimePicker
         * 
         * @access  protected
         * @return  void
         */
        _setupDatetimePicker: function() {
            var current = new Date();
            current.setDate(current.getDate());
            this.find('#expiry').datetimepicker({
                // debug: true,
                format: 'MM/DD/YYYY h:mm A',
                minDate: current,
                // showTodayButton: true,
                showClose: true,
                showClear: true,
                icons: {
                    time: 'fa fa-clock-o',
                    date: 'fa fa-calendar',
                    up: 'fa fa-chevron-up',
                    down: 'fa fa-chevron-down',
                    previous: 'fa fa-chevron-left',
                    next: 'fa fa-chevron-right',
                    today: 'fa fa-calendar-check-o',
                    clear: 'fa fa-trash-o',
                    close: 'fa fa-close'
                }
            });
            this.find('#expiry').val('');
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            var _this = this;
            this.find('select').selectpicker({
                dropupAuto: false
            });
            this.find('select[name="data[frequency]"]').change(
                function(event) {
                    var val = $(this).val(),
                        $duration = _this.find('#duration'),
                        $field = $duration.closest('div.field');
                    $field.addClass('hidden');
                    if (val === 'limited') {
                        $field.removeClass('hidden');
                    }
                }
            );
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            var _this = this;
            this._form.on({
                'submitted': this._format.proxy(this),
            });
            this._form.on({
                'submitted': function(event) {
                    _this._adminModal.pause();
                    _this.pause();
                }
            });
            this._form.on({
                'returned': function(event) {
                    _this._adminModal.unpause();
                    _this.unpause();
                }
            });
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Coupon added');
                    var collection = _this._adminModal.getSection('coupons')._collection;
                    collection.map(response.data.object, false);
                    Stencil.navigate('/app/admin/coupons');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ApplyCouponModalView
     * 
     * @extends ModalView
     */
    window.ApplyCouponModalView = ModalView.extend({

        /**
         * _checkoutModal
         * 
         * @access  protected
         * @var     null|CheckoutModalView (default: null)
         */
        _checkoutModal: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ApplyCouponModalView')
         */
        _string: 'ApplyCouponModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   CheckoutModalView checkoutModal
         * @return  void
         */
        init: function(element, checkoutModal) {
            this._super(element);
            this._checkoutModal = checkoutModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = '/app/checkout/' + (checkoutModal.getPlan());
                    if (checkoutModal.getType() === 'curtain') {
                        path += '?curtain';
                    }
                    Stencil.navigate(path);
                }
            });
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this._checkoutModal.pause();
                    _this.pause();
                }
            });
            this._form.on({
                'returned': function(event) {
                    _this._checkoutModal.unpause();
                    _this.unpause();
                }
            });
            this._form.on({
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Coupon'),
                        coupon = model.setAccessor(response.data.coupon);
                    Track.event('Coupon applied');
                    _this._checkoutModal.setCoupon(coupon);
                    this.find('input[name="data[code]"]').attr('readonly', true);
                    _this.triggerHandler.delay(1000, _this, ['leave']);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * CropperModalView
     * 
     * @see     https://github.com/fengyuanchen/cropperjs
     * @see     https://fengyuanchen.github.io/cropperjs/
     * @see     http://cloudinary.com/documentation/image_transformations
     * @extends ModalView
     */
    window.CropperModalView = ModalView.extend({

        /**
         * _cropper
         * 
         * @access  protected
         * @var     false|Cropper (default: false)
         */
        _cropper: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CropperModalView')
         */
        _string: 'CropperModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Layer layer
         * @return  void
         */
        init: function(element, layer) {
            this._super(element);
            this.unbind('leave');
            this._layer = layer;
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            // this._addEscapeEvent();
            this._addLeaveEvent();
            this._addInputRangeScaleEvents();
            this._addIconScaleEvents();
            this._addCropEvent();
            this._addDownloadEvent();
            this._setupCropper();
            this._setupInputRangeTooltip();
            this._setupTooltips();
        },

        /**
         * _addEscapeEvent
         * 
         * @access  protected
         * @return  void
         */
        _addEscapeEvent: function() {
            var _this = this,
                callback = function(event) {
                    if (
                        event.which === 27
                        && Stencil.get('ignoreMouseDownLayerBlur') !== true
                        && _this._element.hasClass('open') === true
                    ) {
                        event.preventDefault();
                        _this.close();
                        // $(this).unbind(event);
                    }
                };
            App.getElement().on({
                'keydown': callback
            });
            this.once({
                'close': function(event) {
                    App.getElement().unbind('keydown', callback);
                }
            });
        },

        /**
         * _addCropEvent
         * 
         * @access  protected
         * @return  void
         */
        _addCropEvent: function() {
            this.on({
                'crop': function(event) {
                    var data = this._cropper.getData(),
                        msg = Stencil.getMessage('app.crop.cropping'),
                        positioning = {
                            scaleX: (data.scaleX).round(2),
                            x: (data.x).round(0),
                            y: (data.y).round(0),
                            width: (data.width).round(0),
                            height: (data.height).round(0)
                        },
                        key = this._getImageKey();
                    // this.triggerHandler('leave');
                    // App.getBusy().show(msg);
console.log(positioning);
// https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/w_800/s3.local/upldbe02baf8
                    window.open(
                        'https://dx5683gi1tv0w.cloudfront.net' +
                        '/dtrjyhj9q' +
                        '/image' +
                        '/upload' +
                        '/w_800' +
                        '/w_' + (positioning.scaleX) + ',c_scale' +
                        '/x_' + (positioning.x) + ',y_' + (positioning.y) + ',w_' + (positioning.width) + ',h_' + (positioning.height) + ',c_crop' +
                        '/s3.local' +
                        // '/s3.dev' +
                        '/' + (key)
                    );
                }
            });
        },

        /**
         * _addDownloadEvent
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadEvent: function() {
            this.on({
                'download': function(event) {
                    var data = this._cropper.getData(),
                        positioning = {
                            scaleX: (data.scaleX).round(2),
                            x: (data.x).round(0),
                            y: (data.y).round(0),
                            width: (data.width).round(0),
                            height: (data.height).round(0)
                        },
                        key = this._getImageKey(),
                        url = 'https://dx5683gi1tv0w.cloudfront.net' +
                            '/dtrjyhj9q' +
                            '/image' +
                            '/upload' +
                            '/w_800' +
                            '/w_1.00,c_scale' +
                            '/x_' + (positioning.x) + ',y_' + (positioning.y) + ',w_' + (positioning.width) + ',h_' + (positioning.height) + ',c_crop' +
                            '/fl_attachment' +
                            '/s3.local' +
                            // '/s3.dev' +
                            '/' + (key);
                    window.location.href = url;
                }
            });
        },

        /**
         * _addLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _addLeaveEvent: function() {
            this.on({
                'leave': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                }
            });
            Stencil.set('ignoreMouseDownLayerBlur', true);
        },

        /**
         * _addInputRangeScaleEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInputRangeScaleEvents: function() {
            var _this = this,
                $range = this.find('input[type="range"]'),
                listener = function(event) {
                    var value = $(this).val().toFloat();
                    _this._cropper.scale(value);
                    _this.positionTooltip();
                };
            if (UserAgent.is.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _addIconScaleEvents
         * 
         * @access  protected
         * @return  void
         */
        _addIconScaleEvents: function() {
            var _this = this,
                $range = this.find('input[type="range"]'),
                minValue = $range.attr('min').toFloat(),
                maxValue = $range.attr('max').toFloat();
            this.find('div.icon.decrease').on({
                'click': function(event) {
                    var value = $range.val().toFloat();
                    if (value > minValue) {
                        var newValue = Math.max(minValue, value - 0.05);
                        $range.val(newValue);
                        _this._cropper.scale(newValue);
                        _this.positionTooltip();
                    }
                }
            });
            this.find('div.icon.increase').on({
                'click': function(event) {
                    var value = $range.val().toFloat();
                    if (value < maxValue) {
                        var newValue = Math.min(maxValue, value + 0.05);
                        $range.val(newValue);
                        _this._cropper.scale(newValue);
                        _this.positionTooltip();
                    }
                }
            })
        },

        /**
         * _getImageKey
         * 
         * @access  protected
         * @return  String
         */
        _getImageKey: function() {
            return this._layer.getAccessor().get('key');
        },

        /**
         * _setupCropper
         * 
         * @access  protected
         * @return  void
         */
        _setupCropper: function() {
            var $img = this.find('img');
            this._cropper = new Cropper(
                $img[0],
                {
                    toggleDragModeOnDblclick: false,
                    autoCropArea: 0.6,
                    dragMode: 'move',
                    viewMode: 3,
                    guides: false,
                    zoomable: true,
                    zoomOnTouch: false,
                    zoomOnWheel: false,
                    wheelZoomRatio: false,
                    modal: true,
                    minCropBoxWidth: 80,
                    minCropBoxHeight: 80
                }
            );
            var _this = this;
            $img[0].addEventListener('crop', function(event) {
                _this.find('input[name="width"]').val(event.detail.width.round(0));
                _this.find('input[name="height"]').val(event.detail.height.round(0));
            });
        },

        /**
         * _setupInputRangeTooltip
         * 
         * @access  protected
         * @return  void
         */
        _setupInputRangeTooltip: function() {
            var $range = this.find('input[type="range"]');
            $range.after('' +
                '<div class="tooltip bottom" lookup="tooltip/scale">' +
                    '<div class="tooltip-arrow"></div>' +
                    '<div class="tooltip-inner">100%</div>' +
                '</div>');
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * positionTooltip
         * 
         * @access  public
         * @return  void
         */
        positionTooltip: function() {
            var $range = this.find('input[type="range"]'),
                $tooltip = $range.siblings('.tooltip');
            if ($tooltip.length > 0) {
                var value = $range.val().toFloat(),
                    uiValue = (value * 100).round(0) + '%';
                $tooltip.find('.tooltip-inner').text(uiValue);
                var max = $range.attr('max').toFloat(),
                    min = $range.attr('min').toFloat(),
                    paddingLeft = $range.parent().css('padding-left').toFloat(),
                    rangeWidth = $range.css('width').toFloat(),
                    tooltipWidth = $tooltip.css('width').toFloat(),
                    thumbWidth = 16,
                    left = 0;
                left = left + paddingLeft;
                left = left - (tooltipWidth / 2);
                left = left + (thumbWidth / 2);
                left = left + (rangeWidth - thumbWidth) * ((value - min) / (max - min));
                $tooltip.css({
                    left: left.round(0) + ('px')
                });
            }
        },

        /**
         * preload
         * 
         * @access  public
         * @return  void
         */
        preload: function() {
            var _this = this,
                key = this._getImageKey(),
                src = 'https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/w_800/s3.local/' + (key),
                // src = 'https://dx5683gi1tv0w.cloudfront.net/dtrjyhj9q/image/upload/w_800/s3.dev/' + (key),
                image = new Image();
            image.onload = function() {
                _this.triggerHandler('preload');
            };
            image.src = src;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * DelinquentModalView
     * 
     * @extends ModalView
     */
    window.DelinquentModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DelinquentModalView')
         */
        _string: 'DelinquentModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * DownloadModalView
     * 
     * @see     https://github.com/eligrey/FileSaver.js/
     * @see     http://stackoverflow.com/questions/13752984/html5-file-api-downloading-file-from-server-and-saving-it-in-sandbox
     * @see     http://stackoverflow.com/questions/8126623/downloading-canvas-element-to-an-image
     * @see     http://jsfiddle.net/AbdiasSoftware/7PRNN/
     * @extends ModalView
     */
    window.DownloadModalView = ModalView.extend({

        /**
         * _forceRemoteDownload
         * 
         * @access  protected
         * @var     null|Boolean (default: null)
         */
        _forceRemoteDownload: null,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="radio"][name="data[mime]"]': function(event, $input) {
                        var $filename = this.find('[name="data[filename]"]'),
                            value = $filename.val().trim(),
                            mime = this._getMime(),
                            extension = mime === 'image/png' ? 'png' : 'jpg',
                            cleaned = value.replace(/\.[a-z]{3,4}$/i, '.' + extension);
                        $filename.val(cleaned);
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input': function(event, $input) {
                        if (event.which === 13) {
                            event.preventDefault();
                            this.triggerHandler('download');
                        }
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _delays
         * 
         * @access  protected
         * @var     Object
         */
        _delays: {

            /**
             * The duration in milliseconds to wait before triggering the
             * canvas export, to allow for the button transition to complete
             * properly.
             * 
             * This number should be greater than the button animation duration
             * (defined in buttons.scss), because in the browser, triggering
             * a canvas export is a data and memory heavy operation, causing
             * the css to freeze. So just wait a reasonable amount of time
             * before doing so.
             */
            animation: 175,

            /**
             * The duration in milliseconds to wait (at a minimum) before
             * pushing an exported file to the user. This is because sometimes
             * the canvas export is so fast (eg. 150ms) that it feels
             * disjointed, in that they click the button and while the button UI
             * changes to communication something, it stops right away and the
             * modal is hidden. This just ensures a minimum time so it doesn't
             * feel like things are jumping around.
             */
            download: 1500
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DownloadModalView')
         */
        _string: 'DownloadModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor image
         * @param   Boolean forceRemoteDownload used to allow previously saved
         *          images (eg. not the draft) to have options defined before the
         *          download begins.
         * @return  void
         */
        init: function(element, image, forceRemoteDownload) {
            this._super(element);
            this._image = image;
            this._forceRemoteDownload = forceRemoteDownload;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.on({
                'close': function(event) {
                    if (UserAgent.is.electron() === true) {
                        var key = 'clients.electron.images.download.single.complete';
                        Stencil.alert(key);
                    }
                }
            });
            this._setupDownload();
            this._setupTooltips();
        },

        /**
         * _disable
         * 
         * @access  protected
         * @return  void
         */
        _disable: function() {
            this.pause();
            var selector = [
                'input[type="tel"]',
                'input[type="email"]',
                'input[type="password"]',
                'input[type="text"]',
                'select',
                'textarea'
            ].join(',');
            this.find(selector).blur();
            this.find(selector).attr('readonly', true);
            this.find('a.button').addClass('busy').disable();
        },

        /**
         * _enable
         * 
         * @access  protected
         * @return  void
         */
        _enable: function() {
            this.unpause();
            this.find('a.button').removeClass('busy').enable();
        },

        /**
         * _getFilename
         * 
         * @access  protected
         * @return  String
         */
        _getFilename: function() {
            var $filename = this.find('[name="data[filename]"]'),
                filename = $filename.val().trim(),
                $mime = this.find('[name="data[mime]"]:checked'),
                mime = $mime.val();
            if (mime === 'image/png') {
                if (filename === '') {
                    var filename = Stencil.account().draft().getDefaultFilename();
                    return filename.replace(/\.jpg$/, '.png');
                }
                if (filename.match(/\.png$/) === null) {
                    return (filename).replace(/\.jpg$/, '') + '.png';
                }
                return filename;
            }
            if (filename === '') {
                var filename = Stencil.account().draft().getDefaultFilename();
                return filename.replace(/\.png$/, '.jpg');
            }
            if (filename.match(/\.jpg$/) === null) {
                return (filename).replace(/\.png$/, '') + '.jpg';
            }
            return filename;
        },

        /**
         * _getMediaType
         * 
         * @access  protected
         * @return  String
         */
        _getMediaType: function() {
            return this.find('[name="data[mediaType]"]:checked').val();
        },

        /**
         * _getMime
         * 
         * @access  protected
         * @return  String
         */
        _getMime: function() {
            return this.find('[name="data[mime]"]:checked').val();
        },

        /**
         * _getMultiplier
         * 
         * @access  protected
         * @return  String
         */
        _getMultiplier: function() {
            return this.find('[name="data[multiplier]"]:checked').val();
        },

        /**
         * _localDownloadAction
         * 
         * @access  protected
         * @return  void
         */
        _localDownloadAction: function() {
            var filename = this._getFilename(),
                mime = this._getMime(),
                recommendedExportMime = Stencil.account().draft().getRecommendedExportMime(),
                multiplier = this._getMultiplier(),
                check = Footer.validate.changedCanvas.apply(Footer),
                _this = this;

            /**
             * If the canvas contents have changed from the ImageAccessor that's
             * been loaded into the account draft, then ensure a traditional
             * save action goes on.
             */
            if (check.valid === true) {
                this._disable();
                var start = new Date();
                (function() {
                    Footer.save('download', false, function(image, dataURL) {

                        /**
                         * Now that the save has been initiated (but not yet
                         * fully completed), check if the multipler is 2x. This
                         * is because the dataURL that comes into this callback
                         * is by default the 2x version. So if they match, go
                         * ahead and push the dataURL to the browser right away.
                         */
                        if (multiplier === '2x') {
                            if (mime !== recommendedExportMime) {
                                DataUtils.convertDataUrlMime(
                                    dataURL,
                                    mime,
                                    function(dataURL) {
                                        var blob = DataUtils.dataUrlToBlob(dataURL);
                                        saveAs(blob, filename);
                                        _this.triggerHandler('close');
                                    }
                                );
                            } else {
                                var blob = DataUtils.dataUrlToBlob(dataURL);
                                saveAs(blob, filename);
                                _this.triggerHandler('close');
                            }
                        }
                        /**
                         * Otherwise, the user is trying to download the 1x
                         * version. So in that case, I take the dataURL, and
                         * route it through a resize helper function, and then
                         * push that to the browser.
                         */
                        else {
                            var width = Frame.get('width').toInt(),
                                height = Frame.get('height').toInt();
                            DataUtils.resizeDataUrl(
                                dataURL,
                                width,
                                height,
                                mime,
                                function(dataURL) {
                                    var blob = DataUtils.dataUrlToBlob(dataURL);
                                    saveAs(blob, filename);
                                    _this.triggerHandler('close');
                                }
                            );
                        }
                    });
                }).minDelay(start, this._delays.download);
            }
            /**
             * This is the case whereby the canvas contents are *not* different
             * from the account's draft (known by checking the JSON). In this
             * case, the image raw data either:
             * 1) Is currently being saved, specifically in the case of users
             *    who are Free or Pro, and need to click "Save" before the
             *    "Download" button becomes accessible.
             * 2) Is already stored in an S3 resource
             */
            else {
                var check = false;
                if (Canvases.Ghost.getImage() !== null) {
                    var json = {
                            draft: Stencil.account().draft().json(),
                            ghost: Canvases.Ghost.getImage().json()
                        };
                    check = JSON.stringify(json.draft) === JSON.stringify(json.ghost);
                }

                /**
                 * This is the case where the account draft and ghost canvas
                 * contents match. This happens when:
                 * 1) A save action was initiated *before* a download action,
                 */
                if (check === true) {
                    this._disable();
                    var start = new Date();
                    (function() {
                        if (Canvases.Ghost.get('saving') === true) {
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, exportedMime) {
                                    if (multiplier === '2x') {
                                        if (mime !== recommendedExportMime) {
                                            DataUtils.convertDataUrlMime(
                                                dataURL,
                                                mime,
                                                function(dataURL) {
                                                    var blob = DataUtils.dataUrlToBlob(dataURL);
                                                    saveAs(blob, filename);
                                                    _this.triggerHandler('close');
                                                }
                                            );
                                        } else {
                                            var blob = DataUtils.dataUrlToBlob(dataURL);
                                            saveAs(blob, filename);
                                            _this.triggerHandler('close');
                                        }
                                    } else {
                                        var width = Frame.get('width').toInt(),
                                            height = Frame.get('height').toInt();
                                        DataUtils.resizeDataUrl(
                                            dataURL,
                                            width,
                                            height,
                                            mime,
                                            function(dataURL) {
                                                var blob = DataUtils.dataUrlToBlob(dataURL);
                                                saveAs(blob, filename);
                                                _this.triggerHandler('close');
                                            }
                                        );
                                    }
                                }
                            });
                        } else {
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, mime) {
                                    var blob = DataUtils.dataUrlToBlob(dataURL);
                                    saveAs(blob, filename);
                                    _this.triggerHandler('close');
                                }
                            });
                            Canvases.Ghost.export(mime, multiplier === '2x');
                        }
                    }).minDelay(start, this._delays.download);
                }
                /**
                 * This is the case where the account draft and ghost canvas
                 * contents do not match. This happens when:
                 * 1) A previously saved image is loaded into the canvas, and as
                 *    a result, nothing is different from the previously saved
                 *    S3 resource.
                 * 2) The app is initially loaded and a previously saved image
                 *    is the draft (which means an S3 resource exists).
                 */
                else {
                    this._disable();
                    var start = new Date();
                    (function() {
                        var lastSavedImage = Footer.getLastSavedImage();
                        lastSavedImage.once({
                            'download': function(event) {
                                _this.triggerHandler('close');
                            }
                        });
                        lastSavedImage.download(
                            mime,
                            filename,
                            multiplier === '2x',
                            false,
                            false,
                            false
                        );
                    }).minDelay(start, this._delays.download);
                }
            }
        },

        /**
         * _remoteDownloadAction
         * 
         * @access  protected
         * @param   Object timeouts
         * @return  void
         */
        _remoteDownloadAction: function(timeouts) {
            var filename = this._getFilename(),
                mime = this._getMime(),
                multiplier = this._getMultiplier(),
                mediaType = this._getMediaType(),
                check = Footer.validate.changedCanvas.apply(Footer),
                _this = this;

            /**
             * If the canvas contents have changed from the ImageAccessor that's
             * been loaded into the account draft, then ensure a traditional
             * save action goes on.
             */
            var imageToCheckForProgress = this._image;
            if (check.valid === true) {
                this._disable();
                var start = new Date();
                (function() {
                    Footer.save('download', false, function(image, dataURL) {
                        image.once({
                            'download': function(event) {
                                _this.triggerHandler('close');
                            }
                        });
                        image.download(
                            mime,
                            filename,
                            multiplier === '2x',
                            false,
                            mediaType,
                            false
                        );
                    });
                }).minDelay(start, this._delays.download);
            } else {
                imageToCheckForProgress = Footer.getLastSavedImage();
                this._disable();
                var start = new Date();
                (function() {
                    var lastSavedImage = Footer.getLastSavedImage();
                    lastSavedImage.once({
                        'download': function(event) {
                            _this.triggerHandler('close');
                        }
                    });
                    lastSavedImage.download(
                        mime,
                        filename,
                        multiplier === '2x',
                        false,
                        mediaType,
                        false
                    );
                }).minDelay(start, this._delays.download);
            }

            // Success
            this._showPercentageUploadedState('preparing');
            var $percentage = this.find('span[lookup="percentage"]');
            imageToCheckForProgress.on({

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @return  void
                 */
                'upload/success': function(event, response, responseObject) {
                    _this._showPercentageUploadedState('starting');
                },

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   Number loaded
                 * @param   Number total
                 * @return  void
                 */
                'upload/progress': function(event, loaded, total) {
                    TimeoutPool.clear(timeouts.escape);
                    TimeoutPool.clear(timeouts.reporting);
                    timeouts = _this._setupDownloadFreezeLogic();
                    var percentage = Math.round(
                        (loaded / total) * 100
                    );
                    if (percentage > 2) {
                        _this._showPercentageUploadedState('processing');
                        $percentage.text(percentage);
                    }
                }
            });
        },

        /**
         * _setupDownload
         * 
         * @access  protected
         * @return  void
         */
        _setupDownload: function() {
            this.on({
                'download': function(event) {

                    // Flow for download
                    var timeouts = this._setupDownloadFreezeLogic();
                    if (UserAgent.supports.adownload() === false) {
                        this._remoteDownloadAction(timeouts);
                    } else {
                        if (this._getMediaType() === 'print') {
                            this._remoteDownloadAction(timeouts);
                        } else {
                            if (this._forceRemoteDownload === true) {
                                this._remoteDownloadAction(timeouts);
                            } else {
                                this._localDownloadAction();
                            }
                        }
                    }
                }
            });
        },

        /**
         * _setupDownloadFreezeLogic
         * 
         * @access  protected
         * @return  Object
         */
        _setupDownloadFreezeLogic: function() {

            // Logging potential errors
            var form = this.find('form').first(),
                timeouts = {
                    escape: (function() {
                        Stencil.alert('download.bug');
                        Stencil.kill.delay(0);
                    }).delay(75 * 1000),
                    reporting: (function() {
                        var msg = {
                            form: form.serializeObject(),
                            raw: {
                                images: {
                                    draft: Stencil.account().draft().data(),
                                    lastSavedImage: Footer.getLastSavedImage() === false ? false : Footer.getLastSavedImage().data()
                                }
                            }
                        };
                        Stencil.report('Long download duration', msg);
                        if ('Raven.captureMessage'.validMethod() === true) {
                            Raven.captureMessage('Long download duration', {
                                extra: {
                                    msg: msg
                                }
                            });
                        }
                    }).delay(60 * 1000)
                    // }).delay(500)
                };
            this.on({
                'close': function(event) {
                    TimeoutPool.clear(timeouts.reporting);
                    TimeoutPool.clear(timeouts.escape);
                }
            });
            return timeouts;
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: App.getElement(),
                placement: 'bottom'
            });
        },

        /**
         * _showPercentageUploadedState
         * 
         * @access  protected
         * @param   String state
         * @return  void
         */
        _showPercentageUploadedState: function(state) {
            var $button = this.find('a.button');
            $button.removeClass('busy')
            $button.addClass('remote');
            $button.removeClass('preparing');
            $button.removeClass('processing');
            $button.removeClass('starting');
            $button.addClass(state);
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function(copy) {
            this._super();
            var $input = this.find('input[type="text"]').first();
            (function() {
                $input.select();
            }).delay(0);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * DropModalView
     * 
     * @extends ModalView
     */
    window.DropModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'DropModalView')
         */
        _string: 'DropModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addDragListeners();
        },

        /**
         * _addDragListeners
         * 
         * @access  protected
         * @return  void
         */
        _addDragListeners: function() {
            var _this = this,
                $element = this._element;
            $element.listenForFileAndTabDrag();
            $element.on({
                'custom/drag/leave': function(event) {
                    _this.hide();
                },
                'custom/drag/drop/files': function(event, files) {
                    _this._processFileDrag(files);
                },
                'custom/drag/drop/tab': function(event, imageUrl) {
                    _this._processTabDrag(imageUrl);
                }
            });
        },

        /**
         * _hideCopy
         * 
         * @access  protected
         * @return  void
         */
        _hideCopy: function() {
            var $copy = this._element.find('div.copy span');
            $copy.addClass('invisible');
        },

        /**
         * _processFileDrag
         * 
         * @access  protected
         * @param   Array files
         * @return  void
         */
        _processFileDrag: function(files) {
            this._uploadFiles(files);
        },

        /**
         * _processTabDrag
         * 
         * This is a fun one :)
         * 
         * This method processes a drop from another browser tab/window. It
         * allows for either an image url (eg. http://domain.com/image.png) to
         * be received (and via the /utils/proxy endpoint, have it's content
         * retrieved), or an image data uri (eg. data:image/png;base64,...).
         * 
         * The 4096 character length is checked because it's a safe enough bet
         * that if it's greater than that length, it's not an image url (rather
         * an image data uri). However it's possible that if the length is
         * _smaller_ than that, it may still be an image data uri (eg. a really
         * small image). So in that case, I use the StringUtils method to check
         * whether the string is a valid url.
         * 
         * The reason I don't do that test right away is because I don't want
         * to run a regular expression against a (potentially) huge string if I
         * don't have to.
         * 
         * @access  protected
         * @param   String imageUrl
         * @return  void
         */
        _processTabDrag: function(imageUrl) {
            var callback = (function(blobs) {
                if (blobs !== false) {
                    this._uploadFiles(blobs);
                }
            }).proxy(this);
            if (imageUrl.length > 4096) {
                var blob = DataUtils.dataUrlToBlob(imageUrl);
                blob.name = 'unknown';
                callback([blob]);
            } else {
                if (StringUtils.url(imageUrl) === true) {
                    DataUtils.getUrlsAsBlobs([imageUrl], callback);
                } else {
                    var blob = DataUtils.dataUrlToBlob(imageUrl);
                    blob.name = 'unknown';
                    callback([blob]);
                }
            }
        },

        /**
         * _showCopy
         * 
         * @access  protected
         * @return  void
         */
        _showCopy: function() {
            if (App.getStage().fontsDropzoneVisible() === true) {
                this._element.find('div.copy span.fonts').removeClass('invisible');
            } else if (
                App.getEditor().getActiveArea() !== undefined
                && App.getEditor().getActiveArea().getType() === 'watermarks'
            ) {
                this._element.find('div.copy span.watermarks').removeClass('invisible');
            } else {
                this._element.find('div.copy span.images').removeClass('invisible');
            }
        },

        /**
         * _uploadFiles
         * 
         * @note    I believe the items.length check below is done because there
         *          was a case wherbey in an IE browser, multiple File objects
         *          were getting sent to this method, one of which was empty.
         *          And from what I can recall, the jQuery.makeArray method
         *          filtered those out, which in some cases, could result in
         *          items actually being empty. Thus, the check you see below.
         * @access  protected
         * @param   Array items
         * @return  Boolean
         */
        _uploadFiles: function(items) {
            if (items.length === undefined) {
                return false;
            }
            if (Services.check('aws') === false) {
                Stencil.alert('service.aws');
                return false;
            }
            var dropzone = App.getApplicableDropzone();
            if (dropzone.availableForUpload() === false) {
                return false;
            }
            items = jQuery.makeArray(items);
            if (items.length === 0) {
                return false;
            }
            if (dropzone.toString() === 'WatermarksDropzoneView') {
                Stencil.navigate('/app/logos');
            } else if (dropzone.toString() === 'DropzoneView') {
                Stencil.navigate('/app/uploads');
            }
            dropzone.receive(items);
            return true;
        },

        /**
         * show
         * 
         * @note    getActiveArea check is done incase the first path the user
         *          navigates to is in a modal (eg. /app/login).
         * @access  public
         * @return  void
         */
        show: function() {
            this._hideCopy();
            this._showCopy();
            this._super();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ErrorModalView
     * 
     * @extends ModalView
     */
    window.ErrorModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ErrorModalView')
         */
        _string: 'ErrorModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ExtrasModalView
     * 
     * @extends ModalView
     */
    window.ExtrasModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ExtrasModalView')
         */
        _string: 'ExtrasModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'install': function(event) {
                    if (UserAgent.extension() === true) {
                        Stencil.alert('extension.install.window');
                    } else if (UserAgent.supports.chromeWebstore() === false) {
                        Stencil.alert('extension.install.chrome');
                    } else {
                        this.install();
                    }
                }
            });
        },

        /**
         * install
         * 
         * @access  public
         * @return  Boolean
         */
        install: function() {
            var $link = $('link[rel="chrome-webstore-item"][class="extension"]');
            if ($link.length === 0) {
                return false;
            }
            if ('chrome.webstore.install'.validMethod() === false) {
                return false;
            }
            chrome.webstore.install(
                $link.attr('href'),
                function() {
                    Stencil.navigate('/app/extras/chrome/success');
                },
                function(message, code) {
                    console && console.log('Errored', message, code);
                    if (code === 'notPermitted') {

                    } else if (code === 'userCancelled') {

                    }
                }
            );
            return true;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * GoogleFontsModalView
     * 
     * @see     https://i.imgur.com/yaeZdcb.png
     * @extends ModalView
     */
    window.GoogleFontsModalView = ModalView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|ImagesCollection (default: null)
         */
        _collection: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        if (event.which === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            } else {
                                if (this._query !== '') {
                                    this.triggerHandler('clear');
                                }
                            }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="clear"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('clear');
                    }
                },
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input.search': function(event, $input) {
                        $input.parent().removeClass('queried');
                        $input.parent().removeClass('active');
                        if ($input.val().length > 0) {
                            $input.parent().addClass('active');
                        }

                        // Mark UI as queried if user types their way back
                        if ($input.val() === this._query) {
                            $input.parent().removeClass('active');
                            $input.parent().addClass('queried');
                        }
                    }
                },
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.googleFontRow': function(event, $div) {
                        $div.siblings().removeClass('hover');
                        $div.addClass('hover');
                    }
                },
                mouseleave: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.googleFontRow': function(event, $div) {
                        $div.removeClass('hover');
                    }
                }
            });
        },

        /**
         * _loaded
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loaded: false,

        /**
         * _loading
         * 
         * Whether or not any data is currently being loaded (used in infinite
         * scroll)
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _loading: false,

        /**
         * _more
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _more: false,

        /**
         * _query
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _query: '',

        /**
         * _scroll
         * 
         * @access  protected
         * @var     Object
         */
        _scroll: {

            /**
             * native
             * 
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            native: function(event) {
                var $inner = this._element.find('div.results > div.inner'),
                    bottom = ($inner.position().top + $inner.outerHeight(true) - $inner.parent().outerHeight()) <= this._threshold;
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load(false);
                        }
                    }
                }
            },

            /**
             * plugin
             * 
             * @note    It's important that the selector for $inner below does
             *          not look directly at the children of div.results since
             *          jScrollPane changes the relationship of the elements.
             * @access  private
             * @param   jQuery event
             * @param   Number y
             * @param   Boolean top
             * @param   Boolean bottom
             * @return  void
             */
            plugin: function(event, y, top, bottom) {
                var $inner = this._element.find('div.results div.inner');
                bottom = y > ($inner.outerHeight() - this._element.find('div.results').outerHeight() - this._threshold);
                if (bottom === true) {
                    if (this._more === true) {
                        if (this._loading === false) {
                            this.trackLoad();
                            this.load(false);
                        }
                    }
                }
            }
        },

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GoogleFontsModalView')
         */
        _string: 'GoogleFontsModalView',

        /**
         * _threshold
         * 
         * Number of pixels before the bottom of the scrollable area at which
         * point another load is triggered.
         * 
         * @access  protected
         * @var     Number (default: 200)
         */
        _threshold: 200,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupTooltips();
            this._addHoverEvents();
            this._setupCollection();
            this.on({
                'close': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                },
                'createFontPreviewImages': function(event, $anchor) {
                    this._createFontPreviewImages();
                },
                'leave': function(event) {
                    Stencil.set('ignoreMouseDownLayerBlur', false);
                }
            });
            this._setupScrollbar();
            this._addInfiniteScrollEvents();
            this._setupDropdowns();
            this._setupCheckboxes();
            this._setupSearch();
        },

        /**
         * _addHoverEvents
         * 
         * @access  protected
         * @return  void
         */
        _addHoverEvents: function() {
            this.find('div.results').scroll(function(event) {
                var element = document.elementFromPoint(App.getX(), App.getY()),
                    $element = $(element);
                if ($element.length > 0) {
                    $element.closest('.googleFontRow').trigger('mouseenter');
                }
            });
        },

        /**
         * _addInfiniteScrollEvents
         * 
         * @access  protected
         * @return  void
         */
        _addInfiniteScrollEvents: function() {
            var check = this._scroll.native.proxy(this),
                listener = 'scroll';
            if (this._$scrollbar !== null) {
                check = this._scroll.plugin.proxy(this);
                listener = 'jsp-scroll-y';
            }
            this.find('div.results').first().bind(listener, check);
        },

        /**
         * _createFontPreviewImages
         * 
         * @note    After running this method (via the local anchor link), a zip
         *          file will be pushed at you. Run the following commands from
         *          OSX (new terminal session):
cd ~/Downloads/ \
&& mkdir ~/Sites/getstencil.com/tmp-fonts/ \
&& mkdir ~/Sites/getstencil.com/tmp-fonts/compressed/ \
&& mkdir ~/Sites/getstencil.com/tmp-fonts/original/ \
&& unzip images.zip -d ~/Sites/getstencil.com/tmp-fonts/compressed/ \
&& unzip images.zip -d ~/Sites/getstencil.com/tmp-fonts/original/ \
&& rsc
         *
vm3
         *
cd /var/www/getstencil.com/tmp-fonts/compressed/ \
&& pngquant *.png -f --ext .png --quality=65-80 \
&& exit
         *
scp -r ubuntu@10.211.55.16:/var/www/getstencil.com/tmp-fonts/compressed/* ~/Sites/getstencil.com/TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages/48px/compressed/ \
&& scp -r ubuntu@10.211.55.16:/var/www/getstencil.com/tmp-fonts/original/* ~/Sites/getstencil.com/TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages/48px/original/ \
&& rm -rf ~/Sites/getstencil.com/tmp-fonts/ \
&& rsc
         *
cd ~/Sites/getstencil.com/TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages \
&& git add * \
&& git commit -m "New fonts" \
&& git push \
&& cd ~/Sites/getstencil.com/ \
&& git add TurtlePHP/application/webroot/app/static/vendors/submodules/GoogleWebFonts-FontFamilyPreviewImages \
&& git commit -m "New GoogleWebFonts submodule commit" \
&& git status

git checkout -- TurtlePHP/application/config/settings/defaults.inc.php \
TurtlePHP/application/controllers/GoogleFonts.class.php \
TurtlePHP/application/webroot/app/static/templates/modals/googleFonts.html
         * 
         * @see     https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
         * @access  protected
         * @return  void
         */
        _createFontPreviewImages: function() {
            var optimizeForRetina = true,
                drawCanvas = function(label, fontFamily) {
                    var canvas = document.createElement('canvas'),
                        context = canvas.getContext('2d'),
                        multiplier = optimizeForRetina === true ? window.devicePixelRatio : 1;
                    canvas.width = 800 * multiplier;
                    canvas.height = 300 * multiplier;
                    context.scale(multiplier, multiplier);
                    context.font = '48px "' + (fontFamily) + '"';
                    context.fillText(label, 10, 50);
                    return canvas;
                };
            var zip = new JSZip(),
                counter = 0,
                collection = this._collection;
            collection.each(function(index, googleFont) {
                if (googleFont.get('hasImage').toInt() === 0) {
                    googleFont.drawStyleSheet();

                    // Initiate the load
                    WebFont.load({
                        classes: false,
                        fontactive: function(familyName, fvd) {
                            ++counter;
                            var rawCanvas = drawCanvas(
                                    googleFont.get('family'),
                                    googleFont.get('id')
                                ),
                                trimDetails = rawCanvas.trimWhitespace(),
                                resizedCanvas = document.createElement('canvas'),
                                resizedContext = resizedCanvas.getContext('2d'),
                                multiplier = optimizeForRetina === true ? window.devicePixelRatio : 1;
                            resizedCanvas.width = trimDetails.width / multiplier;
                            resizedCanvas.height = trimDetails.height / multiplier;
                            resizedContext.drawImage(
                                rawCanvas,
                                trimDetails.bounds.left,
                                trimDetails.bounds.top,
                                trimDetails.width,
                                trimDetails.height,
                                0,
                                0,
                                trimDetails.width / multiplier,
                                trimDetails.height / multiplier
                            );

                            // 
                            console.log('added to zip file #' + counter);
                            var name = (googleFont.get('id')) + '.' +
                                (googleFont.get('version')) + '.png';
                            zip.file(
                                name,
                                resizedCanvas.toDataURL('image/png').split(',')[1],
                                {
                                    base64: true
                                }
                            );

                            // 
                            var googleFontsWithoutImages = collection.filter(function(index, googleFont) {
                                return googleFont.get('hasImage').toInt() === 0;
                            });
                            if (counter === googleFontsWithoutImages.length) {
                                zip.generateAsync({type: 'blob'}).then(
                                    function(content) {
                                        saveAs(content, 'images.zip');
                                    }
                                );
                            }
                        },
                        fontinactive: function() {
                            console.log('bag');
                        },
                        custom: {
                            families: [googleFont.get('id')]
                        },
                        timeout: 5000
                    });
                }
            });
        },

        /**
         * _drawGoogleFont
         * 
         * @access  protected
         * @param   GoogleFontAccessor googleFont
         * @param   Number position
         * @return  void
         */
        _drawGoogleFont: function(googleFont, position) {
            var $element = DataUtils.render('GoogleFontRow', {
                googleFont: googleFont
            });
            if (position === 0) {
                this.find('div.results div.inner').prepend($element);
            } else {
                this.find('div.results div.inner').append($element);
            }
            new GoogleFontRowView($element, googleFont);
        },

        /**
         * _getCategories
         * 
         * @note    ['empty'] array is returned when no categories, because
         *          otherwise, there's an error on the backend because JavaScript
         *          can't submit an empty array as a parameter via ajax.
         * @access  protected
         * @return  Array
         */
        _getCategories: function() {
            var $checked = this.find('input[type="checkbox"]:checked'),
                categories = [], index;
            jQuery.each($checked, function(index, $input) {
                categories.push(
                    $($input).val()
                );
            });
            if (categories.length === 0) {
                return ['empty'];
            }
            return categories;
        },

        /**
         * _getSubset
         * 
         * @access  protected
         * @return  String
         */
        _getSubset: function() {
            return this.find('[name="data[subset]"]').val();
        },

        /**
         * _getQuery
         * 
         * @access  protected
         * @return  String
         */
        _getQuery: function() {
            return this._query;
        },

        /**
         * _getWeight
         * 
         * @access  protected
         * @return  String
         */
        _getWeight: function() {
            return this.find('[name="data[weight]"]').val();
        },

        /**
         * _getSort
         * 
         * @access  protected
         * @return  String
         */
        _getSort: function() {
            return this.find('[name="data[sort]"]').val();
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _setupCheckboxes
         * 
         * @access  protected
         * @return  void
         */
        _setupCheckboxes: function() {
            var _this = this;
            this.find('input[type="checkbox"]').on({
                'change': function(event) {
                    _this.pause();
                    _this.unload();
                    _this.trackLoad();
                    _this.load(true, function() {
                        _this.unpause();
                    });
                }
            });
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = new GoogleFontsCollection();
            this._collection.on({
                'add': function(event, googleFont, position) {
                    _this._drawGoogleFont(googleFont, position);
                },
                'list': function(event) {
                    _this.refreshScrollbar();
                },
                'empty': function(event) {
                    _this.find('.googleFontRow').remove();
                    _this.refreshScrollbar();
                }
            });
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.pause();
                    _this.unload();
                    _this.trackLoad();
                    _this.load(true, function() {
                        _this.unpause();
                    });
                    _this.find('label').focus();
                }
            );
        },

        /**
         * _setupScrollbar
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbar: function() {
            if (UserAgent.supports.css.scrollbars() === false) {
                var $results = this.find('div.results');
                this._makeScrollable($results);
            }
        },

        /**
         * _setupSearch
         * 
         * @access  protected
         * @return  void
         */
        _setupSearch: function() {

            // Draw
            var total = Config.get('google').fonts.total.commas(),
                placeholder = 'Search for your font by name',
                $search = DataUtils.render('ResourcesSearch', {
                    placeholder: placeholder
                });
            this.find('h1').after($search);

            // Events
            this.on({
                'clear': function(event) {
                    var $input = this.find('input.search');
                    $input.val('');
                    this.find('div.field').removeClass('queried');
                    this.find('div.field').addClass('active');
                    this._query = '';
                    this.unload();
                    this.pause();
                    var _this = this;
                    this.trackLoad();
                    this.load(true, function() {
                        _this.unpause();
                        if (UserAgent.is.tablet() === false) {
                            $input.focus();
                        }
                    });
                },
                'submit': function(event) {
                    var $weight = this.find('select[name="data[weight]"]');
                    $weight.val('all');
                    $weight.selectpicker('refresh');
                    var $input = this.find('input.search'),
                        val = $input.val();
                    if (UserAgent.is.tablet() === true) {
                        document.activeElement.blur();
                        $input.blur();
                    }
                    this.find('div.field').addClass('queried');
                    this.find('div.field').removeClass('active');
                    this._query = $input.val();
                    this.unload();
                    this.pause();
                    var _this = this;
                    this.trackLoad();
                    this.load(true, function() {
                        _this.unpause();
                        if (UserAgent.is.tablet() === false) {
                            $input.focus();
                        }
                    });
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * getCollection
         * 
         * @access  public
         * @return  GoogleFontsCollection
         */
        getCollection: function() {
            return this._collection;
        },

        /**
         * load
         * 
         * @note    We need to check for stats being defined because when the
         *          request times out, that property isn't available. See:
         *          https://i.imgur.com/cYAI9mt.png
         * @access  public
         * @param   Boolean delay
         * @param   undefined|Function callback
         * @return  void
         */
        load: function(delay, callback) {
            var _this = this;
            this._element.find('.empty').addClass('hidden');
            this._element.addClass('loading');
            this._collection.list({
                conditions: {
                    categories: this._getCategories(),
                    query: this._getQuery(),
                    subset: this._getSubset(),
                    weight: this._getWeight()
                },
                delay: delay === true ? 1 : 0,
                limit: Config.default('objectsPerPage').fonts.import,
                offset: this._collection.length(),
                sort: this._getSort()
            }, function(response) {
                _this._element.removeClass('loading');
                _this._loading = false;
                _this._more = response.data.more;
                if (response.data.stats !== undefined) {
                    _this.updateCount(
                        response.data.stats.found,
                        response.data.stats.total
                    );
                }
                if (_this._collection.length() === 0) {
                    _this._element.find('.empty').removeClass('hidden');
                }
                callback && callback();
            });
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._super();
            this.find('a.button.tiny').disable();
            this.find('div.field input').disable();
            this.find('aside').disable();
        },

        /**
         * refreshScrollbar
         * 
         * @access  public
         * @return  void
         */
        refreshScrollbar: function() {
            if (this._$scrollbar !== null) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super();
            Stencil.set('ignoreMouseDownLayerBlur', true);
            if (UserAgent.is.tablet() === false) {
                this.find('input[type="text"]').focus();
            }
            if (this._loaded === false) {
            // if (this._query !== query) {
                // this.unload();
                // this._query = query;
                this.trackLoad();
                this.load(true);
            }
        },

        /**
         * trackLoad
         * 
         * Tracks that results are being loaded.
         * 
         * @access  public
         * @return  void
         */
        trackLoad: function() {
            this._loaded = true;
            this._loading = true;
        },

        /**
         * unload
         * 
         * @access  public
         * @return  void
         */
        unload: function() {
            this._loaded = false;
            this._loading = false;
            this._more = false;
            this._collection.empty();
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._super();
            this.find('a.button.tiny:not(.done)').enable();
            this.find('div.field input').enable();
            this.find('aside').enable();
        },

        /**
         * updateCount
         * 
         * @access  public
         * @param   Number found
         * @param   Number total
         * @return  void
         */
        updateCount: function(found, total) {
            var $counts = this.find('section footer div.counts'),
                $total = $counts.find('strong');
            $counts.removeClass('invisible');
            $total.text(total.commas());
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ImageSentModalView
     * 
     * @extends ModalView
     */
    window.ImageSentModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ImageSentModalView')
         */
        _string: 'ImageSentModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, shareModal, image) {
            this._super(element);
            this._shareModal = shareModal;
            this._setupTooltips();
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = image.getSharePath('instagram');
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * LegacyModalView
     * 
     * @extends ModalView
     */
    window.LegacyModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LegacyModalView')
         */
        _string: 'LegacyModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * LegacyImageNormalizeModalView
     * 
     * @extends ModalView
     */
    window.LegacyImageNormalizeModalView = ModalView.extend({

        /**
         * _image
         * 
         * @access  protected
         * @var     false|ImageAccessor (default: false)
         */
        _image: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LegacyImageNormalizeModalView')
         */
        _string: 'LegacyImageNormalizeModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this._addLeaveEvent();
        },

        /**
         * _addLeaveEvent
         * 
         * @access  protected
         * @return  void
         */
        _addLeaveEvent: function() {
            this.on({
                'leave': function(event) {
                    if (this._image.get('legacyNormalized').toInt() === 1) {
                        this._image.select('unknown', false, {});
                    } else {
                        var start = new Date(),
                            key = 'image.legacy.normalizing',
                            msg = Stencil.getMessage(key);
                        App.getBusy().show(msg);
                        this._image.once({
                            'normalize': function(event) {
                                (function() {
                                    App.getBusy().hide();
                                    this.select('unknown', false, {});
                                }).minDelay(start, 2500, this);
                            }
                        });
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AuthModalView', function() {

    /**
     * LoginModalView
     * 
     * @extends AuthModalView
     */
    window.LoginModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LoginModalView')
         */
        _string: 'LoginModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   false|String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    var accountData = response.data.account,
                        userData = response.data.user;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    Stencil.account().swap(accountData);
                    Stencil.account().swapCategories();
                    var model = Stencil.getModel('User'),
                        user = model.setAccessor(userData);
                    Stencil.set('user', user);
                    User.login();
                    _this._flow();
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ModalView
     * 
     * @events  close
     *          leave
     * @extends View
     */
    window.ModalView = View.extend({

        /**
         * _fallbackPath
         * 
         * The path that a modal should fallback to if it was directly accessed
         * and is subsequently closed (eg. linking a user to a share modal from
         * an email).
         * 
         * @access  protected
         * @var     String (default: '/app')
         */
        _fallbackPath: '/app',

        /**
         * _paused
         * 
         * Tracks whether the modal is paused. Used to prevent the user from
         * navigating away and interrupting the UX.
         * 
         * @access  protected
         * @var     Boolean
         */
        _paused: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ModalView')
         */
        _string: 'ModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addCloseEvent();
            this._addHideEvent();
            this._addLeaveEvent();
        },

        /**
         * _addCloseEvent
         * 
         * Adds a close event to the modal, which in this case is responsible
         * for:
         * - hiding tooltips that may be showing in the modal
         * - Closing HelpScout if it's open
         * - Remove the modal from the DOM
         * - Removing the modal reference from the Modals singelton refernce of
         *   open modals
         * 
         * It's important to note that this listener does not affect app
         * navigation at all.
         * 
         * @access  protected
         * @return  void
         */
        _addCloseEvent: function() {
            this.on({
                'close': function(event) {
                    App.tooltips.hide();
                    var _this = this,
                        open = Modals.getOpen();
                    HelpScout.close();
                    this.remove();
                    $(open).each(
                        function(index, modal) {
                            if (modal === _this) {
                                open.splice(index, 1);
                            }
                        }
                    );
                }
            });
        },

        /**
         * _addHideEvent
         * 
         * Adds a hide event to the modal, which at the time of documenting is
         * only being used by the SocialSettingsView class.
         * 
         * @access  protected
         * @return  void
         */
        _addHideEvent: function() {
            this.on({
                'hide': function(event) {
                    this.hide();
                }
            });
        },

        /**
         * _addLeaveEvent
         * 
         * Adds a leave event, which at the time of documenting, is similar to a
         * close event, with the exception that it will navigate the browser
         * back to a specific path.
         * 
         * @access  protected
         * @return  void
         */
        _addLeaveEvent: function() {
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var router = Stencil.getRouter(),
                        path = router.getPrevious() || this._fallbackPath;
                    router.setPrevious(false);
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * find
         * 
         * Middleware method to prevent lookups from going into any submodals.
         * This was happening between the CheckoutModal and ApplyCouponModal.
         * 
         * @access  public
         * @param   String selector
         * @return  jQuery
         */
        find: function(selector) {
            var $matches = this._super(selector);
            if (this._element.parents('.modal').length === 0) {
                return $matches.filter(function() {
                    return $(this).parents('.modal').length === 1;
                });
            }
            return $matches;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._element.addClass('hidden');
        },

        /**
         * leaveUponEscapeKey
         * 
         * @access  public
         * @return  void
         */
        leaveUponEscapeKey: function() {
            var check = (function(event) {
                if (event.which === 27) {
                    this.triggerHandler('leave');
                }
            }).proxy(this);
            App.getElement().on({
                'keydown': check
            });
            this.on({
                'leave': function(event) {
                    App.getElement().unbind('keydown', check);
                }
            });
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._paused = true;
            this.find('> div.overlay').removeAttr('click');
            this.find('a.close').addClass('invisible');
        },

        /**
         * remove
         * 
         * @access  public
         * @return  void
         */
        remove: function() {
            this._element.remove();
        },

        /**
         * setFallbackPath
         * 
         * @access  public
         * @param   String path
         * @return  void
         */
        // setFallbackPath: function(path) {
        //     this._fallbackPath = path;
        // },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._element.removeClass('hidden');
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._paused = false;
            this.find('> div.overlay').attr('click', 1);
            this.find('a.close').removeClass('invisible');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StickyModalView', function() {

    /**
     * OnboardModalView
     * 
     * @extends StickyModalView
     */
    window.OnboardModalView = StickyModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OnboardModalView')
         */
        _string: 'OnboardModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String point
         * @param   jQuery $relative
         * @param   jQuery $highlight
         * @return  void
         */
        init: function(element, point, $relative, $highlight) {
            // StencilBooter.log($relative, $highlight);
            this._super(element, point, $relative, $highlight);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * OnboardingModalView
     * 
     * @extends ModalView
     */
    window.OnboardingModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OnboardingModalView')
         */
        _string: 'OnboardingModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   Object settings
         * @return  void
         */
        init: function(element, settings) {
            this._super(element);
            this._settings = settings;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * OrientationModalView
     * 
     * @extends ModalView
     */
    window.OrientationModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'OrientationModalView')
         */
        _string: 'OrientationModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PasswordModalView
     * 
     * @extends ModalView
     */
    window.PasswordModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _redirect
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _redirect: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PasswordModalView')
         */
        _string: 'PasswordModalView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element);
            this._type = type;
            this._redirect = redirect;
            this._form = new AppFormView(this.find('form'));
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Password recovery email sent');
                    _this.find('.pre').addClass('hidden');
                    _this.find('.post').removeClass('hidden');
                    // _this.triggerHandler('leave');
                    // Stencil.alert('password.reset');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PlanSwitchModalView
     * 
     * @extends ModalView
     */
    window.PlanSwitchModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlanSwitchModalView')
         */
        _string: 'PlanSwitchModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PlanSwitchedModalView
     * 
     * @extends ModalView
     */
    window.PlanSwitchedModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlanSwitchedModalView')
         */
        _string: 'PlanSwitchedModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * PlansModalView
     * 
     * @extends ModalView
     */
    window.PlansModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlansModalView')
         */
        _string: 'PlansModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            // this.unbind('leave');
            // this.on({
            //     'leave': function(event) {
            //         this.triggerHandler('close');
            //     }
            // });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AuthModalView', function() {

    /**
     * PromoModalView
     * 
     * @extends AuthModalView
     */
    window.PromoModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PromoModalView')
         */
        _string: 'PromoModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   false|String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {

                    // Data merge for change history
                    var userData = response.data.user,
                        accountData = response.data.account;
                    accountData = ChangeHistory.replaceAccountChangeHistory(
                        accountData
                    );
                    userData = ChangeHistory.replaceUserChangeHistory(
                        userData
                    );

                    /**
                     * Signup as well as promo redemption
                     * 
                     */
                    if (Stencil.get('user') === false) {
                        var model = Stencil.getModel('User'),
                            user;
                        user = model.setAccessor(userData);
                        Stencil.set('user', user);
                        User.signup();
                    }

                    /**
                     * Promo redemption for logged in account
                     * 
                     */
                    Stencil.account().merge(accountData);
                    Stencil.get('user').merge(userData);
                    User.upgrade(false);
                    var path = Stencil.account().getUpgradedPath();
                    if (_this._type !== 'curtain') {
                        _this.triggerHandler('leave');
                        Stencil.navigate(path);
                    } else {
                        _this._element.addClass('transition');
                        (function() {
                            App.getElement().removeClass('curtain');
                            _this.triggerHandler('leave');
                            Stencil.navigate(path);
                        // }).delay(1800);
                        }).delay(0);
                    }
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * AddPromoSetModalView
     * 
     * @extends ModalView
     */
    window.AddPromoSetModalView = ModalView.extend({

        /**
         * _adminModal
         * 
         * Reference to the open admin modal so that events can be paused on it
         * while an action is happening
         * 
         * @access  protected
         * @var     null|SettingsModalView (default: null)
         */
        _adminModal: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AddPromoSetModalView')
         */
        _string: 'AddPromoSetModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminModalView adminModal
         * @return  void
         */
        init: function(element, adminModal) {
            this._super(element);
            this._adminModal = adminModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    Stencil.navigate('/app/admin/promoSets');
                }
            });
            this._setupDropdowns();
            this._setupForm();
            this._setupDatetimePicker();
            this._setupTooltips();
        },

        /**
         * _format
         * 
         * @access  protected
         * @return  void
         */
        _format: function() {

            // Format expiry
            var $expiry = this.find('#expiry'),
                expiry = $expiry.val(),
                mo = moment(expiry, 'MM/DD/YYYY h:mm A');
            this.find('[name="data[expiry]"]').val(
                mo.format('X')
            );
        },

        /**
         * _setupDatetimePicker
         * 
         * @access  protected
         * @return  void
         */
        _setupDatetimePicker: function() {
            var current = new Date();
            current.setDate(current.getDate());
            this.find('#expiry').datetimepicker({
                // debug: true,
                format: 'MM/DD/YYYY h:mm A',
                minDate: current,
                // showTodayButton: true,
                showClose: true,
                showClear: true,
                icons: {
                    time: 'fa fa-clock-o',
                    date: 'fa fa-calendar',
                    up: 'fa fa-chevron-up',
                    down: 'fa fa-chevron-down',
                    previous: 'fa fa-chevron-left',
                    next: 'fa fa-chevron-right',
                    today: 'fa fa-calendar-check-o',
                    clear: 'fa fa-trash-o',
                    close: 'fa fa-close'
                }
            });
            this.find('#expiry').val('');
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            this.find('select').selectpicker({
                dropupAuto: false
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            var _this = this;
            this._form.on({
                'submitted': this._format.proxy(this)
            });
            this._form.on({
                'submitted': function(event) {
                    _this._adminModal.pause();
                    _this.pause();
                }
            });
            this._form.on({
                'returned': function(event) {
                    _this._adminModal.unpause();
                    _this.unpause();
                }
            });
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Promo set added');
                    var collection = _this._adminModal.getSection('promoSets')._collection;
                    collection.map(response.data.object, false);
                    Stencil.navigate('/app/admin/promoSets');
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                container: this._element,
                html: true,
                placement: 'bottom',
                selector: '[tooltip]'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * RenameModalView
     * 
     * @events  save
     * @extends ModalView
     */
    window.RenameModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RenameModalView')
         */
        _string: 'RenameModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this.leaveUponEscapeKey();
            this._setupForm();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned/failed': function(event) {
                    _this.unpause();
                },
                'returned/shit': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    _this.triggerHandler('save', [response.data.object]);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('StickyModalView', function() {

    /**
     * RightClickModalView
     * 
     * @extends StickyModalView
     */
    window.RightClickModalView = StickyModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'RightClickModalView')
         */
        _string: 'RightClickModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String direction
         * @param   jQuery $relative
         * @param   jQuery $highlight
         * @return  void
         */
        init: function(element, direction, $relative, $highlight) {
            // StencilBooter.log($relative, $highlight);
            this._super(element, direction, $relative, $highlight);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * SettingsModalView
     * 
     * @extends ModalView
     */
    window.SettingsModalView = ModalView.extend({

        /**
         * _settings
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _settings: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SettingsModalView')
         */
        _string: 'SettingsModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupNotifications();
            this._setupObfuscate();
            this._setupPassword();
            this._setupPayment();
            this._setupPlan();
            this._setupProfile();
            this._setupReferral();
            this._setupSocial();
        },

        /**
         * _setupNotifications
         * 
         * @access  protected
         * @return  void
         */
        _setupNotifications: function() {
            var $notifications = this.find('section.notifications');
            this._settings.notifications = new NotificationsSettingsView(
                $notifications,
                this
            );
        },

        /**
         * _setupObfuscate
         * 
         * @access  protected
         * @return  void
         */
        _setupObfuscate: function() {
            var $obfuscate = this.find('section.obfuscate');
            this._settings.obfuscate = new ObfuscateSettingsView(
                $obfuscate,
                this
            );
        },

        /**
         * _setupPassword
         * 
         * @access  protected
         * @return  void
         */
        _setupPassword: function() {
            var $password = this.find('section.password');
            this._settings.password = new PasswordSettingsView($password, this);
        },

        /**
         * _setupPayment
         * 
         * @access  protected
         * @return  void
         */
        _setupPayment: function() {
            var $payment = this.find('section.payment');
            this._settings.payment = new PaymentSettingsView($payment, this);
        },

        /**
         * _setupPlan
         * 
         * @access  protected
         * @return  void
         */
        _setupPlan: function() {
            var $plan = this.find('section.plan');
            this._settings.plan = new PlanSettingsView($plan, this);
        },

        /**
         * _setupProfile
         * 
         * @access  protected
         * @return  void
         */
        _setupProfile: function() {
            var $profile = this.find('section.profile');
            this._settings.profile = new ProfileSettingsView($profile, this);
        },

        /**
         * _setupReferral
         * 
         * @access  protected
         * @return  void
         */
        _setupReferral: function() {
            var $referral = this.find('section.referral');
            this._settings.referral = new ReferralSettingsView($referral, this);
        },

        /**
         * _setupSocial
         * 
         * @access  protected
         * @return  void
         */
        _setupSocial: function() {
            var $social = this.find('section.social');
            this._settings.social = new SocialSettingsView($social, this);
        },

        /**
         * getSettings
         * 
         * @access  public
         * @param   String type
         * @return  SettingsView
         */
        getSettings: function(type) {
            return this._settings[type];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ShareModalView
     * 
     * @todo    Preload connection profile/images, incase they change their
     *          desired connection.
     * @todo    Currently the 64 bit data encoded image is inserted into any
     *          share views that the user views, while the image is being
     *          uploaded
     *          For better quality, two things should happen:
     *          1. When the ghost is ready, switch that data encoded value in
     *          2. When the image has been uploaded, switch that src in
     * @extends ModalView
     */
    window.ShareModalView = ModalView.extend({

        /**
         * _fallback
         * 
         * See parent for documentation on this property.
         * 
         * @access  protected
         * @var     String (default: '/app/saved')
         */
        _fallback: '/app/saved',

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _networks
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _networks: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareModalView')
         */
        _string: 'ShareModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ImageAccessor image
         * @return  void
         */
        init: function(element, image) {
            this._super(element);
            this._image = image;
            this._setupBuffer();
            this._setupFacebook();
            this._setupInstagram();
            this._setupLink();
            this._setupPinterest();
            this._setupTooltips();
            this._setupTwitter();
            this._setupVerifone();
            // this._addHoverEvents();
        },

        /**
         * _addVerifoneFrameAttribute
         * 
         * @access  protected
         * @return  void
         */
        _addVerifoneFrameAttribute: function() {
            this._element.removeAttr('frame');
            if (this._image.isVerifoneFrame() === true) {
                var frameKey = this._image.get('frame');
                this._element.attr('frame', frameKey);
            }
        },

        /**
         * _addHoverEvents
         * 
         * @access  protected
         * @var     void
         */
        _addHoverEvents: function() {
            var _this = this;
            this.find('a[network]:not([network="buffer"])').one({
                'mouseenter': function(event) {
                    var $target = $(event.currentTarget),
                        network = $target.attr('network');
                    _this._networks[network].drawImage('desktop');
                }
            });
            this.find('a[network="buffer"]').one({
                'mouseenter': function(event) {
                    var $target = $(event.currentTarget),
                        network = $target.attr('network');
                    _this._networks[network].drawImage();
                }
            });
        },

        /**
         * _setupBuffer
         * 
         * @access  protected
         * @return  void
         */
        _setupBuffer: function() {
            var $buffer = this.find('section.buffer');
            this._networks.buffer = new BufferShareView($buffer, this);
        },

        /**
         * _setupFacebook
         * 
         * @access  protected
         * @return  void
         */
        _setupFacebook: function() {
            var $facebook = this.find('section.facebook');
            this._networks.facebook = new FacebookShareView($facebook, this);
        },

        /**
         * _setupInstagram
         * 
         * @access  protected
         * @return  void
         */
        _setupInstagram: function() {
            var $instagram = this.find('section.instagram');
            this._networks.instagram = new InstagramShareView($instagram, this);
        },

        /**
         * _setupLink
         * 
         * @access  protected
         * @return  void
         */
        _setupLink: function() {
            var $link = this.find('section.link');
            this._networks.link = new LinkShareView($link, this);
        },

        /**
         * _setupPinterest
         * 
         * @access  protected
         * @return  void
         */
        _setupPinterest: function() {
            var $pinterest = this.find('section.pinterest');
            this._networks.pinterest = new PinterestShareView($pinterest, this);
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            var account = Stencil.account();
            // if (account.createdBefore('2 weeks') === false) {
            if (false) {
                this._element.tooltip({
                    html: true,
                    selector: '[tooltip]',
                    container: this._element,
                    placement: 'left'
                });
            }
        },

        /**
         * _setupTwitter
         * 
         * @access  protected
         * @return  void
         */
        _setupTwitter: function() {
            var $twitter = this.find('section.twitter');
            this._networks.twitter = new TwitterShareView($twitter, this);
        },

        /**
         * _setupVerifone
         * 
         * @access  protected
         * @return  void
         */
        _setupVerifone: function() {
            var $verifone = this.find('section.verifone');
            this._networks.verifone = new VerifoneShareView($verifone, this);
        },

        /**
         * getImage
         * 
         * @access  public
         * @return  ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getNetwork
         * 
         * @access  public
         * @param   String network
         * @return  NetworkView
         */
        getNetwork: function(network) {
            return this._networks[network];
        },

        /**
         * pause
         * 
         * @access  public
         * @return  void
         */
        pause: function() {
            this._super();
            this.find('nav a').disable();
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._addVerifoneFrameAttribute();
            this._super();
        },

        /**
         * unpause
         * 
         * @access  public
         * @return  void
         */
        unpause: function() {
            this._super();
            this.find('nav a').enable();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ShareErrorModalView
     * 
     * @extends ModalView
     */
    window.ShareErrorModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareErrorModalView')
         */
        _string: 'ShareErrorModalView',

        /**
         * init
         * 
         * @todo    Look into whether redirect below is needed; I don't think it
         *          is, since the success modal isn't a unique resource. Should
         *          be able to just close it.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ImageAccessor image
         * @param   ConnectionAccessor connection
         * @return  void
         */
        init: function(element, shareModal, image, connection) {
            this._super(element);
            this._shareModal = shareModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var network = connection.get('network'),
                        path = image.getSharePath(network);
                    Stencil.navigate(path);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * ShareSuccessModalView
     * 
     * @extends ModalView
     */
    window.ShareSuccessModalView = ModalView.extend({

        /**
         * _shareModal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _shareModal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ShareSuccessModalView')
         */
        _string: 'ShareSuccessModalView',

        /**
         * init
         * 
         * @todo    Look into whether redirect below is needed; I don't think it
         *          is, since the success modal isn't a unique resource. Should
         *          be able to just close it.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView shareModal
         * @param   ShareAccessor share
         * @return  void
         */
        init: function(element, shareModal, share) {
            this._super(element);
            this._shareModal = shareModal;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var network = share.reference('connection').get('network'),
                        path = share.reference('image').getSharePath(network);
                    Stencil.navigate(path);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AuthModalView', function() {

/*
Stencil.navigate('/app/signup');
Stencil.navigate('/app/signup?save');
Stencil.navigate('/app/signup?upgrade');
Stencil.navigate('/app/signup?checkout');
*/

    /**
     * SignupModalView
     * 
     * @extends AuthModalView
     */
    window.SignupModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SignupModalView')
         */
        _string: 'SignupModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String type
         * @param   String redirect
         * @return  void
         */
        init: function(element, type, redirect) {
            this._super(element, type, redirect);
            this._form.setTimeout(0);
            this._deselectSelectedLayer();
            this._loadCaptchaScript();
            var _this = this;
            this._form.on({
                'submitted': function(event) {
                    _this.pause();
                },
                'returned': function(event) {
                    _this.unpause();
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('User'),
                        userData = response.data.user,
                        user;
                    userData = ChangeHistory.replaceUserChangeHistory(userData);
                    user = model.setAccessor(userData);
                    Stencil.set('user', user);
                    User.signup();
                    _this._flow();
                }
            });
        },

        /**
         * _loadCaptchaScript
         * 
         * @access  protected
         * @return  void
         */
        _loadCaptchaScript: function() {
            if (Account.requireCaptcha() === true) {
                Scripts.load('reCaptcha');
            }
        },

        /**
         * _deselectSelectedLayer
         * 
         * @note    This exists because there was a case whereby a user got to
         *          the signup modal and a toolbar was open. When that happened,
         *          which also meant a ToolbarView was showing, the keydown event
         *          listener for the page was preventing the tab key (since that
         *          event triggers the layer-tabbing flow) from working within
         *          the form. So I saw below that if a layer is selected, discard
         *          the active object, hide the controls for the drawing, and
         *          hide the toolbar.
         * @access  protected
         * @return  void
         */
        _deselectSelectedLayer: function() {
            // Canvases.Preview.deselectSelectedLayer();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('AuthModalView', function() {

    /**
     * TemplatePreviewModalView
     * 
     * @extends AuthModalView
     */
    window.TemplatePreviewModalView = AuthModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TemplatePreviewModalView')
         */
        _string: 'TemplatePreviewModalView',

        /**
         * _template
         * 
         * @access  protected
         * @var     null|TemplateAccessor (default: null)
         */
        _template: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   TemplateAccessor template
         * @return  void
         */
        init: function(element, template) {
            this._super(element);
            this._template = template;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
            this._addImageListeners();
        },

        /**
         * _addImageListeners
         * 
         * @access  protected
         * @return  void
         */
        _addImageListeners: function() {
            var $img = this.find('img');
            $img.on({
                'contextmenu': function(event) {
                    event.preventDefault();
                }
            });
        },

        /**
         * position
         * 
         * @access  public
         * @return  void
         */
        position: function() {
            var $content = this.find('div.content').first(),
                $columns = $content.find('.columns').first(),
                $first = $columns.find('.column').first();
            var width = $columns.css('width').toInt();
            width = width.ceil();
            width = (width) + 'px';
            $content.css({
                width: width
            });
            var height = $first.find('> div.content').first().css('height').toInt();
            height = height.ceil();
            height = (height) + 'px';
            $columns.css({
                height: height
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * StickyModalView
     * 
     * @extends ModalView
     */
    window.StickyModalView = ModalView.extend({

        /**
         * _$highlight
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$highlight: null,

        /**
         * _$relative
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$relative: null,

        /**
         * _direction
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _direction: null,

        /**
         * _padding
         * 
         * @access  protected
         * @var     Number (default: 20)
         */
        _padding: 20,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StickyModalView')
         */
        _string: 'StickyModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String direction Which direction (eg. up down left right) the
         *          sticky modal should point
         * @param   jQuery $relative
         * @param   false|jQuery $highlight
         * @return  void
         */
        init: function(element, direction, $relative, $highlight) {
            this._super(element);
            this._direction = direction;
            this._$relative = $relative;
            this._$highlight = $highlight || this._$relative;
            this._addPositionEvent();
            this._addCloseEvent();
        },
        
        /**
         * _addCloseEvent
         * 
         * @access  protected
         * @return  void
         */
        _addCloseEvent: function() {
            this._super();
            this.on({
                'close': function(event) {
                    this._$highlight.css('z-index', 'auto');
                }
            });
        },
        
        /**
         * _addPositionEvent
         * 
         * @access  protected
         * @return  void
         */
        _addPositionEvent: function() {
            var reposition = function() {
                this.position();
            }.proxy(this);
            $(window).resize(reposition);
            this.on({
                'close': function(event) {
                    $(window).unbind('resize', reposition);
                }
            });
        },
        
        /**
         * _positionAbove
         * 
         * @note    Content offset is used, because without it, the positioning
         *          is off when the app is loaded externally. This is because of
         *          the padding on the body, which throws off the calculations.
         * @access  protected
         * @return  void
         */
        _positionAbove: function() {
            var offset = {
                    content: App.find('> div.content').offset(),
                    relative: this._$relative.offset()
                },
                width = this._$relative.css('width'),
                height = this._$relative.css('height'),
                position = {
                    middle: offset.relative.left.toInt() - offset.content.left.toInt() + (width.toInt() / 2),
                    top: offset.relative.top.toInt() - offset.content.top.toInt()
                },
                $inner = this._element.find('.inner').first(),
                $content = this._element.find('.content').first();
            $inner.first().css({
                position: 'absolute',
                top: position.top - $content.css('height').toInt() - this._padding,
                left: position.middle - ($content.css('width').toInt() / 2)
            });
            this._$highlight.css('z-index', 1000);
            this._$highlight.css('position', 'relative');
        },
        
        /**
         * _positionBelow
         * 
         * @note    Content offset is used, because without it, the positioning
         *          is off when the app is loaded externally. This is because of
         *          the padding on the body, which throws off the calculations.
         * @access  protected
         * @return  void
         */
        _positionBelow: function() {
            var offset = {
                    content: App.find('> div.content').offset(),
                    relative: this._$relative.offset()
                },
                width = this._$relative.css('width'),
                height = this._$relative.css('height'),
                position = {
                    middle: offset.relative.left.toInt() - offset.content.left.toInt() + (width.toInt() / 2),
                    bottom: offset.relative.top.toInt() - offset.content.top.toInt() + height.toInt()
                },
                $inner = this._element.find('.inner').first(),
                $content = this._element.find('.content').first();
            $inner.first().css({
                position: 'absolute',
                top: position.bottom + this._padding,
                left: position.middle - ($content.css('width').toInt() / 2)
            });
            this._$highlight.css('z-index', 1000);
            this._$highlight.css('position', 'relative');
        },
        
        /**
         * position
         * 
         * @access  public
         * @return  void
         */
        position: function() {
            if (this._direction === 'up') {
                this._positionBelow();
            } else {
                this._positionAbove();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * TutorialsModalView
     * 
     * @extends ModalView
     */
    window.TutorialsModalView = ModalView.extend({

        /**
         * _tutorials
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _tutorials: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TutorialsModalView')
         */
        _string: 'TutorialsModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupSections();
        },

        /**
         * _setupSections
         * 
         * @access  protected
         * @return  void
         */
        _setupSections: function() {
            var tutorials = Config.get('tutorials'),
                _this = this;
            jQuery.each(tutorials, function(index, tutorial) {
                var slug = tutorial.slug,
                    selector = 'section.' + (slug),
                    $tutorials = _this.find(selector);
                _this._tutorials[slug] = new TutorialsView($tutorials, slug, _this);
            });
        },

        /**
         * getTutorials
         * 
         * @access  public
         * @param   String slug
         * @return  TutorialsView
         */
        getTutorials: function(slug) {
            return this._tutorials[slug];
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * UpgradeModalView
     * 
     * @extends ModalView
     */
    window.UpgradeModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradeModalView')
         */
        _string: 'UpgradeModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * UpgradedModalView
     * 
     * @extends ModalView
     */
    window.UpgradedModalView = ModalView.extend({

        /**
         * _plan
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _plan: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpgradedModalView')
         */
        _string: 'UpgradedModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String plan
         * @return  void
         */
        init: function(element, plan) {
            this._super(element);
            this._plan = plan;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * SearchUsersModalView
     * 
     * @extends ModalView
     */
    window.SearchUsersModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keydown: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    'input[type="text"]': function(event, $input) {
                        if (event.which === 13) {
                            var val = $input.val();
                            if (val !== '') {
                                this.triggerHandler('submit');
                            }
                        }
                    }
                },
                keypress: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger="submit"]': function(event, $element) {
                        event.preventDefault();
                        this.triggerHandler('submit');
                    }
                },
                submit: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $form
                     * @return  void
                     */
                    'form': function(event, $form) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SearchUsersModalView')
         */
        _string: 'SearchUsersModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   AdminUsersView section
         * @return  void
         */
        init: function(element, section) {
            this._super(element);
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = section.getPath();
                    Stencil.navigate(path);
                }
            });
            this.on({
                'submit': function(event) {
                    var $input = this.find('input[type="text"]'),
                        val = $input.val(),
                        query = encodeURIComponent(val),
                        path = '/app/admin/users/search/' + (query);
                    Stencil.navigate(path, true, true);
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * UpdateUserModalView
     * 
     * @extends ModalView
     */
    window.UpdateUserModalView = ModalView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'UpdateUserModalView')
         */
        _string: 'UpdateUserModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String key
         * @param   AdminUsersView section
         * @return  void
         */
        init: function(element, key, section) {
            this._super(element);
            this.unbind('leave');
            this._setupDropdowns();
            this._setupTooltips();
            this._form = new AppFormView(this.find('form'));
            var modal = this;
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                }
            });
            this._form.on({
                'returned/succeeded': function(event, response) {
                    var user = Stencil.getAccessor(key),
                        id = user.get('id'),
                        encoded = encodeURIComponent(id),
                        url = '/app/admin/users/search/' + (encoded);
                    Stencil.set('temporaryReloadUrl', url);
                    Stencil.alert('admin.user.update');
                    Stencil.kill();
                }
            });
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                    var path = section.getPath();
                    Stencil.navigate(path);
                }
            });
        },

        /**
         * _setupDropdowns
         * 
         * @access  protected
         * @return  void
         */
        _setupDropdowns: function() {
            this.find('select').selectpicker();
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: this._element,
                placement: 'bottom'
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * WelcomeTourModalView
     * 
     * @extends ModalView
     */
    window.WelcomeTourModalView = ModalView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WelcomeTourModalView')
         */
        _string: 'WelcomeTourModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * step
         * 
         * @access  public
         * @param   Number step
         * @return  void
         */
        step: function(step) {
            this.find('div.step').addClass('hidden');
            this.find('[step="' + (step) + '"]').removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ModalView', function() {

    /**
     * YouTubeVideoModalView
     * 
     * @extends ModalView
     */
    window.YouTubeVideoModalView = ModalView.extend({

        /**
         * _options
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _options: {},

        /**
         * _slug
         * 
         * @access  protected
         * @var     false|String (default: false)
         */
        _slug: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'YouTubeVideoModalView')
         */
        _string: 'YouTubeVideoModalView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   String youTubeSlug
         * @param   Object options
         * @return  void
         */
        init: function(element, youTubeSlug, options) {
            this._super(element);
            this._youTubeSlug = youTubeSlug;
            this._options = options;
            this.unbind('leave');
            this.on({
                'leave': function(event) {
                    this.triggerHandler('close');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * AppPageView
     * 
     * @extends View
     */
    window.AppPageView = View.extend({

        /**
         * _dropModalShowing
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _dropModalShowing: false,

        /**
         * _editor
         * 
         * @access  protected
         * @var     null|EditorView (default: null)
         */
        _editor: null,

        /**
         * _hourglass
         * 
         * @access  protected
         * @var     null|HourglassView (default: null)
         */
        _hourglass: null,

        /**
         * _last
         * 
         * Tracks the mouse position
         * 
         * @access  protected
         * @var     Object
         */
        _last: {
            x: 0,
            y: 0
        },

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a[internal]:not([disabled])': function(event, $anchor) {
                        event.preventDefault();
                        var href = $anchor.attr('href');
                        Stencil.navigate(href);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Prevents disabled click events from default actions and going
                     * up the chain.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'a[internal][disabled]': function(event, $anchor) {
                        event.preventDefault();
                    }
                }
                // keydown: {
                //     '[tabindex]': function(event, $element) {
                //         StencilBooter.log(event);
                //         if (event.which === 9) {
                //             event.preventDefault();
                //         }
                //     }
                // }
            });
        },

        /**
         * _maxScriptWaitMilliseconds
         * 
         * The maximum number of milliseconds the app will wait for a 3rd-party
         * script to load, before showing an alert.
         * 
         * @access  protected
         * @var     Number (default: 30 * 1000)
         */
        _maxScriptWaitMilliseconds: 30 * 1000,

        /**
         * _sidebar
         * 
         * @access  protected
         * @var     null|SidebarView (default: null)
         */
        _sidebar: null,

        /**
         * _stage
         * 
         * @access  protected
         * @var     null|StageView (default: null)
         */
        _stage: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'AppPageView')
         */
        _string: 'AppPageView',

        /**
         * _thresholds
         * 
         * @access  protected
         * @var     Object
         */
        _thresholds: {
            unrestrict: 2500
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            window.App = this;
            this._reInitFabricDevicePixelRatioSetting();
            this._addBrowserClasses();
            this._addCustomDragListeners();
            this._addDeviceClasses();
            this._addMousemoveEvent();
            this._addRenderEventListener();
            this._addChangeHistoryEventListeners();
            this._addDevicePixelRatioChangeEvent();
            this._drawDropModal();
            this._drawHourglass();
            this._preloadAccountOnboardingImages();
            this._preloadStencilIconFont();
            this._preloadVerifoneAssets();
            this._setupAuth();
            this._setupBusyModal();
            this._setupCookieCheck();
            this._setupEditor();
            this._setupEmergency();
            this._setupHelpScoutHide();
            this._setupHide();
            this._setupSelectAllListener();
            this._setupAdminKeyboardShortcuts();
            this._setupPasteListener();
            this._setupPartnerSource();
            this._setupSidebar();
            this._setupStage();
            this._setupTooltipHiding();
            this._setupUnload();
            // this._showNewBadge();
            if (UserAgent.is.tablet() === true) {
                this._setupOrientationModal();
            }
        },

        /**
         * _addBrowserClasses
         * 
         * A bit of gotcha here is that Microsoft Edge passes the Google Chrome
         * check. So to get around this, I simply check for Edge first. Also
         * worth noting is that Edge identifies as webkit, perhaps because it's
         * goal is to support all webkit features. This can throw things for a
         * loop sometimes.
         * 
         * @access  protected
         * @return  void
         */
        _addBrowserClasses: function() {
            if (UserAgent.is.edge() === true) {
                this._element.addClass('edge');
            } else if (UserAgent.is.chrome() === true) {
                this._element.addClass('chrome');
            } else if (UserAgent.is.safari() === true) {
                this._element.addClass('safari');
            } else if (UserAgent.is.firefox() === true) {
                this._element.addClass('firefox');
            } else if (UserAgent.is.ie() === true) {
                this._element.addClass('ie');
            }
        },

        /**
         * _addRenderEventListener
         * 
         * @access  protected
         * @return  void
         */
        _addRenderEventListener: function() {
            App.getElement().on({
                'mousedown': function(event) {
                    if (Canvases.Preview.get('rendering') === true) {
                        var msg = Stencil.getMessage('image.rendering'),
                            startTimestamp = new Date();
                        App.getBusy().show(msg);
                        Canvases.Preview.once({
                            'set/rendering': function(event, value) {
                                if (value === false) {
                                    var busy = App.getBusy();
                                    busy.hide.minDelay(
                                        startTimestamp,
                                        1000,
                                        busy
                                    );
                                }
                            }
                        });
                    }
                }
            });
        },

        /**
         * _addChangeHistoryEventListeners
         * 
         * @access  protected
         * @return  void
         */
        _addChangeHistoryEventListeners: function() {
            if (ChangeHistory.active() === true) {

                /**
                 * 
                 */
                this._element.on({
                    'mouseup keyup': function(event) {
                        ChangeHistory.track.delay(0, ChangeHistory, [true, event]);
                    }
                });
                this.on({
                    'changeHistory/track': function(event) {
                        ChangeHistory.track.delay(0, ChangeHistory, [true, event]);
                    }
                });

                /**
                 * Adds the keyboard shortcut listeners for redo and undo.
                 * 
                 */
                App.getElement().on({
                    'keydown': function(event) {
                        if (ChangeHistory.keyboardShortcuts.redo(event) === true) {

                            /**
                             * I prevent the browser default action if the y-key
                             * is pressed, because in Chrome the default action
                             * is to open the browser history.
                             * 
                             * @note    Safari error'd out when checking event.key.
                             *          For some reason, not available there.
                             */
                            // if (event.key.toLowerCase() === 'y') {
                            if (event.which.toInt() === 89) {
                                event.preventDefault();
                            }
                            ChangeHistory.initiate.redo(1);
                        } else if (ChangeHistory.keyboardShortcuts.undo(event) === true) {

                            /**
                             * I prevent the default behaviour, since in Safari,
                             * the default is to open any last closed tab.
                             * 
                             * @see     https://apple.stackexchange.com/questions/26834/how-can-i-get-safari-to-reopen-my-last-closed-tab
                             */
                            event.preventDefault();
                            ChangeHistory.initiate.undo(1);
                        }
                    }
                });
            }
        },

        /**
         * _addCustomDragListeners
         * 
         * @access  protected
         * @return  void
         */
        _addCustomDragListeners: function() {
            var _this = this,
                $element = this._element.find('> div.content');
            $element.listenForFileAndTabDrag();
            $element.on({
                'custom/drag/enter/files': function(event) {
                    _this._drop.show();
                },
                'custom/drag/enter/tab': function(event) {
                    _this._drop.show();
                }
            });
        },

        /**
         * _addDeviceClasses
         * 
         * @access  protected
         * @return  void
         */
        _addDeviceClasses: function() {
            if (UserAgent.is.ipad() === true) {
                this._element.addClass('ipad');
            }
        },

        /**
         * _addDragAndDropEvents
         * 
         * @access  protected
         * @return  void
         */
        // _addDragAndDropEvents: function() {
        //     window.addEventListener('dragenter', function(e) {
        //         lastTarget = e.target; // cache the last target here
        //     });
        //     window.addEventListener('dragleave', function(e) {
        //     // this is the magic part. when leaving the window,
        //     // e.target happens to be exactly what we want: what we cached
        //     // at the start, the dropzone we dragged into.
        //     // so..if dragleave target matches our cache, we hide the dropzone.
        //     if (e.target === lastTarget)
        //     {
        //     document.querySelector('.dropzone').style.visibility = 'hidden';
        //     document.querySelector('.dropzone').style.opacity = 0;
        //     }
        //     });
        // },

        /**
         * _addDevicePixelRatioChangeEvent
         * 
         * Detects a change (any change) to the window's devicePixelRatio
         * property, and prompts the user to reload the app (since the canvas
         * will likely be bust otherwise).
         * 
         * @see     http://stackoverflow.com/questions/28905420/window-devicepixelratio-change-listener/29653772#29653772
         * @see     http://caniuse.com/#feat=matchmedia
         * @access  protected
         * @return  void
         */
        _addDevicePixelRatioChangeEvent: function() {
            var dPR = window.devicePixelRatio.round(3),
                queries = {
                    min: 'screen and (min-resolution: ' + (dPR) + 'dppx)',
                    max: 'screen and (max-resolution: ' + (dPR) + 'dppx)'
                },
                kill = function(event) {
                    Stencil.account().draft().setConfiguration();
                    Stencil.account().draft().saveConfiguration();
                    Stencil.alert('devicePixelRatio.change');
                    Stencil.kill();
                };
            window.matchMedia(queries.max).addListener(kill);
            window.matchMedia(queries.min).addListener(kill);
        },

        /**
         * _addMousemoveEvent
         * 
         * @access  protected
         * @return  void
         */
        _addMousemoveEvent: function() {
            $(window).mousemove(
                function(event) {
                    this._last.x = event.pageX;
                    this._last.y = event.pageY;
                }.proxy(this)
            );
        },

        /**
         * _drawDropModal
         * 
         * @access  protected
         * @return  void
         */
        _drawDropModal: function() {
            var messages = Stencil.get('config').messages,
                $drop = DataUtils.render('DropModal', {
                copy: {
                    fonts: messages['app.drag.fonts'],
                    images: messages['app.drag.images'],
                    watermarks: messages['app.drag.watermarks']
                }
            });
            this._element.find('> div.content').append($drop);
            this._drop = new DropModalView($drop);
        },

        /**
         * _drawHourglass
         * 
         * @access  protected
         * @return  void
         */
        _drawHourglass: function() {
            var $hourglass = DataUtils.render('Hourglass');
            this._element.append($hourglass);
            this._hourglass = new HourglassView($hourglass);
        },

        /**
         * getApplicableDropzone
         * 
         * @access  public
         * @param   undefined|Boolean includeFontsDropzone (default: true)
         * @return  DropzoneView
         */
        getApplicableDropzone: function(includeFontsDropzone) {
            includeFontsDropzone = DataUtils.getDefaultValue(
                includeFontsDropzone,
                true
            );
            if (
                includeFontsDropzone === true
                && App.getStage().fontsDropzoneVisible() === true
            ) {
                return Toolbars.getToolbar('text').getFontsDropdown().getDropzone();
            }
            if (App.getEditor().getActiveArea() !== undefined) {
                if (App.getEditor().getActiveArea().getType() === 'watermarks') {
                    return App.getEditor().getArea('watermarks').getDropzone();
                }
            }
            return App.getEditor().getArea('uploads').getDropzone();
        },

        /**
         * _preloadAccountOnboardingImages
         * 
         * @access  protected
         * @return  void
         */
        _preloadAccountOnboardingImages: function() {
            var account = Stencil.account(),
                jitOnboarding = account.setting('jitOnboarding');
            jitOnboarding = JSON.parse(jitOnboarding);
            if (
                jitOnboarding.backgroundSelected === undefined
                && jitOnboarding.foregroundSelected === undefined
            ) {
                var assets = [
                    (window.STATIC) + '/app/static/images/backgrounds/onboarding/backgroundSelected.jpg',
                    (window.STATIC) + '/app/static/images/backgrounds/onboarding/foregroundSelected.jpg'
                ];
                Images.preload(assets);
            }
        },

        /**
         * _preloadStencilIconFont
         * 
         * @access  protected
         * @return  void
         */
        _preloadStencilIconFont: function() {
            var $regular = $('<div class="sif sif-cloud-up"></div>'),
                $thick = $('<div class="sift sift-cloud-up"></div>');
            $regular.css({
                'position': 'absolute',
                'top': '-100000px',
                'left': '-100000px'
            });
            $thick.css({
                'position': 'absolute',
                'top': '-100000px',
                'left': '-100000px'
            });
            this._element.append($regular);
            this._element.append($thick);
            (function() {
                $regular.remove();
                $thick.remove();
            }).delay(5 * 1000);
        },

        /**
         * _preloadVerifoneAssets
         * 
         * @access  protected
         * @return  void
         */
        _preloadVerifoneAssets: function() {
            var partnerSource = Stencil.account().setting('partnerSource');
            if (partnerSource === 'verifone') {
                var assets = [
                    (window.STATIC) + '/app/static/images/icons/verifone.png'
                ];
                Images.preload(assets);
            }
        },

        /**
         * _reInitFabricDevicePixelRatioSetting
         * 
         * Firefox has a pretty big bug whereby the devicePixelRatio is
         * undefined while an iframe is hidden. This causes issues with the
         * Firefox extension and Publisher embed because the global
         * fabric.devicePixelRatio is defined initially when the fabric library
         * is loaded. As a result, when the iframe is loaded, it gets
         * invalidally set to 1. To deal with this, I reset the devicePixelRatio
         * for the library when the app is setup, since at that point, the
         * iframe is visible.
         * 
         * @access  protected
         * @return  void
         */
        _reInitFabricDevicePixelRatioSetting: function() {
            fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                fabric.window.webkitDevicePixelRatio ||
                fabric.window.mozDevicePixelRatio ||
                1;
        },

        /**
         * _setupAdminKeyboardShortcuts
         * 
         * @access  protected
         * @return  void
         */
        _setupAdminKeyboardShortcuts: function() {

            /**
             * Admin navigation keyboard shortcuts
             * 
             */
            var bindingFunction = function() {

                /**
                 * Area navigation
                 * 
                 */
                var combos = ['1', '2', '3', '4', '5', '6', '7'];
                Mousetrap.bind(combos, function(event, combo) {
                    event.preventDefault();
                    var sidebar = App.getSidebar(),
                        path = $(sidebar.find('[area]').get(combo.toInt() - 1)).attr('href');
                    Stencil.navigate(path);
                    return false;
                });

                /**
                 * Favorites category
                 * 
                 */
                Mousetrap.bind('f', function(event, combo) {
                    event.preventDefault();
                    var area = App.getEditor().getActiveArea();
                    if (area !== undefined) {
                        if (area.canHaveCollections() === true) {
                            var type = area.getType(),
                                category = Categories.account.favorites(type),
                                path = category.getPath();
                            Stencil.navigate(path);
                            return false;
                        }
                    }
                });

                /**
                 * Admin area
                 * 
                 */
                Mousetrap.bind(['a', 'd'], function(event, combo) {
                    event.preventDefault();
                    var path = '/app/admin/dashboard';
                    Stencil.navigate(path);
                    return false;
                });

                /**
                 * Users
                 * 
                 */
                // Mousetrap.bind('u', function(event, combo) {
                //     event.preventDefault();
                //     Stencil.navigate('/app/admin/users');
                //     return false;
                // });

                /**
                 * User search
                 * 
                 */
                Mousetrap.bind('u', function(event, combo) {
                    event.preventDefault();
                    var path = '/app/admin/users/search';
                    Stencil.navigate(path);
                    return false;
                });
            };
            if (User.admin() === true) {
                bindingFunction();
            } else {
                User.once({
                    'login': function(event, user) {
                        if (User.admin() === true) {
                            bindingFunction();
                        }
                    }
                });
            }
        },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            var _this = this;
            if (User.admin() === true) {
                var email = Stencil.get('user').get('email');
                this._element.addClass('admin');
                this._element.attr('data-user-email', email);
            } else if (User.editor() === true) {
                var email = Stencil.get('user').get('email');
                this._element.addClass('editor');
                this._element.attr('data-user-email', email);
            } else {
                User.once({
                    'login': function(event, user) {
                        if (User.admin() === true) {
                            var email = Stencil.get('user').get('email');
                            _this._element.addClass('admin');
                            _this._element.attr('data-user-email', email);
                        } else if (User.editor() === true) {
                            var email = Stencil.get('user').get('email');
                            _this._element.addClass('editor');
                            _this._element.attr('data-user-email', email);
                        }
                    }
                });
            }
        },

        /**
         * _setupBusyModal
         * 
         * @access  protected
         * @return  void
         */
        _setupBusyModal: function() {
            var $busy = this.find('> div.content > div.modal.busy');
            this._busy = new BusyModalView($busy);
        },

        /**
         * _setupCookieCheck
         * 
         * @access  protected
         * @return  void
         */
        _setupCookieCheck: function() {
            (function() {
                var session = Cookies.get('session');
                if (session === undefined) {
                    Stencil.alert('cookies.cleared');
                    Stencil.kill();
                } else {
                    // var account = Cookies.get('account');
                    // if (account === undefined) {
                    //     Stencil.alert('cookies.missingAccountKey');
                    //     Stencil.kill();
                    // }
                }
            }).interval(250);
        },

        /**
         * _setupEditor
         * 
         * @access  protected
         * @return  void
         */
        _setupEditor: function() {
            var $editor = this.find('section.editor');
            this._editor = new EditorView($editor);
        },

        /**
         * _setupEmergency
         * 
         * @access  protected
         * @return  void
         */
        _setupEmergency: function() {
            var emergency = Config.get('emergency'),
                markup = '<div class="emergency">' +
                        '<div class="message"></div>' +
                        '<div class="close fa fa-close"></div>' +
                    '</div>',
                $element = $(markup);
            $element.find('.message').text(emergency.message);
            if (emergency.active === true) {
                this._element.prepend($element);
                $element.find('.close').one({
                    'click': function(event, $div) {
                        $element.remove();
                    }
                });
            }
        },

        /**
         * _setupHelpScoutHide
         * 
         * @access  protected
         * @return  void
         */
        _setupHelpScoutHide: function() {
            this._element.on({
                'click': function(event) {
                    if ('window.HS.beacon.close'.validMethod() === true) {
                        window.HS.beacon.close();
                    }
                }
            });
        },

        /**
         * _setupHide
         * 
         * @access  protected
         * @return  void
         */
        _setupHide: function() {
            this.on({
                'hide': this.hide.proxy(this)
            });
        },

        /**
         * _setupOrientationModal
         * 
         * @access  protected
         * @return  void
         */
        _setupOrientationModal: function() {
            var check = function() {
                if (UserAgent.getOrientation() === 'portrait') {
                    Stencil.navigate('/app/orientation?clean=1');
                } else {
                    var modal = Modals.get('Orientation');
                    if (modal) {
                        modal.triggerHandler('leave');
                    }
                }
            };
            window.addEventListener('orientationchange', check, false);
        },

        /**
         * _setupPartnerSource
         * 
         * @access  protected
         * @return  void
         */
        _setupPartnerSource: function() {
            var account = Stencil.account();
            if (account.setting('partnerSource') === 'verifone') {
                this._element.attr('partner', 'verifone');
            } else {
                User.once({
                    'login': function(event, user) {
                        if (account.setting('partnerSource') === 'verifone') {
                            App.getElement().attr('partner', 'verifone');
                        }
                    }
                });
            }
        },

        /**
         * _setupPasteListener
         * 
         * @access  protected
         * @return  void
         */
        _setupPasteListener: function() {
            if (UserAgent.supports.file() === true) {
                var _this = this;
                $(document).on({
                    'custom/paste/images': function(event, blobs) {
                        var dropzone = _this.getApplicableDropzone(false);
                        if (dropzone.availableForUpload() === true) {
                            if (dropzone.toString() === 'WatermarksDropzoneView') {
                                Stencil.navigate('/app/logos');
                            } else {
                                Stencil.navigate('/app/uploads');
                            }
                            dropzone.receive(blobs);
                        }
                    }
                });
            }
        },

        /**
         * _setupSelectAllListener
         * 
         * @access  protected
         * @return  void
         */
        _setupSelectAllListener: function() {

            /**
             * selectAll
             * 
             * @note    Check for activeArea is done, since it's possible that in
             *          certain states (eg. /login flow), no area has been set as
             *          active.
             * @access  private
             * @param   jQuery event
             * @return  void
             */
            var selectAll = function() {
                    var activeArea = App.getEditor().getActiveArea();
                    if (activeArea !== undefined) {
                        var results = activeArea.getActiveGroup().getActiveResults();
                        results.selectAll();
                    }
                },
                /**
                 * deselectAll
                 * 
                 * @note    I check for an active area in the below routing event for
                 *          cases whereby a navigation event happens without any area
                 *          having been set up. eg. https://i.imgur.com/txNe9mB.png
                 * @access  private
                 * @return  void
                 */
                deselectAll = function() {
                    var activeArea = App.getEditor().getActiveArea();
                    if (activeArea !== undefined) {
                        var results = activeArea.getActiveGroup().getActiveResults();
                        results.deselectAll();
                        activeArea.getContextMenu().triggerHandler('close');
                    }
                };

            // Deselect everything if a navigation event occurs
            Stencil.getRouter().on({
                'route': function() {
                    deselectAll();
                }
            });

            // Keyboard shortcuts for Windows + Mac for select/deselect all
            var commands = {
                selectAll: 'ctrl+a',
                deselectAll: 'ctrl+shift+a'
            };
            if (UserAgent.is.mac() === true) {
                commands = {
                    selectAll: 'command+a',
                    deselectAll: 'command+shift+a'
                };
            }
            Mousetrap.bind(commands.selectAll, function(event, combo) {
                event.preventDefault();
                selectAll();
                return false;
            });
            Mousetrap.bind(commands.deselectAll, function(event, combo) {
                event.preventDefault();
                deselectAll();
                return false;
            });

            // Deselect everything if valid click occurs
            App.getElement().on({
                'click': function(event) {
                    var $target = $(event.target),
                        selectors = [
                            'div.thumb',
                            'div.quote.row',
                            'div.watermark',
                            'div.contextMenu'
                        ],
                        selector = selectors.join(',');
                    if (
                        $target.parents(selector).length === 0
                        && $target.is(selector) === false
                        && $target.parents('.modal.confirm').length === 0
                    ) {
                        if ($target.hasClass('contextMenu') === false) {
                            if (App.getBusy().getElement().hasClass('hidden') === true) {
                                var activeArea = App.getEditor().getActiveArea();
                                if (activeArea !== undefined) {
                                    var contextMenu = activeArea.getContextMenu();
                                    if (contextMenu.closable() === true) {
                                        deselectAll();
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // Deselect everything if valid escape key occurs
            App.getElement().on({
                'keydown': function(event) {
                    var deselectable = function(event) {
                        if (event.which !== 27) {
                            return false;
                        }
                        if (App.find('.modal.busy:not(.hidden)').length !== 0) {
                            return false;
                        }
                        if (App.find('.modal.confirm').length !== 0) {
                            return false;
                        }
                        if (App.find('.contextMenu:not(.hidden)').length !== 0) {
                            return false;
                        }
                        return true;
                    };
                    if (deselectable(event) === true) {
                        deselectAll();
                    }
                }
            });
        },

        /**
         * _setupSidebar
         * 
         * @access  protected
         * @return  void
         */
        _setupSidebar: function() {
            var $sidebar = this.find('aside.sidebar');
            this._sidebar = new SidebarView($sidebar);
        },

        /**
         * _setupStage
         * 
         * @access  protected
         * @return  void
         */
        _setupStage: function() {
            var $stage = this.find('section.stage'),
                view = new StageView($stage);
            this._stage = view;
        },

        /**
         * _setupTooltipHiding
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltipHiding: function() {
            var router = Stencil.getRouter();
            router.on({
                'route': function() {
                    App.tooltips.hide();
                }
            });
        },

        /**
         * _setupUnload
         * 
         * @todo    Stencil.kill? Not sure if possible
         * @access  protected
         * @return  void
         */
        _setupUnload: function() {
            $(window).bind({
                'beforeunload': function(event) {
                    if (XHRPool.length() > 0) {
                        return 'Still saving!';
                    }
                }
            });
        },

        /**
         * _showNewBadge
         * 
         * @access  protected
         * @return  void
         */
        _showNewBadge: function() {
            if (Stencil.account().get('created').toInt() <= 1500685200) {
                var $badge = this.find('a[href="/app/uploads"] span.full span.badge');
                $badge.removeClass('invisible');
            } else {
                User.once({
                    'login': this._showNewBadge.proxy(this)
                });
            }
        },

        // /**
        //  * busy
        //  * 
        //  * @access  public
        //  * @param   String type
        //  * @return  void
        //  */
        // busy: function(type) {
        //     if (type === 'popup') {
        //         var msg = 'If a window does not popup, please check that it ' +
        //             'was<br />not blocked by your browser or popup-blocker.';
        //         App.getBusy().show(msg);
        //     }
        // },

        /**
         * hide
         * 
         * @access  protected
         * @return  void
         */
        hide: function() {
            var slide = Config.default('slide');
            this.slide.up.apply(this);
            Stencil.postMessage.delay(
                slide,
                Stencil,
                ['message.app.hide']
            );
        },

        /**
         * getEditor
         * 
         * @access  public
         * @return  EditorView
         */
        getEditor: function() {
            return this._editor;
        },

        /**
         * getHourglass
         * 
         * @access  public
         * @return  HourglassView
         */
        getHourglass: function() {
            return this._hourglass;
        },

        /**
         * getSidebar
         * 
         * @access  public
         * @return  SidebarView
         */
        getSidebar: function() {
            return this._sidebar;
        },

        /**
         * getStage
         * 
         * @access  public
         * @return  StageView
         */
        getStage: function() {
            return this._stage;
        },

        /**
         * getX
         * 
         * @access  public
         * @return  Number
         */
        getX: function() {
            return this._last.x;
        },

        /**
         * getY
         * 
         * @access  public
         * @return  Number
         */
        getY: function() {
            return this._last.y;
        },

        /**
         * preloadShareModalStaticAssets
         * 
         * @access  public
         * @return  void
         */
        preloadShareModalStaticAssets: function() {
            var key = 'shareModalStaticAssetsPreloaded',
                preloaded = Stencil.get(key);
            if (preloaded === undefined) {
                Stencil.set(key, true);
                var assets = [
                    '/app/static/images/backgrounds/phone.header.v2.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/chevron.down.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/globe.png',
                    '/app/static/images/backgrounds/previews/mobile/facebook/footer.png',
                    '/app/static/images/backgrounds/previews/mobile/instagram/footer.png',
                    '/app/static/images/backgrounds/previews/mobile/pinterest/header.png',
                    '/app/static/images/icons/buffer.png',
                    '/app/static/vendors/source/external/intl-tel-input/v6.2.1/img/flags@2x.png'
                ];
                var account = Stencil.account();
                if (account.setting('partnerSource') === 'verifone') {
                    var verifoneAssets = [
                        '/app/static/images/backgrounds/verifone/masks/carbon8.jpg',
                        '/app/static/images/backgrounds/verifone/masks/vx.jpg',
                        '/app/static/images/icons/verifone.png'
                    ];
                    assets = assets.concat(verifoneAssets);
                }
                for (var index in assets) {
                    new Image().src = (window.STATIC) + (assets[index]);
                }
            }
        },

        /**
         * setSelectedFrame
         * 
         * Sets the frame accessor that should be accessible via the global
         * window.Frame reference. Also updates the UI surrounding the canvas to
         * reference the selected frame (such as the dimensions copy and label
         * underneath the preview canvas).
         * 
         * @access  public
         * @return  void
         */
        setSelectedFrame: function() {
            var account = Stencil.account(),
                draft = account.draft(),
                orphan = account.orphanFrame(),
                key = draft.get('frame'),
                frame = account.collection('frames').find(key);
            if (frame === false) {
                frame = orphan;
                orphan.set({
                    width: draft.get('width').toInt(),
                    height: draft.get('height').toInt()
                });
            } else {
                if (
                    frame.get('width').toInt() !== draft.get('width').toInt()
                    || frame.get('height').toInt() !== draft.get('height').toInt()
                ) {
                    frame = orphan;
                    orphan.set({
                        width: draft.get('width').toInt(),
                        height: draft.get('height').toInt()
                    });
                }
            }
            frame.select();
            frame.updateMessaging();
        },

        /**
         * show
         * 
         * @access  protected
         * @return  void
         */
        show: function() {
            this.slide.down.apply(this);
            // Stencil.postMessage.delay(
            //     750,
            //     Stencil,
            //     ['message.app.opened']
            // );
        },

        /**
         * slide
         * 
         * @var     Object
         * @access  public
         */
        slide: {

            /**
             * down
             * 
             * @access  public
             * @return  void
             */
            down: function() {
                this._element.addClass('down');
            },

            /**
             * up
             * 
             * @access  public
             * @return  void
             */
            up: function() {
                this._element.removeClass('down');
            }
        },

        /**
         * tooltips
         * 
         * @var     Object
         * @access  public
         */
        tooltips: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                App.find('[tooltip]').tooltip('destroy');
            }
        },

        /**
         * unrestrict
         * 
         * @note    This is the function that upon initial page load, removes the
         *          busy modal. Look here, Oliver, look here!
         * @access  public
         * @return  void
         */
        unrestrict: function() {
            // var current = new Date.getTime();
            // if ((current - start) > this._thresholds.unrestrict) {
                this._busy.hide();
            // } else {
            //     this.unrestrict.delay(50, this);
            // }
        },

        /**
         * waitFor
         * 
         * Waits for a specific script to load by showing a busy modal with a
         * message, and once loaded, hides it. Also contains logic incase the
         * script doesn't load after X seconds. If that occurs, simply show an
         * alert and unbind the callback.
         * 
         * @access  public
         * @param   String script
         * @return  void
         */
        waitFor: function(script) {
            var msg = Stencil.getMessage('dependency.pending'),
                timeout,
                callback = function() {
                    TimeoutPool.clear(timeout);
                    App.getBusy().hide();
                },
                listener = 'script/' + (script) + '/loaded';
            timeout = (function() {
                Stencil.alert('dependency.failed');
                Stencil.kill();
                Stencil.unbind(listener, callback);
            }).delay(this._maxScriptWaitMilliseconds);
            App.getBusy().show(msg);
            Stencil.once(listener, callback);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * NotificationsSettingsView
     * 
     * @extends SettingsView
     */
    window.NotificationsSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'NotificationsSettingsView')
         */
        _string: 'NotificationsSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'notifications')
         */
        _type: 'notifications',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(100);
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                },
                /**
                 * 
                 * @note    setting notification below is to trigger a User::change
                 *          event, which inits an analytics tracking call
                 */
                'returned/succeeded': function(event, response) {
                    Track.event('Notifications settings updated');
                    var user = Stencil.get('user'),
                        notification = response.data.object.notification;
                    user.set({'notification': notification});
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * ObfuscateSettingsView
     * 
     * @extends SettingsView
     */
    window.ObfuscateSettingsView = SettingsView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ObfuscateSettingsView')
         */
        _string: 'ObfuscateSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'obfuscate')
         */
        _type: 'obfuscate',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._addListeners();
        },

        /**
         * _addListeners
         * 
         * @access  protected
         * @return  void
         */
        _addListeners: function() {
            this.on({
                'showConfirmObfuscateModal': function(event) {
                    var modal = Modals.showConfirm({
                        h1: 'This will permanently delete your account.',
                        h2: 'This cannot be undone'
                    });
                    modal.on({
                        'no': function(event) {
                            this.triggerHandler('leave');
                        },
                        'yes': function(event) {
                            this.triggerHandler('leave');
                            var alertKeys = {
                                failed: {
                                    other: 'users.obfuscate.failed.other',
                                    subscription: 'users.obfuscate.failed.subscription'
                                },
                                success: 'users.obfuscate.success'
                            }
                            if (
                                Account.upgraded() === true
                                && Account.lifetime() === false
                            ) {
                                Stencil.alert(alertKeys.failed.subscription);
                            } else if (User.admin() === true || User.editor() === true) {
                                Stencil.alert(alertKeys.failed.other);
                            } else {
                                var msg = Stencil.getMessage('users.settings.obfuscate');
                                App.getBusy().show(msg);
                                var path = '/users/settings/obfuscate';
                                Stencil.ajax({
                                    signature: {file: 'Obfuscate', line: 69},
                                    url: path,
                                    type: 'POST',
                                    success: function(response) {
                                        if (response.success === true) {
                                            (function() {
                                                Stencil.alert(alertKeys.success);
                                                Stencil.kill();
                                            }).delay(2500);
                                        } else {
                                            var error = Stencil.extractError(response),
                                                code = 'd67-' + (error.code),
                                                reference = error.reference;
                                            Stencil.error(code, reference);
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * PasswordSettingsView
     * 
     * @extends SettingsView
     */
    window.PasswordSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PasswordSettingsView')
         */
        _string: 'PasswordSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'password')
         */
        _type: 'password',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Password changed');
                    this.find('input').val('');
                }
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * PaymentSettingsView
     * 
     * @events  show/history
     * @extends SettingsView
     */
    window.PaymentSettingsView = SettingsView.extend({

        /**
         * _events
         * 
         * @access  protected
         * @var     Object
         */
        _events: {

            /**
             * detect
             * 
             * @access  private
             * @param   jQuery event
             * @param   jQuery $input
             * @return  void
             */
            detect: function(event, $input) {
                var $wrapper = this.find('div.cards'),
                    $imgs = $wrapper.find('img');
                if ($input.hasClass('identified') === true) {
                    $imgs.addClass('faded');
                    if ($input.hasClass('visa') === true) {
                        $wrapper.find('.visa').removeClass('faded');
                    } else if ($input.hasClass('mastercard') === true) {
                        $wrapper.find('.mastercard').removeClass('faded');
                    } else if ($input.hasClass('amex') === true) {
                        $wrapper.find('.amex').removeClass('faded');
                    } else {
                        $wrapper.find('.unknown').removeClass('faded');
                    }
                } else {
                    $imgs.removeClass('faded');
                }
            }
        },

        /**
         * _form
         * 
         * @access  protected
         * @var     null|CreditCardAppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                keyup: {
                    '[data-stripe="number"]': this._events.detect
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PaymentSettingsView')
         */
        _string: 'PaymentSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'payment')
         */
        _type: 'payment',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('accountDock');
            this._form = new CreditCardAppFormView(this.find('form'));
            this._form.unbind('returned/failed');
            this._form.on({
                'returned/failed': function(event, response) {
                    this.find('a.button').enable();
                    if (response.failedRules) {
                        var error = this.getError(response);
                        this.showError(error);
                    } else {
                        this.showError(response.error);
                    }
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Payment settings updated');
                    var account = Stencil.account(),
                        customer = account.upgrade().customer();
                    customer.set({
                        delinquent: 0
                    });
                }
            });
            this._form.setTimeout(0);
            this._form.setAcceptableCards([
                'Visa',
                'MasterCard',
                'American Express'
            ]);

            // History
            this.on({
                'show/history': function(event) {
                    if (Scripts.loaded('accountDock') === false) {
                        App.waitFor('accountDock');
                    } else {
                        if (UserAgent.extension() === true) {
                            Stencil.alert('accountDock.extension.disabled');
                        } else {
                            if ('AccountDock.configure'.validMethod() === true) {
                                var key = Stencil.account().upgrade().customer().get(
                                        'gatewayKey'
                                    ),
                                    handler = AccountDock.configure({
                                        customer: key
                                    });
                                handler.open({
                                    container: 'window'
                                });
                            }
                        }
                    }
                }
            });

            // Pausing/unpausing
            this._form.on({
                'card/submitted': modal.pause.proxy(modal),
                'card/returned': modal.unpause.proxy(modal),
                'submitted': modal.pause.proxy(modal),
                'returned': modal.unpause.proxy(modal)
            });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * PlanSettingsView
     * 
     * @extends SettingsView
     */
    window.PlanSettingsView = SettingsView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PlanSettingsView')
         */
        _string: 'PlanSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'plan')
         */
        _type: 'plan',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * ProfileSettingsView
     * 
     * @extends SettingsView
     */
    window.ProfileSettingsView = SettingsView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ProfileSettingsView')
         */
        _string: 'ProfileSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'profile')
         */
        _type: 'profile',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    modal.pause();
                },
                'returned': function(event) {
                    modal.unpause();
                },
                'returned/succeeded': function(event, response) {
                    Track.event('Profile settings updated');
                    var user = Stencil.get('user');
                    user.set({
                        email: response.data.object.email,
                        name: response.data.object.name
                    });
                }
            });
            // ElectronUtils.get('downloads.recent.path').then(function(value) {
            //     console.log('value: ' + value);
            // }).catch(function(err) {
            // });
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * ReferralSettingsView
     * 
     * @events  share/facebook
     *          share/twitter
     * @extends SettingsView
     */
    window.ReferralSettingsView = SettingsView.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                focus: {
                    'input': this.selectInput
                },
                keypress: {
                    'input': function(event) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ReferralSettingsView')
         */
        _string: 'ReferralSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'referral')
         */
        _type: 'referral',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this.on({
                'share/facebook': this.showFacebookShare,
                'share/twitter': this.showTwitterShare
            });
            Scripts.load('facebook');
        },

        /**
         * _getFacebookShareObject
         * 
         * @access  protected
         * @return  Object
         */
        _getFacebookShareObject: function() {
            var share = Config.get('shares')['referral.facebook'];
            return {
                display: 'popup',
                method: 'feed',
                name: share.title,
                description: share.description,
                link: this._getShareUrl(),
                picture: share.picture
            };
        },

        /**
         * _getShareUrl
         * 
         * @access  protected
         * @return  String
         */
        _getShareUrl: function() {
            return Stencil.account().getReferralUrl();
        },

        /**
         * _getSnippet
         * 
         * @access  protected
         * @return  String
         */
        _getSnippet: function() {
            return 'Check out Stencil, the easiest way to create amazing ' +
                'graphics for #socialmedia:';
        },

        /**
         * selectInput
         * 
         * @access  public
         * @return  void
         */
        selectInput: function() {
            var input = this.find('input');
            (function() {
                input.select();
            }).delay(0);
        },

        /**
         * showFacebookShare
         * 
         * @access  public
         * @return  void
         */
        showFacebookShare: function() {
            if (Scripts.loaded('facebook') === false) {
                App.waitFor('facebook');
            } else {
                FB.ui(
                    this._getFacebookShareObject(),
                    function(response) {
                    }
                );
            }
        },

        /**
         * showTwitterShare
         * 
         * @access  public
         * @return  void
         */
        showTwitterShare: function() {
            var share = Config.get('shares')['referral.twitter'],
                url = this._getShareUrl(),
                message = encodeURIComponent(share.message),
                link = 'https://twitter.com/intent/tweet' +
                    '?url=' + (url) +
                    '&via=' + (share.via) +
                    '&text=' + (message);
            window.open(
                link,
                'Twitter Share',
                'width=640, height=420'
            );
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * SettingsView
     * 
     * @extends View
     */
    window.SettingsView = View.extend({

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|SettingsModalView (default: null)
         */
        _modal: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SettingsView')
         */
        _string: 'SettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _type: null,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[settings="' + (this._type) + '"]');
            $anchor.siblings('[settings]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            if (UserAgent.is.tablet() === false) {
                this._element.focusable().focus();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('SettingsView', function() {

    /**
     * SocialSettingsView
     * 
     * @todo    Preload connection profile/images, incase they click on
     *          "View/edit"
     * @events  connect/facebook
     *          connect/twitter
     * @extends SettingsView
     */
    window.SocialSettingsView = SettingsView.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|Collection (default: null)
         */
        _collection: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SocialSettingsView')
         */
        _string: 'SocialSettingsView',

        /**
         * _type
         * 
         * @access  protected
         * @var     String (default: 'social')
         */
        _type: 'social',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   SettingsModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('facebook');
            this._setupCollection();
            this.refresh();
            this.on({
                'connect/facebook': function(event) {
                    if (Scripts.loaded('facebook') === false) {
                        App.waitFor('facebook');
                    } else {
                        this._showBusyModal();
                        // App.busy('popup');
                        var facebook = this._getModel('Facebook');
                        facebook.connect({
                            'connected': function(connections) {
                                App.getBusy().hide();
                            },
                            'denied': function() {
                                App.getBusy().hide();
                            }
                        });
                    }
                },
                'connect/twitter': function(event) {
                    this._showBusyModal();
                    // App.busy('popup');
                    var twitter = this._getModel('Twitter');
                    twitter.setup();
                    twitter.connect({
                        'closed': function(connections) {
                            App.getBusy().hide();
                        }
                    });
                }
            });
        },

        /**
         * _count
         * 
         * @access  protected
         * @param   String network
         * @return  void
         */
        _count: function(network) {
            var connections = this._collection.network(network),
                $network = this.find('[network="' + (network) + '"]'),
                $count,
                type,
                hash = {
                    facebook: {
                        account: 'page',
                        profile: 'profile'
                    },
                    twitter: {
                        profile: 'account'
                    }
                },
                copy,
                matching,
                $counts = $network.find('[lookup="count"]');
            jQuery.each($counts, function(index, count) {
                matching = [];
                $count = $(count);
                type = $count.attr('type');
                jQuery.each(connections, function(index, connection) {
                    if (connection.get('type') === type) {
                        matching.push(connection);
                    }
                });
                copy = (matching.length) + ' ' +
                    (matching.length === 1 ? hash[network][type] : (hash[network][type] + 's'));
                $count.text(copy);
            });
        },

        /**
         * _setupCollection
         * 
         * @access  protected
         * @return  void
         */
        _setupCollection: function() {
            var _this = this;
            this._collection = Stencil.account().collection('connections');
            this._collection.on({
                'update': function(event) {
                    _this.refresh();
                }
            });
        },

        /**
         * _show
         * 
         * @access  protected
         * @param   String network
         * @return  void
         */
        _show: function(network) {
            var connections = this._collection.network(network),
                $network = this.find('[network="' + (network) + '"]');
            $network.find('.prompt').addClass('hidden');
            $network.find('.details').addClass('hidden');
            if (connections.length === 0) {
                $network.find('.prompt').removeClass('hidden');
            } else {
                $network.find('.details').removeClass('hidden');
            }
        },

        /**
         * _showBusyModal
         * 
         * @access  protected
         * @return  void
         */
        _showBusyModal: function() {
            var exception = 'A window should have popped up. If you can\'t ' +
                'see it, it may appear behind this browser window, or on ' +
                'another monitor if you have one attached.<br />' +
                'If you cannot find it, ' +
                '<a click trigger="hide" class="text">go back to Stencil</a>.';
            App.getBusy().show(undefined, exception);
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            this._show('facebook');
            this._count('facebook');
            this._show('twitter');
            this._count('twitter');
            this._show('pinterest');
            this._count('pinterest');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * BufferShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.BufferShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'buffer')
         */
        _network: 'buffer',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BufferShareView')
         */
        _string: 'BufferShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
            this.on({
                'open': this.open
            });
        },

        /**
         * _getShareUrl
         * 
         * @access  protected
         * @return  String
         */
        _getShareUrl: function() {
            return '';
        },

        /**
         * _position
         * 
         * Ensures that the required <img> has a width by loading the same image
         * it is, and then onload, setting the left margin.
         * 
         * @access  protected
         * @return  void
         */
        _position: function() {
            var _this = this,
                image = new Image();
            image.onload = function() {
                var img = _this.find('img:not(.shadow)'),
                    width = img.css('width').toInt();
                _this.find('.shadow').css(
                    'margin-left',
                    0 - Math.round(width / 2)
                );
            };
            image.src = this._modal.getImage().getSrc();
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access  public
         * @return  void
         */
        drawImage: function() {
            if (this._drawn === false) {

                // Done
                this._drawn = true;

                // Regular
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    selector = '[lookup="draw"]',
                    $first = $('<img />'),
                    $second = $('<img />');
                $first.attr('src', src);
                $first.attr('draggable', false);
                this.find(selector).replaceWith($first);

                // Shadow
                selector = '[lookup="draw.shadow"]';
                $second.attr('src', src);
                $second.attr('draggable', false);
                $second.addClass('shadow');
                this.find(selector).replaceWith($second);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    this._getImage().once({
                        'preload': function(event) {
                            // var height = $first.css('height').toInt();
                            $first.attr('src', this.getSrc());
                            // $first.css('height', height);
                            $second.attr('src', this.getSrc());
                            // $second.css('height', height);
                        }
                    });
                }
            }
        },

        /**
         * open
         * 
         * @note    Buffer breaks if I don't pass in a url parameter, so I
         *          override the NetworkShareView _getShareUrl method to return
         *          an empty string.
         * @note    I don't truncate, since Buffer offers it's own UI and UX to
         *          truncate the string. It's better for them to do it there,
         *          since the different networks off different degrees of
         *          truncation.
         * @access  public
         * @return  void
         */
        open: function() {
            var image = this._getImage();
            if (image.get('uploaded').toInt() === 1) {
                var snippetObject = this._getSnippet(false),
                    url = encodeURIComponent(this._getShareUrl()),
                    picture = encodeURIComponent(this._getOriginalImageUrl()),
                    text = encodeURIComponent(snippetObject.snippet),
                    link = 'https://buffer.com/add' +
                        '?url=' + (url) +
                        '&picture=' + (picture);
                if (snippetObject.default === false) {
                    link += '&text=' + (text);
                }
                window.open(
                    link,
                    'Buffer Share',
                    'width=900, height=840'
                );
            } else {
                var msg = Stencil.getMessage('image.share.pending');
                App.getBusy().show(msg);
                image.once({
                    'change/uploaded': function(event) {
                        App.getBusy().hide();
                        Stencil.alert('image.uploaded');
                    }
                });
            }
        },

        /**
         * show
         * 
         * Duplicated here only to prevent calling drawImage with a parameter
         * since BufferShareView doesn't require one. Also, the <_position> call
         * is needed for Buffer.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._position();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * FacebookShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.FacebookShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $textarea
                     * @return  void
                     */
                    'textarea': function(event, $textarea) {
                        var $message = this.find('[lookup="message"]'),
                            message = $textarea.val();
                        this.setMessage(message);
                        this.triggerHandler('change/message');
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'facebook')
         */
        _network: 'facebook',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FacebookShareView')
         */
        _string: 'FacebookShareView',

        /**
         * _thresholds
         * 
         * @access  protected
         * @var     Object
         */
        _thresholds: {
            search: 15
        },

        /**
         * init
         * 
         * @todo!!  Instead of having image-uploaded property checked on backend,
         *          check it here, and if it is not yet uploaded, wait for it
         *          (via event listener), and then submit form.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            Scripts.load('facebook');
            this.on({
                'connection/add': function(event) {
                    if (Scripts.loaded('facebook') === false) {
                        App.waitFor('facebook');
                    } else {
                        this._showBusyModal();
                        var _this = this,
                            model = this._getModel('Facebook');
                        model.connect({
                            connected: function(connections) {
                                App.getBusy().hide();
                                _this.state('connections');
                            },
                            denied: function(connections) {
                                App.getBusy().hide();
                            }
                        });
                    }
                }
            });
            this._setupForm();
            this.preview('desktop', false);

            // State
            if (this._connections().length === 0) {
                this.state('connect');
            } else {
                this.state('connections');
            }
        },

        /**
         * _connections
         * 
         * Returns all connections for Facebook, or else Facebook connections by
         * type (eg. page, profile).
         * 
         * @access  protected
         * @param   String type
         * @return  Array
         */
        _connections: function(type) {
            var connections = this._super(),
                matching = [];
            if (type === undefined) {
                return connections;
            }
            jQuery.each(connections, function(index, connection) {
                if (connection.get('type') === type) {
                    matching.push(connection);
                }
            });
            return matching;
        },

        /**
         * _drawConnections
         * 
         * @access  protected
         * @return  void
         */
        _drawConnections: function() {
            var connections = this._connections(),
                $connections;
            $connections = DataUtils.render('FacebookConnections', {
                live: connections.length > this._thresholds.search,
                connections: {
                    profiles: this._connections('profile'),
                    pages: this._connections('account')
                }
            });
            this.find('div.selector').append($connections);
        },

        /**
         * _initConnections
         * 
         * Creates the initial <selectpicker>, and listens for value changes
         * to have the preview update or prompt them to connect more accounts.
         * 
         * @access  protected
         * @return  void
         */
        _initConnections: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.update();
                    _this.find('textarea').focus();
                    if ($(this).val().toInt() === 0) {
                        _this.triggerHandler('connection/add');
                        _this.find('textarea').blur();
                        _this._setupConnections();
                    } else {
                        var userAccount = Stencil.account().userAccount();
                        userAccount.push(
                            'settings.shareFacebookRecent',
                            $(this).val()
                        );
                    }
                }
            );
        },

        /**
         * _preselectConnection
         * 
         * Looks up which connection should be preselected, based on a possible
         * cookie value.
         * 
         * @todo    Ensure preselected is cookied
         * @access  protected
         * @return  void
         */
        _preselectConnection: function() {
            var $select = this.find('select'),
                share = Stencil.account().userAccount().setting('shareFacebookRecent'),
                first = $select.find('option').first().val(),
                preselected = share.match(/^cnnc/) === null ? first : share;
            $select.val(preselected);
        },

        /**
         * _removeConnections
         * 
         * @access  protected
         * @return  void
         */
        _removeConnections: function() {
            var $selector = this.find('div.selector');
            $selector.empty();
        },

        /**
         * _setupConnections
         * 
         * @access  protected
         * @return  void
         */
        _setupConnections: function() {
            this._removeConnections();
            this._drawConnections();
            this._preselectConnection();
            this._initConnections();
            this.update();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            this._form.on({
                'submitted': function(event) {
                    _this._modal.pause();
                },
                'returned': function(event) {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {
                    if (response.data && response.data.connection) {
                        if (response.data.action === 'delete') {
                            var key = response.data.connection.key;
                            Stencil.getAccessor(key).delete();
                            if (_this._connections().length === 0) {
                                _this.state('connect');
                            } else {
                                _this.state('connections');
                            }

                            // Error handling
                            this.clearErrors();
                            var image = _this._getImage(),
                                path = '/app/images/' + (image.get('key')) +
                                    '/' + (key) + '/error?clean=1';
                            Stencil.navigate(path);
                        }
                    }
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Share'),
                        share = model.setAccessor(response.data.object);
                    Stencil.navigate(share.getPath());
                }
            });
        },

        /**
         * setMessage
         * 
         * @see     https://stackoverflow.com/questions/5002111/javascript-how-to-strip-html-tags-from-string
         * @note    Added the .textContent / .innerText logic to prevent people
         *          from pasting in markup that may include script tags. This
         *          logic simply strips out the html tags. But I don't think I
         *          actually want this. So instead, simply replacing open and
         *          close html tags to prevent tags from being rendered.
         * @todo    Match truncation for links in Facebook preview:
         *          https://i.imgur.com/WDJDlvy.png
         * @access  public
         * @param   String message
         * @return  void
         */
        setMessage: function(message) {
            var $message = this.find('[lookup="message"]');//,
                // div = document.createElement('div');
            // div.innerHTML = message;
            // message = (div.textContent || div.innerText || '');
            message = message.replace(/</g, '&lt;');
            message = message.replace(/>/g, '&gt;');
            message = message.replace(/^\n{1,}/g, '');
            message = message.encode('url');
            message = message.encode('hashtag', {
                href: 'https://www.facebook.com/hashtag/$hashtag'
            });
            message = message.replace(/\n{2,}/g, '\n');
            message = message.replace(/\n+$/, '');
            message = message.encode('newlines');
            $message.html(message);
        },

        /**
         * state
         * 
         * Show the proper state (eg. show connections w/ textarea, or button
         * prompting them to connect their FB account(s))
         * 
         * @access  public
         * @param   String state
         * @return  void
         */
        state: function(state) {
            this.find('.state').addClass('hidden');
            if (state === 'connect') {
                this.find('.state[lookup="connect"]').removeClass('hidden');
            } else {
                this._setupConnections();
                this.find('.state[lookup="connections"]').removeClass('hidden');
            }
        },

        /**
         * update
         * 
         * Updates the UI of the previews to have the corresponding name and
         * picture in there.
         * 
         * @todo    Preload all conncetion urls into memory for faster
         *          transitions between them
         * @access  public
         * @return  void
         */
        update: function() {

            // Get the selected connection
            var connections = Stencil.account().collection('connections'),
                $select = this.find('select'),
                value = $select.val(),
                selected = false;
            if (connections.find(value) !== false) {
                selected = connections.find(value);
            }

            // If a connection was found
            if (selected !== false) {
                var $names = this.find('[lookup="connection.label"]'),
                    $images = this.find('[lookup="connection.image"]');
                $names.text(selected.get('label'));
                $images.attr('src', selected.getImageSrc());
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * InstagramShareView
     * 
     * @extends NetworkShareView
     */
    window.InstagramShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $input
                     * @return  void
                     */
                    '[type="tel"]': function(event, $input) {
                        this.find('[name="data[number]"]').val(
                            $input.intlTelInput('getNumber')
                        );
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'instagram')
         */
        _network: 'instagram',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'InstagramShareView')
         */
        _string: 'InstagramShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupForm();
            this.preview('desktop', false);
            this._setupMobileInput();
        },

        /**
         * _getCountryDropdownDefaultCodes
         * 
         * @access  protected
         * @return  Array
         */
        _getCountryDropdownDefaultCodes: function() {
            var countryDropdownDefaults = Config.default('countryDropdownDefaults'),
                codes = [],
                index = 0;
            for (index; index < countryDropdownDefaults.length; index++) {
                codes.push(countryDropdownDefaults[index].code);
            }
            return codes;
        },

        /**
         * _setupMobileInput
         * 
         * @note    Originally I was performing a Stencil.alive check before the
         *          Geo lookup, but that resulted in two things:
         *          1) In areas with firewalls (eg. Turkey), the Stencil.alive
         *          check would result in always showing a connection error.
         *          2) I don't believe a connection needs to be checked for
         *          first. Simply make the call, and if it bails, the connection
         *          check will come in.
         * @todo!   Abstract utils.js to only be loaded if Instagram view is used
         * @access  protected
         * @return  void
         */
        _setupMobileInput: function() {

            // Input
            var $tel = this.find('input[type="tel"]');

            // GitHub Repo
            $tel.intlTelInput({
                // utilsScript: '/app/static/vendors/source/external/libphonenumber/v7.0.11/utils.js',
                defaultCountry: 'auto',
                preferredCountries: this._getCountryDropdownDefaultCodes(),
                geoIpLookup: function(callback) {
                    var fallback = function() {
                        var geo = Stencil.get('account').geo();
                        if (geo === false) {
                            callback('us');
                        } else {
                            var code = geo.country.code.toLowerCase();
                            if (code === '') {
                                callback('us');
                            } else {
                                callback(code);
                            }
                        }
                    };
                    Stencil.ajax({
                        excludeDefaultData: true,
                        signature: {file: 'Instagram', line: 122},
                        url: '/utils/geo/ipStack',
                        type: 'GET',
                        cache: true,
                        timeout: 2500,
                        success: function(response) {
                            if (response.success === true) {
                                var code = response.data.country.code.toLowerCase();
                                if (code === '') {
                                    callback('us');
                                } else {
                                    callback(code);
                                }
                            } else {
                                fallback();
                            }
                        },
                        error: fallback
                    });
                }
            });

            // Number set
            if (Stencil.account().userAccount().setting('shareMobile') !== '') {
                this.find('[name="data[number]"]').val(
                    $tel.intlTelInput('getNumber')
                );
            }
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'submitted': function(event) {
                    _this._modal.pause();
                    this._enabled = true;
                    if (
                        Account.max.sms() === true
                        && User.admin() === false
                        && User.editor() === false
                    ) {
                    // if (true) {//&& User.admin() === false) {
                        this._enabled = false;
                        if (Account.upgraded() === true) {
                            if (Account.plan('unlimited') === true) {
                                Stencil.alert('account.unlimited.limit.sms');
                            } else {
                                Stencil.navigate('/app/upgrade/unlimited/sms?clean=1&additive');
                            }
                        } else {
                            Stencil.navigate('/app/upgrade/pro/sms?clean=1&additive');
                        }
                        this.enable.delay(0, this);
                        _this._modal.unpause();
                        this.find('a.button').enable();
                        this.find('a.button').removeClass('busy');
                    }
                },
                'returned': function(event) {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {

                    /**
                     * Have to check for failed rules here because of an
                     * exception (as always) whereby if the country is not in
                     * the whitelist, we trigger an email to myself (Oliver),
                     * and send back a success = false value (but without any
                     * failed rules).
                     * 
                     * @see     https://i.imgur.com/oaJfBCz.png
                     */
                    if (
                        response.failedRules !== undefined
                        && response.failedRules[0]
                        && response.failedRules[0].validator[1] === 'validMobileNumber'
                    ) {
                        var image = _this._getImage(),
                            key = image.get('key'),
                            mobileNumber = _this.find('[name="data[number]"]').val(),
                            path = '/app/images/' + (key) + '/confirm/mobile/' + (mobileNumber) + '?clean';
                        Stencil.navigate(path);
                        var $callout = this.find('.callout.errors');
                        $callout.addClass('hidden');
                    } else {
                        this.setErrorMessage(response.message);
                    }
                },
                'returned/succeeded': function(event, response) {
                    var path = _this._modal.getImage().getSentPath();
                    Stencil.navigate(path);

                    // Track the messages sent this month and in total in memory
                    var account = Stencil.account(),
                        monthlySentSmsMessages = account.get('monthlySentSmsMessages'),
                        totalSentSmsMessages = account.get('totalSentSmsMessages');
                    account.set({
                        'monthlySentSmsMessages': monthlySentSmsMessages + 1,
                        'totalSentSmsMessages': totalSentSmsMessages + 1
                    });
                    account.syncRefillData(function(changed) {
                        if (changed === true) {
                            this.set({
                                monthlySavedImages: this.get('monthlySavedImages').toInt(),
                                monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt() + 1,
                                totalSentSmsMessages: this.get('totalSentSmsMessages').toInt() + 1
                            });
                        }
                        // this.save([
                        //     'monthlySentSmsMessages',
                        //     'totalSentSmsMessages'
                        // ]);
                    });

                    /**
                     * Set mobile in accessor (saved on the backend by this
                     * point).
                     */
                    var userAccount = account.userAccount();
                    userAccount.set({
                        'settings.shareMobile': response.data.mobile
                    });
                }
            });
        },

        /**
         * getForm
         * 
         * @access  public
         * @return  AppFormView
         */
        getForm: function() {
            return this._form;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * LinkShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.LinkShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {
                    'input': this.selectInput
                },
                focus: {
                    'input': this.selectInput
                },
                keypress: {
                    'input': function(event) {
                        event.preventDefault();
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'link')
         */
        _network: 'link',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'LinkShareView')
         */
        _string: 'LinkShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
        },

        /**
         * _getShareUrl
         * 
         * @access  protected
         * @return  String
         */
        _getShareUrl: function() {
            return '';
        },

        /**
         * _position
         * 
         * Ensures that the required <img> has a width by loading the same image
         * it is, and then onload, setting the left margin.
         * 
         * @access  protected
         * @return  void
         */
        _position: function() {
            var _this = this,
                image = new Image();
            image.onload = function() {
                var img = _this.find('img:not(.shadow)'),
                    width = img.css('width').toInt();
                _this.find('.shadow').css(
                    'margin-left',
                    0 - Math.round(width / 2)
                );
            };
            image.src = this._modal.getImage().getSrc();
        },

        /**
         * _setShortUrl
         * 
         * @note    The attempted parameter is used to determine if a request to
         *          the server has already been fired, and in cases in which it
         *          has, and no short url is available (eg. bitly error'd out, or
         *          what's more likely is the connection to it timed out),
         *          display an alert error to the user to notify them of an
         *          issue.
         * @access  protected
         * @param   undefined|Boolean attempted
         * @return  void
         */
        _setShortUrl: function(attempted) {
            attempted = attempted === undefined ? false : attempted;
            var image = this._getImage();
            if (image.setting('shortUrl') === '' ) {
                if (attempted === true) {
                    Stencil.alert('image.shortUrl.error');
                } else {
                    image.once({
                        'change/settings.shortUrl': this._setShortUrl.proxy(
                            this,
                            [true]
                        )
                    });
                    image.generateShortUrl();
                }
            } else {
                var shortUrl = image.setting('shortUrl');
                this.find('input[id="link"]').val(shortUrl);
                this.find('div.fields.placeholder').removeClass('placeholder');
                this.find('input:not(.placeholder)').focus();
            }
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access  public
         * @return  void
         */
        drawImage: function() {
            if (this._drawn === false) {

                // Done
                this._drawn = true;

                // Regular
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    selector = '[lookup="draw"]',
                    $first = $('<img />'),
                    $second = $('<img />');
                $first.attr('src', src);
                $first.attr('draggable', false);
                this.find(selector).replaceWith($first);

                // Shadow
                selector = '[lookup="draw.shadow"]';
                $second.attr('src', src);
                $second.attr('draggable', false);
                $second.addClass('shadow');
                this.find(selector).replaceWith($second);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    this._getImage().once({
                        'preload': function(event) {
                            // var height = $first.css('height').toInt();
                            $first.attr('src', this.getSrc());
                            // $first.css('height', height);
                            $second.attr('src', this.getSrc());
                            // $second.css('height', height);
                        }
                    });
                }
            }
        },

        /**
         * selectInput
         * 
         * @access  public
         * @return  void
         */
        selectInput: function() {
            var input = this.find('input#link');
            (function() {
                input.select();
            }).delay(0);
        },

        /**
         * show
         * 
         * Duplicated here only to prevent calling drawImage with a parameter
         * since LinkShareView doesn't require one. Also, the <_position> call
         * is needed for Link.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            this._setShortUrl();
            this._position();
            this.find('input:not(.placeholder)').focus();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * NetworkShareView
     * 
     * @events  show/desktop
     *          show/mobile
     * @extends View
     */
    window.NetworkShareView = View.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Object
         */
        _drawn: {
            desktop: false,
            mobile: false
        },

        /**
         * _modal
         * 
         * @access  protected
         * @var     null|ShareModalView (default: null)
         */
        _modal: null,

        /**
         * _network
         * 
         * @access  protected
         * @var     null|String (default: null)
         */
        _network: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'NetworkShareView')
         */
        _string: 'NetworkShareView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element);
            this._modal = modal;
            this._drawn = {
                desktop: false,
                mobile: false
            };
            this.on({
                'show/desktop': function(event) {
                    this.preview('desktop', true);
                },
                'show/mobile': function(event) {
                    this.preview('mobile', true);
                }
            });
        },

        /**
         * _connections
         * 
         * @access  protected
         * @return  Array
         */
        _connections: function() {
            var _this = this;
            return Stencil.account().collection('connections').network(
                this._network
            );
        },

        /**
         * _getImage
         * 
         * @access  protected
         * @return  ImageAccessor
         */
        _getImage: function() {
            return this._modal.getImage();
        },

        // /**
        //  * _getImageUrl
        //  * 
        //  * @access  protected
        //  * @return  String
        //  */
        // _getImageUrl: function() {
        //     var image = this._getImage(),
        //         width = image.get('width');
        //     return this._getImage().url('scale', {
        //         width: width
        //     });
        // },

        /**
         * _getOriginalImageUrl
         * 
         * Returns the path to the original image on Cloudinary. This should
         * only be used by Buffer and Pinterest, to ensure they get the links to
         * the originally saved images.
         * 
         * @access  protected
         * @return  String
         */
        _getOriginalImageUrl: function() {
            return this._getImage().url('original');
        },

        /**
         * _getShareUrl
         * 
         * @access  protected
         * @return  String
         */
        _getShareUrl: function() {
            var key = this._getImage().get('key');
            return 'https://getstencil.com/p/' + (key);
        },

        /**
         * _getSnippet
         * 
         * @access  protected
         * @param   Number limit
         * @return  Object
         */
        _getSnippet: function(limit) {
            return this._getImage().getSnippet(limit);
        },

        /**
         * _showBusyModal
         * 
         * @access  protected
         * @return  void
         */
        _showBusyModal: function() {
            var exception = 'A window should have popped up. If you can\'t ' +
                'see it, it may appear behind this browser window, or on ' +
                'another monitor if you have one attached.<br />' +
                'If you cannot find it, ' +
                '<a click trigger="hide" class="text">go back to Stencil</a>.';
            App.getBusy().show(undefined, exception);
        },

        /**
         * drawImage
         * 
         * This function was intended to put less strain (read: memory
         * requirements) on the browser by only writing images when the user
         * requests a section and/or preview-tab that ought to show the image.
         * Specifically, I didn't want to write the base-64 encoded image data
         * in 9 different places if the user was only going to look at one, and
         * even more so, if they look at more than one, it's better to show the
         * image-src if the image has been uploaded by that point.
         * 
         * @access  public
         * @param   String type
         * @return  void
         */
        drawImage: function(type) {
            if (this._drawn[type] === false) {
                this._drawn[type] = true;
                var uploaded = this._getImage().get('uploaded').toInt(),
                    preloaded = this._getImage().preloaded(),
                    src = this._getImage().getSrc(),
                    lookup = 'draw.' + (type),
                    selector = '[lookup="' + (lookup) + '"]',
                    $img = $('<img />');
                if (uploaded === 0 || preloaded === false) {
                // if (uploaded === 0) {

                    /**
                     * The below commented code works, but I'm not sure it
                     * should be used because of the following:
                     * 1. It's heavy. A Ghost canvas can be more than 1mb quite
                     *    easily. Considering that the image will likely only be
                     *    noticably blurry when it's a Pinterest frame, and
                     *    they're viewing Facebook/Twitter (where 100% width
                     *    stretching happens), it might not be worth the weight.
                     * 2. After X seconds the image will have been uploaded, so
                     *    it's likely okay to wait until then.
                     * 3. Listeners on Ghost are fine, but Ghost fires very
                     *    quickly. So without a secondary-access method for
                     *    the above <_getImageUrl> call, this Ghost listener
                     *    will only actually be run once for whatever network
                     *    and tab the user first hits. After that, the Preview
                     *    canvas data string will be used. Would need to be
                     *    build a helper method for this, which would touch a
                     *    lot of parts of the app.
                     */
                    // Canvases.Ghost.once({
                    //     'export': function(event, dataURL, mime) {
                    //         $img.attr('src', dataURL);
                    //     }
                    // });

                    // Once preloaded, swap out the image src
                    this._getImage().once({
                        'preload': function(event) {
                            $img.attr('src', this.getSrc());
                        }
                    });
                }
                $img.attr('src', src);
                $img.attr('draggable', false);
                this.find(selector).replaceWith($img);
            }
        },

        /**
         * getNav
         * 
         * @access  public
         * @return  jQuery
         */
        getNav: function() {
            return this.find('aside nav');
        },

        /**
         * getPreview
         * 
         * @access  public
         * @return  jQuery
         */
        getPreview: function() {
            return this.find('aside div.preview');
        },

        /**
         * preview
         * 
         * @access  public
         * @param   String type
         * @param   Boolean drawImage
         * @return  void
         */
        preview: function(type, drawImage) {
            if (drawImage === true) {
                this.drawImage(type);
            }
            this.getNav().find('a').removeClass('active');
            this.getNav().find('a.' + (type)).addClass('active');
            this.getPreview().find('> section').addClass('hidden');
            this.getPreview().find('> section.' + (type)).removeClass('hidden');
        },

        /**
         * show
         * 
         * @access  public
         * @param   undefined|Boolean focusOnInput
         * @return  void
         */
        show: function(focusOnInput) {
            var userAccount = Stencil.account().userAccount();
            userAccount.push('settings.shareNetwork', this._network);
            this.drawImage('desktop');
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
            if (UserAgent.is.tablet() === false) {
                if (focusOnInput !== false) {
                    this._element.focusable().focus();
                }
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * PinterestShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.PinterestShareView = NetworkShareView.extend({

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'pinterest')
         */
        _network: 'pinterest',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PinterestShareView')
         */
        _string: 'PinterestShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._setupKeyEvents();
            this.preview('desktop', false);
            this.on({
                'open': this.open
            });
        },

        /**
         * _getShareUrl
         * 
         * @acccess protected
         * @return  String
         */
        _getShareUrl: function() {
            var urlValue = this.find('[name="url"]').val();
            return urlValue;
        },

        /**
         * _setupKeyEvents
         * 
         * @note    13 = enter key
         * @acccess protected
         * @return  void
         */
        _setupKeyEvents: function() {
            var _this = this;
            this.find('input[name="url"]').on({
                'keydown': function(event) {
                    if (event.which === 13) {
                        _this.triggerHandler('open');
                    }
                }
            });
        },

        /**
         * open
         * 
         * @note    Pinterest (oddly) truncates (by adding three dots) at 500 or
         *          greater characters. So I truncate at 499, with my own three
         *          dots, to ensure things are in sync.
         * @note    It's okay to exclude the description (eg. if there is none)
         * @access  public
         * @return  void
         */
        open: function() {
            var image = this._getImage();
            if (image.get('uploaded').toInt() === 1) {
                var snippetObject = this._getSnippet(499),
                    url = encodeURIComponent(this._getShareUrl()),
                    media = encodeURIComponent(this._getOriginalImageUrl()),
                    description = encodeURIComponent(snippetObject.snippet),
                    link = 'https://pinterest.com/pin/create/button/' +
                        '?url=' + (url) +
                        '&media=' + (media);
                if (snippetObject.default === false) {
                    link += '&description=' + (description);
                }
                window.open(
                    link,
                    'Pinterest Share',
                    'width=640, height=320'
                );
            } else {
                var msg = Stencil.getMessage('image.share.pending');
                App.getBusy().show(msg);
                image.once({
                    'change/uploaded': function(event) {
                        App.getBusy().hide();
                        Stencil.alert('image.uploaded');
                    }
                });
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * TwitterShareView
     * 
     * @events  connection/add
     * @extends NetworkShareView
     */
    window.TwitterShareView = NetworkShareView.extend({

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                input: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $textarea
                     * @return  void
                     */
                    'textarea': function(event, $textarea) {
                        var $message = this.find('[lookup="message"]'),
                            message = $textarea.val();
                        this.setMessage(message);
                        this.triggerHandler('change/message');
                    }
                }
            });
        },

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'twitter')
         */
        _network: 'twitter',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TwitterShareView')
         */
        _string: 'TwitterShareView',

        /**
         * _thresholds
         * 
         * @access  protected
         * @var     Object
         */
        _thresholds: {
            search: 15
        },

        /**
         * init
         * 
         * @todo!!  Instead of having image-uploaded property checked on backend,
         *          check it here, and if it is not yet uploaded, wait for it
         *          (via event listener), and then submit form.
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this.on({
                'connection/add': function(event) {
                    this._showBusyModal();
                    var _this = this,
                        model = this._getModel('Twitter');
                    model.setup();
                    model.connect({
                        closed: function() {
                            App.getBusy().hide();
                        },
                        connected: function(connections) {
                            _this.state('connections');
                        }
                    });
                }
            });
            this._setupForm();
            this.preview('desktop', false);
            this._addCountListener();
            this._refreshCount();
            this._setupTooltips();

            // State
            if (this._connections().length === 0) {
                this.state('connect');
            } else {
                this.state('connections');
            }
        },

        /**
         * _addCountListener
         * 
         * @access  protected
         * @return  void
         */
        _addCountListener: function() {
            this.on({
                'change/message': this._refreshCount
            });
        },

        /**
         * _drawConnections
         * 
         * @access  protected
         * @return  void
         */
        _drawConnections: function() {
            var connections = this._connections(),
                $connections = DataUtils.render('TwitterConnections', {
                    live: connections.length > this._thresholds.search,
                    connections: connections
                });
            this.find('div.selector').append($connections);
        },

        /**
         * _initConnections
         * 
         * Creates the initial <selectpicker>, and listens for value changes
         * to have the preview update or prompt them to connect more accounts.
         * 
         * @access  protected
         * @return  void
         */
        _initConnections: function() {
            var _this = this,
                $select = this.find('select');
            $select.selectpicker();
            $select.change(
                function(event) {
                    _this.update();
                    _this.find('textarea').focus();
                    if ($(this).val().toInt() === 0) {
                        _this.triggerHandler('connection/add');
                        _this.find('textarea').blur();
                        _this._setupConnections();
                    } else {
                        var userAccount = Stencil.account().userAccount();
                        userAccount.push(
                            'settings.shareTwitterRecent',
                            $(this).val()
                        );
                    }
                }
            );
        },

        /**
         * _preselectConnection
         * 
         * Looks up which connection should be preselected, based on a possible
         * cookie value.
         * 
         * @todo    Ensure preselected is cookied
         * @access  protected
         * @return  void
         */
        _preselectConnection: function() {
            var $select = this.find('select'),
                share = Stencil.account().userAccount().setting('shareTwitterRecent'),
                first = $select.find('option').first().val(),
                preselected = share.match(/^cnnc/) === null ? first : share;
            $select.val(preselected);
        },

        /**
         * _refreshCount
         * 
         * @see     https://dev.twitter.com/rest/reference/get/help/configuration
         * @note    Count used to start at 24 since an image is attached to the
         *          tweet. No longer seems to be the case.
         * @access  protected
         * @return  void
         */
        _refreshCount: function() {
            var $textarea = this.find('textarea'),
                val = $textarea.val(),
                $status = this.find('.status'),
                $count = $status.find('[lookup="current"]'),
                // count = 24;
                count = 0;

            // Leading @ sign


            // Replace links with hardcoded-counts (23)
            count += val.replace(
                /h[A-Za-z]+:\/\/[A-Za-z0-9-_]+\.[A-Za-z0-9-_:%&~\?\/.=]+/g,
                '12345678901234567890123'
            // Twitter doesn't require http(s) when a trailing .com is found
            ).replace(
                /^[a-z0-9]+\.com(\s)/gi,
                '12345678901234567890123$1'
            ).replace(
                /(\s)[a-z0-9]+\.com(\s)/gi,
                '$112345678901234567890123$2'
            ).replace(
                /(\s)[a-z0-9]+\.com$/gi,
                '$112345678901234567890123'
            ).replace(
                /^[a-z0-9]+\.com$/gi,
                '12345678901234567890123'
            ).length;
            // ).replace(
            //     /^[a-z0-9]+\.com\s/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /\s[a-z0-9]+\.com\s/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /\s[a-z0-9]+\.com$/gi,
            //     '12345678901234567890123'
            // ).replace(
            //     /^[a-z0-9]+\.com$/gi,
            //     '12345678901234567890123'
            // ).length;

            // Twitter doesn't require http(s) when a trailing .com is found
//             count += val.replace(
//                 /\s[a-z0-9]+\.com\s/gi,
//                 '12345678901234567890123'
//             ).length;
// StencilBooter.log(
//     val.replace(
//                 /\s[a-z0-9]+\.com\s/gi,
//                 '12345678901234567890123'
//             )
// );
//             count += val.replace(
//                 /\s[a-z0-9]+\.com$/gi,
//                 '12345678901234567890123'
//             ).length;

            // Set count, along with UI for overage
            $count.text(count);
            $status.removeClass('red');
            if (count > 280) {
                $status.addClass('red');
            }
        },

        /**
         * _removeConnections
         * 
         * @access  protected
         * @return  void
         */
        _removeConnections: function() {
            var $selector = this.find('div.selector');
            $selector.empty();
        },

        /**
         * _setupConnections
         * 
         * @access  protected
         * @return  void
         */
        _setupConnections: function() {
            this._removeConnections();
            this._drawConnections();
            this._preselectConnection();
            this._initConnections();
            this.update();
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var _this = this;
            this._form = new AppFormView(this.find('form'));
            this._form.setTimeout(0);
            this._form.on({
                'submitted': function(event) {
                    _this._modal.pause();
                },
                'returned': function(event) {
                    _this._modal.unpause();
                },
                'returned/failed': function(event, response) {
                    if (response.data && response.data.connection) {
                        if (response.data.action === 'delete') {
                            var key = response.data.connection.key;
                            Stencil.getAccessor(key).delete();
                            if (_this._connections().length === 0) {
                                _this.state('connect');
                            } else {
                                _this.state('connections');
                            }

                            // Error handling
                            this.clearErrors();
                            var image = _this._getImage(),
                                path = '/app/images/' + (image.get('key')) +
                                    '/' + (key) + '/error?clean=1';
                            Stencil.navigate(path);
                        } else if (response.data.action === 'error') {
                            this.setErrorMessage(response.message);
                        }
                    }
                },
                'returned/succeeded': function(event, response) {
                    var model = Stencil.getModel('Share'),
                        share = model.setAccessor(response.data.object);
                    Stencil.navigate(share.getPath());
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                selector: '[tooltip]',
                container: App.getElement(),
                // container: this._element,
                placement: 'bottom'
            });
        },

        /**
         * setMessage
         * 
         * This function is very peculiar. The goal is to have the preview look
         * exactly like how Twitter will render it. To that end, note the
         * following:
         * - Twitter will strip lead whitespace
         * - It will cap more than 2 newline characters to just 2
         * - It will strip trailing whitespace
         * 
         * @see     https://stackoverflow.com/questions/5002111/javascript-how-to-strip-html-tags-from-string
         * @see     https://i.imgur.com/VTsHkJi.png
         *          https://i.imgur.com/p2Fg7a9.png
         *          Look into truncating url's to match how Twitter does it
         * @note    Added the .textContent / .innerText logic to prevent people
         *          from pasting in markup that may include script tags. This
         *          logic simply strips out the html tags. But I don't think I
         *          actually want this. So instead, simply replacing open and
         *          close html tags to prevent tags from being rendered.
         * @access  public
         * @param   String message
         * @return  void
         */
        setMessage: function(message) {
            var $message = this.find('[lookup="message"]');//,
                // div = document.createElement('div');
            // div.innerHTML = message;
            // message = (div.textContent || div.innerText || '');
            message = message.replace(/</g, '&lt;');
            message = message.replace(/>/g, '&gt;');
            message = message.replace(/^\n{1,}/g, '');
            message = message.encode('url');
            message = message.encode('hashtag', {
                href: 'https://twitter.com/hashtag/$hashtag'
            });
            message = message.encode('username', {
                href: 'https://twitter.com/$username'
            });
            message = message.replace(/\n{2,}/g, '\n\n');
            message = message.replace(/\n+$/, '');
            message = message.encode('newlines');
            $message.html(message);
        },

        /**
         * state
         * 
         * Show the proper state (eg. show connections w/ textarea, or button
         * prompting them to connect their FB account(s))
         * 
         * @access  public
         * @param   String state
         * @return  void
         */
        state: function(state) {
            this.find('.state').addClass('hidden');
            if (state === 'connect') {
                this.find('.state[lookup="connect"]').removeClass('hidden');
            } else {
                this._setupConnections();
                this.find('.state[lookup="connections"]').removeClass('hidden');
            }
        },

        /**
         * update
         * 
         * Updates the UI of the previews to have the corresponding name and
         * picture in there.
         * 
         * @todo    Preload all conncetion urls into memory for faster
         *          transitions between them
         * @access  public
         * @return  void
         */
        update: function() {

            // Get the selected connection
            var connections = Stencil.account().collection('connections'),
                $select = this.find('select'),
                value = $select.val(),
                selected = false;
            if (connections.find(value) !== false) {
                selected = connections.find(value);
            }

            // If a connection was found
            if (selected !== false) {
                var $names = this.find('[lookup="connection.label"]'),
                    $usernames = this.find('[lookup="connection.networkUserId"]'),
                    $images = this.find('[lookup="connection.image"]'),
                    label = '@' + (selected.get('label')),
                    raw = selected.getRaw(),
                    name = raw.name;

                // Inserts
                $names.text(name === undefined ? '' : name);
                $usernames.text(label);
                $images.attr('src', selected.getImageSrc());
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('NetworkShareView', function() {

    /**
     * VerifoneShareView
     * 
     * @events  open
     * @extends NetworkShareView
     */
    window.VerifoneShareView = NetworkShareView.extend({

        /**
         * _drawn
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _drawn: false,

        /**
         * _network
         * 
         * @access  protected
         * @var     String (default: 'verifone')
         */
        _network: 'verifone',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VerifoneShareView')
         */
        _string: 'VerifoneShareView',

        /**
         * init
         * 
         * @todo    Ensure action for this view cannot be initiated until after
         *          the image has been uploaded:
         *          eg: image.get('uploaded').toInt() === 1
         * @access  public
         * @param   jQuery element
         * @param   ShareModalView modal
         * @return  void
         */
        init: function(element, modal) {
            this._super(element, modal);
            this._drawn = false;
            this._addDownloadEvent();
            this._listenForUploadedChange();
        },

        /**
         * _addDownloadEvent
         * 
         * @access  protected
         * @return  void
         */
        _addDownloadEvent: function() {
            var image = this._getImage();
            this.on({
                'download': function(event) {
                    var maxBytes = this._getMaxBytes();
                    image.download(false, false, false, maxBytes, false, false);
                }
            });
            var _this = this;
            Stencil.once({
                'redirect/start': function(event) {
                    _this._modal.pause();
                    var $buttons = _this.find('a.button');
                    $buttons.addClass('busy');
                    $buttons.disable();
                },
                'redirect/complete': function(event) {
                    _this._modal.unpause();
                    var $buttons = _this.find('a.button');
                    $buttons.removeClass('busy');
                    $buttons.addClass('done');
                    (function() {
                        $buttons.removeClass('done');
                        $buttons.enable();
                    }).delay(2000, this);
                }
            });
        },

        /**
         * _getMaxBytes
         * 
         * @access  protected
         * @return  Number
         */
        _getMaxBytes: function() {
            var image = this._getImage(),
                frameKey = image.get('frame');
            return Config.get('partners').verifone.frames[frameKey].maxBytes;
        },

        /**
         * _listenForUploadedChange
         * 
         * @access  protected
         * @return  void
         */
        _listenForUploadedChange: function() {
            var _this = this,
                image = this._getImage();
            if (image.get('uploaded').toInt() === 0) {
                image.once({
                    'update/uploaded': function(event) {
                        var $buttons = _this.find('a.button');
                        $buttons.removeClass('busy');
                        $buttons.enable();
                    }
                });
            }
        },

        /**
         * _showAppropriateFramePreview
         * 
         * @access  protected
         * @return  void
         */
        _showAppropriateFramePreview: function() {
            var image = this._getImage(),
                frameKey = image.get('frame');
            if (frameKey === 'frm-partner.verifone-carbon8') {
                this.find('[frame="frm-partner.verifone-carbon8"]').removeClass('hidden');
            } else if (frameKey === 'frm-partner.verifone-vx') {
                this.find('[frame="frm-partner.verifone-vx"]').removeClass('hidden');
            }
        },

        /**
         * drawImage
         * 
         * (see parent for documentation)
         * 
         * @access  public
         * @return  void
         */
        drawImage: function() {
            if (this._drawn === false) {
                this._drawn = true;
                var image = this._getImage(),
                    frameKey = image.get('frame'),
                    uploaded = image.get('uploaded').toInt(),
                    preloaded = image.preloaded(),
                    src = image.getSrc(),
                    selector = '[frame="' + (frameKey) + '"] [lookup="draw"]',
                    $img = $('<img />');
                $img.attr('src', src);
                $img.attr('draggable', false);
                this.find(selector).replaceWith($img);

                // Callback for post-uploaded
                if (uploaded === 0 || preloaded === false) {
                    image.once({
                        'preload': function(event) {
                            $img.attr('src', this.getSrc());
                        }
                    });
                }
            }
        },

        /**
         * show
         * 
         * @note    Not pushing shareNetwork to the UserAccount record, since I
         *          don't want it remembered.
         * @access  public
         * @return  void
         */
        show: function() {
            this.drawImage();
            this._showAppropriateFramePreview();
            var $nav = this._modal.find('nav').first(),
                $anchor = $nav.find('[network="' + (this._network) + '"]');
            $anchor.siblings('[network]').removeClass('active');
            $anchor.addClass('active');
            this._element.siblings('section').addClass('hidden');
            this._element.removeClass('hidden');
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * SidebarView
     * 
     * @extends View
     */
    window.SidebarView = View.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'SidebarView')
         */
        _string: 'SidebarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * getNav
         * 
         * @access  public
         * @return  jQuery
         */
        getNav: function() {
            return this.find('nav');
        },

        /**
         * updatePath
         * 
         * @access  public
         * @param   AreaView area
         * @param   String path
         * @return  void
         */
        updatePath: function(area, path) {
            var $nav = this.getNav(),
                type = area.getType(),
                $anchor = $nav.find('a[area="' + (type) + '"]');
            $anchor.attr('href', path);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * CanvasView
     * 
     * @see     http://rstgroup.github.io/fabricjs-viewport/
     *          Contains library to zoom in and out of a fabricjs canvas
     * @extends View
     */
    window.CanvasView = View.extend({

        /**
         * _cotton
         * 
         * Reference to the fabric.Canvas object.
         * 
         * @access  protected
         * @var     null|fabric.Canvas (default: null)
         */
        _cotton: null,

        /**
         * _image
         * 
         * @access  protected
         * @var     null|ImageAccessor (default: null)
         */
        _image: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'CanvasView')
         */
        _string: 'CanvasView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
        },

        /**
         * _setupCotton
         * 
         * @note    Had to add the moveCursor property to prevent the move cursor
         *          from showing up when the BackgroundRectangle layer was being
         *          accidentally dragged
         * @see     https://gist.github.com/paulkaplan/6050309
         * @access  protected
         * @return  void
         */
        _setupCotton: function() {
            this._cotton = new fabric.Canvas(
                this._element.get(0),
                {
                    controlsAboveOverlay: true,
                    moveCursor: 'default',
                    magnets: {
                        drawings: []
                    },
                    selection: false
                    // ,targetFindTolerance: 5
                }
            );
            // if (window.devicePixelRatio !== 1) {
            //     var canvas = this._element.get(0),
            //         width = canvas.width,
            //         height = canvas.height,
            //         ratio = window.devicePixelRatio;
            //     canvas.getContext('2d').scale(ratio, ratio);
            //     canvas.setAttribute('width', width * ratio);
            //     canvas.setAttribute('height', height * ratio);
            //     $(canvas).css({
            //         width: (width) + 'px',
            //         height: (height) + 'px'
            //     });
            // }
        },

        /**
         * drawLayers
         * 
         * Recursively draws layers onto the canvas since it may at time require
         * fetching further resources (eg. fonts, svg images, bitmap images,
         * etc). Also imortant for exporting (done via the Ghost canvas), since
         * the fully rendered image won't be available until it's assets have
         * been loaded.
         * 
         * @access  public
         * @return  void
         */
        drawLayers: function() {
            this._resizeCanvas();
            var _this = this,
                drawing,
                layer,
                layers = this._image.getImageDocument().getLayers(true),
                length = layers.length,
                next = function(index) {
                    layer = layers[index];
                    drawing = layer.getDrawing();
                    drawing.once({
                        'draw': function(event) {
                            if (index !== length - 1) {
                                next(index + 1);
                            } else {
                                _this.triggerHandler('draw');
                            }
                        }
                    });
                    drawing.draw();
                };
            next(0);
        },

        /**
         * getBackgroundBitmapImageLayer
         * 
         * @access  public
         * @return  BackgroundBitmapImageLayer
         */
        getBackgroundBitmapImageLayer: function() {
            return this._image.getImageDocument().getBackgroundBitmapImageLayer();
        },

        /**
         * getCotton
         * 
         * @access  public
         * @return  fabric.Canvas
         */
        getCotton: function() {
            return this._cotton;
        },

        /**
         * getImage
         * 
         * @access  public
         * @return  ImageAccessor
         */
        getImage: function() {
            return this._image;
        },

        /**
         * getRenderedDimensions
         * 
         * @access  public
         * @return  Object
         */
        getRenderedDimensions: function() {
            var height = this._cotton.getHeight(),
                width = this._cotton.getWidth(),
                ratio = width / height;
            return {
                height: height,
                ratio: ratio,
                width: width
            };
        },

        /**
         * render
         * 
         * Reorders the drawn layers, assuming that the order in which they're
         * returned from getLayers is the order that they're desired via the UI.
         * 
         * A check is made against whether the drawings have successfully been
         * drawn, because it's possible that this method is called after a layer
         * has been added to the image document, but before it's been drawn. I
         * ran into this issue when I was a logged in user with more than one
         * watermark enabled. When I logged out, and then back in, one of the
         * calls below failed because the <cotton> property didn't yet exist.
         * The Canvas.render method was being triggered by the
         * WatermarkUploadAccessor.addToCanvas method.
         * 
         * The renderFilters check is always made to prevent rendering files
         * when actions unrelated to a bitmap operation is made. Without this
         * check, when a filter is specified, running non-filter based
         * operations against the canvas would be super-slow, since it would be
         * doing bitmap operations each time.
         * 
         * @todo    Look into fabric's moveTo method. It may be useful for
         *          ordering layers.
         * @access  public
         * @return  void
         */
        render: function() {

            // Reorder layers, including backdrop (if any)
            this.set({
                'rendering': true
            });
            var imageDocument = this._image.getImageDocument(),
                layers = imageDocument.getLayers(true),
                drawing,
                cotton;
            jQuery.each(layers, function(index, layer) {
                drawing = layer.getDrawing();
                if (drawing.drawn() === true) {
                    cotton = drawing.getCotton();
                    if (layer.getProperty('type') === 'text') {
                        if (cotton.backdrop !== undefined) {
                            cotton.backdrop.bringToFront();
                            // cotton.backdrop.setCoords();
                        }
                    }
                    if (layer.getProperty('background') === undefined) {
                        cotton.bringToFront();
                    }
                    if (drawing.getOutline() !== null) {
                        drawing.getOutline().centers.top.bringToFront();
                        drawing.getOutline().centers.right.bringToFront();
                        drawing.getOutline().centers.bottom.bringToFront();
                        drawing.getOutline().centers.left.bringToFront();
                        drawing.getOutline().red.bringToFront();
                        drawing.getOutline().white.bringToFront();
                    }
                    // cotton.setCoords();
                }
            });

            // Determine if a filter-rendering is required on any layer
            var layer, index, filterLayersToRender = [], filterLayers = [],
                filters;
            for (index in layers) {
                layer = layers[index];
                filters = layer.getProperty('filters');
                if (filters !== undefined && filters.length > 0) {
                    filterLayers.push(layer);
                }
                if (layer.get('renderFilters') === true) {
                    filterLayersToRender.push(layer);
                }
            }

            // Post filter-rendering callback
            if (filterLayersToRender.length > 0) {
                var _this = this,
                    recursiveFilterRendering = function(layers) {
                        if (layers.length === 0) {
                            _this._cotton.renderAll();
                            _this.set({
                                'rendering': false
                            });
                            _this.triggerHandler('render');
                        } else {
                            var layer = layers.shift();
                            layer.sortFilters();
                            layer.getDrawing().once({
                                'applyFilters/complete': function(event) {
                                    recursiveFilterRendering(layers);
                                }
                            });
                            layer.getCotton().applyFilters();
                            layer.set({'renderFilters': false});
                        }
                    };
                recursiveFilterRendering(filterLayersToRender);
            } else {
                this._cotton.renderAll();
                this.set({
                    'rendering': false
                });
                this.triggerHandler('render');
            }
        },

        /**
         * setImage
         * 
         * @access  public
         * @param   ImageAccessor image
         * @return  void
         */
        setImage: function(image) {
            this._image = image;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CanvasView', function() {

    /**
     * GhostCanvasView
     * 
     * @extends CanvasView
     */
    window.GhostCanvasView = CanvasView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'GhostCanvasView')
         */
        _string: 'GhostCanvasView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            window.Canvases.Ghost = this;
            this._setupCotton();
        },

        /**
         * _getExportMime
         * 
         * @access  protected
         * @return  String
         */
        _getExportMime: function() {
            return this._image.getRecommendedExportMime();
        },

        /**
         * _resizeCanvas
         * 
         * Fabric.js automatically creates a secondary canvas behind the main
         * one. They do this to deal with retina issues: they want to ensure
         * that whatever is exported, it's optimized for the display (read
         * "number of pixels"). So in the case where the device pixel ratio
         * matches the minPixelDensity property of 2 set in the config file,
         * nothing needs to be done, since Fabric.js will create the proper
         * sized canves.
         * 
         * But in the case:
         * 1) The device has a lower device pixel ratio (eg. 1), the canvas
         *    is blown up to ensure that whatever download the user desires (
         *    eg. retina)
         * 2) The device has a higher device pixel ratio (eg. zoomed in to 2.2),
         *    the canvas is made a bit smaller to ensure whatever is downloaded
         *    fits the proper dimensions.
         * 
         * @access  protected
         * @return  void
         */
        _resizeCanvas: function() {
            var width = Frame.get('width'),
                height = Frame.get('height'),
                devicePixelRatio = window.devicePixelRatio,
                minDevicePixelRatio = Config.default('minPixelDensity').toInt();
            if (devicePixelRatio === minDevicePixelRatio) {
                this._cotton.resizeTo(width, height);
            } else {
                width *= (minDevicePixelRatio / devicePixelRatio);
                height *= (minDevicePixelRatio / devicePixelRatio);
                this._cotton.resizeTo(width, height);
            }
        },

        /**
         * _setupCotton
         * 
         * @access  protected
         * @return  void
         */
        _setupCotton: function() {
            this._super();
            this._element.parent().addClass('ghost-canvas-container');
        },

        /**
         * _syncBackgroundBitmapImage
         * 
         * @access  protected
         * @param   Function callback
         * @return  void
         */
        _syncBackgroundBitmapImage: function(callback) {
            var layer = this.getBackgroundBitmapImageLayer(),
                key = layer.getProperty('image');
            if (key.match(/^asst/) !== null || key.match(/^upld/) !== null) {
                callback();
            } else {
                var accessor = Stencil.getAccessor(key);
                accessor.once({
                    'save': function(event, resource, asset) {
                        callback();
                    }
                });
                accessor.save();
            }
        },

        /**
         * draw
         * 
         * Waits for a background image, if defined, to be saved to the backend
         * to ensure a frame-dimension-specific background image can be loaded
         * (via Cloudinary). After that's completed, standard call to
         * <drawLayers> method.
         * 
         * @note    <clear> call to get rid of any previously drawn objects
         * @access  public
         * @return  void
         */
        draw: function() {
            this.once({
                'draw': function(event) {
                    this.render();
                }
            });
            this._cotton.clear();
            var layer = this.getBackgroundBitmapImageLayer(),
                key = layer.getProperty('image');
            if (key === false) {
                this.drawLayers();
            } else {
                this._syncBackgroundBitmapImage(this.drawLayers.proxy(this));
            }
        },

        /**
         * export
         * 
         * @access  public
         * @param   false|String mime
         * @param   Boolean scaleForRetina
         * @return  void
         */
        export: function(mime, scaleForRetina) {
            mime = mime === false ? this._getExportMime() : mime;
            this.time('export');

            // Numbers based on device pixel ratio and retina desire
            var minDevicePixelRatio = Config.default('minPixelDensity').toInt(),
                multiplier = 0.5,
                width = Frame.get('width').toInt() * minDevicePixelRatio,
                height = Frame.get('height').toInt() * minDevicePixelRatio;
            if (scaleForRetina === true) {
                multiplier = 1;
            }

            // Export and trigger event
            window.exportingMultiplier = multiplier;
            var dataURL = this._cotton.toDataURL({
                format: mime === 'image/jpeg' ? 'jpeg' : 'png',
                quality: 1,
                multiplier: multiplier,
                left: 0,
                top: 0,
                width: width,
                height: height
            });
            delete window.exportingMultiplier;

            // 
            this.time('export');
            this.triggerHandler('export', [dataURL, mime]);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('CanvasView', function() {

    /**
     * PreviewCanvasView
     * 
     * @extends CanvasView
     */
    window.PreviewCanvasView = CanvasView.extend({

        /**
         * _events
         * 
         * Behinds a number of events to the app. This works a bit differently
         * than other views, in that events are sometimes bound to other view
         * elements, as well as elements that aren't selected via the
         * traditional <find> method.
         * 
         * @access  protected
         * @var     Function
         */
        _events: function() {
            return {

                /**
                 * center.snap
                 * 
                 * @access  protected
                 * @return  void
                 */
                'center.snap': function() {
                    var $app = App.getElement();
                    this._cotton.on({
                        'mouse:up': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        },
                        'object:moving': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        },
                        'object:modified': function(options) {
                            var $guides = $app.find('div.guides');
                            $guides.find('div.guide').addClass('hidden');
                        }
                    });
                },

                /**
                 * body.click
                 * 
                 * Listeners for mousedown events to allow the selected layer to
                 * be blurred, so long as anything other than the text toolbar
                 * is clicked. When the text toolbar is clicked, simply force
                 * the selected layer out of editing mode.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'body.click': function() {
                    var $app = App.getElement();
                    $app.on({
                        'mousedown': function(event) {
                            var canvas = Canvases.Preview,
                                layer = canvas.getSelectedLayer();
                            if (layer !== false) {
                                if (Stencil.get('ignoreMouseDownLayerBlur') !== true) {
                                    var $target = $(event.target),
                                        drawing = layer.getDrawing();
                                    if ($target.parents('.toolbar.text').length === 1) {
                                        if (drawing.getCotton().isEditing === true) {
                                            drawing.getCotton().exitEditing();
                                            drawing.select();
                                        }
                                    } else if ($target.parents('.toolbar').length !== 1) {
                                        if ($target.tag() !== 'canvas') {
                                            // drawing.getCotton().exitEditing();
                                            canvas.deselectSelectedLayer();
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.click
                 * 
                 * Ensures the selected layer is blurred when the canvas is
                 * clicked on, and another fabric object is focused, or simply
                 * the canvas itself is focused on. The key here being that the
                 * selected object's fabric object is _not_ the target event
                 * that's clicked on.
                 * 
                 * At the moment, the only time I could find whereby the
                 * deselect code is run is where a TextDrawing has a backdrop
                 * specified, set to "Full width", and then clicking between
                 * the BackgroundRectangleDrawing and the backdrop itself causes
                 * the below code to be successfully executed.
                 * 
                 * I believe this is because in almost all cases, clicking on a
                 * canvas cotton object results in that layer being "activated",
                 * which then already takes care of deselecting the selected
                 * layer.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'canvas.click': function() {
                    var _this = this;
                    this._cotton.on({
                        'mouse:down': function(event) {
                            var canvas = Canvases.Preview,
                                layer = canvas.getSelectedLayer();
                            if (layer !== false) {
                                var drawing = layer.getDrawing();
                                if (event.target !== drawing.getCotton()) {
                                    _this.deselectSelectedLayer();
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.dblclick
                 * 
                 * Allows for double-click insertion of an empty text layer.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'canvas.dblclick': function() {
                    App.find('canvas#preview').parent().on({
                        'dblclick': function(event) {
                            var $target = $(event.target);
                            if ($target.parent('.busy.modal').length === 0) {
                                var canvas = Canvases.Preview,
                                    selected = canvas.getSelectedLayer();
                                if (
                                    selected === false
                                    || selected.toString() === 'BackgroundRectangleLayer'
                                    || selected.toString() === 'BackgroundBitmapImageLayer'
                                    || selected.toString() === 'ForegroundBitmapImageLayer'
                                ) {
                                    // Position of click
                                    var options = {
                                        left: ((event.offsetX / canvas.getCotton().getWidth()) * 100).round(4),
                                        top: ((event.offsetY / canvas.getCotton().getHeight()) * 100).round(4)
                                    };

                                    // Add layer
                                    var layer = canvas.addTextLayer(options),
                                        drawing = layer.getDrawing();
                                    layer.setChangeOperationType('added');
                                    drawing.once({
                                        'draw': function(event) {
                                            this.select();
                                            drawing.animate();
                                            // cotton.enterEditing();
                                            // cotton.selectAll();
                                        }
                                    });
                                    drawing.draw();
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.rclick
                 * 
                 * @access  protected
                 * @return  void
                 */
                'canvas.rclick': function() {
                    App.find('canvas#preview').parent().on({
                        'contextmenu': function(event) {
                            var canvas = Canvases.Preview,
                                layer = canvas.getSelectedLayer();
                            if (layer !== false) {
                                var drawing = layer.getDrawing();
                                if (drawing.toString() === 'TextDrawing') {
                                    Stencil.set('ignoreMouseDownLayerBlur', true);
                                    Stencil.alert('canvas.text.rclick');
                                    setTimeout(function() {
                                        drawing.getCotton().exitEditing();
                                        drawing.select();
                                    }, 100);
                                    Modals.getOpen()[0].once({
                                        'leave': function(event) {
                                            Stencil.set('ignoreMouseDownLayerBlur', false);
                                            setTimeout(function() {
                                                drawing.select();
                                                drawing.getCotton().enterEditing();
                                                drawing.getCotton().selectAll();
                                            }, 0);
                                        }
                                    });
                                }
                            }
                        }
                    });
                },

                /**
                 * canvas.hover
                 * 
                 * @access  protected
                 * @return  void
                 */
                // 'canvas.hover': function() {
//                     var _this = this;
// StencilBooter.log(App.find('canvas#preview').siblings('canvas'));
//                     App.find('canvas#preview').siblings('canvas').on({
//                         'hover': function(event) {
//                             var layers = this._imageDocument.filter(function(index, layer) {
//                                 return layer.getStyle('order').toInt() >= 2;
//                             });
//                             StencilBooter.log(layers);
//                         }
//                     });
                // },

                /**
                 * canvas.render
                 * 
                 * Method to throttle requests to Footer.reset whenever the
                 * canvas is updated. Nice central place to do this.
                 * 
                 * @access  protected
                 * @return  void
                 */
                // 'canvas.render': function() {
                    // var callback = Footer.reset.proxy(Footer);
                    // this._cotton.on({
                    //     'after:render': _.throttle(callback, 75)
                    // });
                // },

                /**
                 * key.autoAlign
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.autoAlign': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            // 'c' key
                            if (event.which === 67) {
                                var $target = $(event.target);
                                if (
                                    $target.tag() !== 'input'
                                    || (
                                        $target.tag() === 'input'
                                        && $target.attr('type') !== 'text'
                                    )
                                ) {
                                    var layer = Canvases.Preview.getSelectedLayer();
                                    if (layer !== false) {
                                        var layerType = layer.toString();
                                        if (
                                            layerType !== 'BackgroundRectangleLayer'
                                            && layerType !== 'BackgroundBitmapImageLayer'
                                        ) {
                                            if (layerType === 'TextLayer') {
                                                var cotton = layer.getCotton();
                                                if (cotton.isEditing === false) {
                                                    layer.autoAlign();
                                                }
                                            } else {
                                                layer.autoAlign();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.delete
                 * 
                 * Allows for delete-key deletion. Checks whether a correct
                 * keyCode was detected, a layer is currently selected, and the
                 * user is currently not focused on a text input (since if they
                 * are, they may intend to delete a hex code value, rather than
                 * the layer).
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.delete': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.which === 8 || event.which === 46) {
                                var layer = Canvases.Preview.getSelectedLayer();
                                if (
                                    Modals.getOpen().length === 0
                                    && layer !== false
                                ) {
                                    /**
                                     * @note    The
                                     *          ChangeHistory.clearOperationType()
                                     *          below is used to account for the
                                     *          case where a user is dragging the
                                     *          BackgroundBitmapImageLayer around
                                     *          and while doing so, hits the delete
                                     *          key.
                                     */
                                    if (layer.toString() === 'BackgroundBitmapImageLayer') {
                                        var $target = $(event.target);
                                        if (
                                            $target.tag() !== 'input'
                                            || (
                                                $target.tag() === 'input'
                                                && $target.attr('type') !== 'text'
                                            )
                                        ) {
                                            event.preventDefault();
                                            var canvas = Canvases.Preview;
                                            ChangeHistory.clearOperationType();
                                            layer.setChangeOperationType('deleted');
                                            canvas.clearBackgroundImageLayer();
                                            canvas.render();
                                            canvas.getBackgroundRectangleLayer().select();
                                        }
                                    } else if (layer.toString() !== 'BackgroundRectangleLayer') {
                                        var drawing = layer.getDrawing();

                                        /**
                                         * There was a bug whereby if the user
                                         * highlighted text by dragging, and
                                         * their mouse ended up outside the
                                         * canvas, clicking delete would delete
                                         * the whole text field. I account for
                                         * this by checking if the fabric object
                                         * is currently being edited below, in
                                         * cases where the drawing is a
                                         * TextDrawing object.
                                         */
                                        if (
                                            drawing.toString() !== 'TextDrawing'
                                            || drawing.getCotton().isEditing === false
                                        ) {
                                            var $target = $(event.target);
                                            if (
                                                $target.tag() !== 'input'
                                                || (
                                                    $target.tag() === 'input'
                                                    && $target.attr('type') !== 'text'
                                                )
                                            ) {
                                                event.preventDefault();
                                                layer.triggerHandler('delete', [
                                                    {
                                                        trigger: 'key.delete'
                                                    }
                                                ]);
                                            }
                                        }

                                        /**
                                         * 
                                         */
                                        if (layer.toString() === 'WatermarkBitmapImageLayer') {
                                            layer.getWatermark().set({
                                                'settings.active': 0
                                            });
                                            layer.getWatermark().save([
                                                'settings.active'
                                            ]);
                                        }
                                    } else {
                                        var $target = $(event.target);
                                        if (
                                            $target.tag() !== 'input'
                                            || (
                                                $target.tag() === 'input'
                                                && $target.attr('type') !== 'text'
                                            )
                                        ) {
                                            event.preventDefault();
                                            var backgroundColor = layer.getStyle('backgroundColor');
                                            backgroundColor = ColorUtils.addSpaces(backgroundColor);
                                            if (backgroundColor !== ColorUtils.getBlack('rgba', 0)) {

                                                /**
                                                 * It's important that the color
                                                 * value is formatted exactly as
                                                 * it is below (including
                                                 * spaces), because the rest of
                                                 * the platform formats things
                                                 * this way, and if the
                                                 * formatting is different, it
                                                 * can cause issues with the
                                                 * ChangeHistory system (since
                                                 * it might think something is
                                                 * different in the image, even
                                                 * if it's just formatting).
                                                 */
                                                var white = ColorUtils.getWhite('rgba');
                                                if (backgroundColor === white) {
                                                    Toolbars.getToolbar('backgroundRectangle').triggerHandler('clear/backgroundColor');
                                                } else {
                                                    Canvases.Preview.getSelectedLayer().triggerHandler(
                                                        'change/backgroundColor',
                                                        [white, true]
                                                    );
                                                    Toolbars.getToolbar('backgroundRectangle').show();
                                                }
                                            } else {
                                                var white = ColorUtils.getWhite('rgba');
                                                Canvases.Preview.getSelectedLayer().triggerHandler(
                                                    'change/backgroundColor',
                                                    [white, true]
                                                );
                                                Toolbars.getToolbar('backgroundRectangle').show();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.directional
                 * 
                 * Allows for directional-key-based positioning. Directional
                 * keys in this case are the up, down, right and left keys.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.directional': function() {
                    App.getElement().on({
                        'keydown': function(event) {
                            var layer = Canvases.Preview.getSelectedLayer();
                            if (
                                layer !== false
                                && layer.toString() !== 'BackgroundBitmapImageLayer'
                                && layer.toString() !== 'BackgroundRectangleLayer'
                            ) {
                                var $target = $(event.target);
                                if (
                                    $target.tag() !== 'input'
                                    || (
                                        $target.tag() === 'input'
                                        && $target.attr('type') !== 'text'
                                    )
                                ) {
                                    // Left
                                    if (event.which === 37) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/left');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                    // Up
                                    else if (event.which === 38) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/up');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                    // Right
                                    else if (event.which === 39) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/right');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                    // Down
                                    else if (event.which === 40) {
                                        event.preventDefault();
                                        layer.triggerHandler('move/down');
                                        // layer.getDrawing().getCotton().trigger('lock');
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.enter
                 * 
                 * Allows for enter-key-based text editing.
                 * 
                 * @note    Checking for a modal open, since in a modal, hitting
                 *          enter ought to submit for the form; not possibly
                 *          focus on a text layer.
                 *          https://i.imgur.com/wEll3Ab.png
                 * @access  protected
                 * @return  void
                 */
                'key.enter': function() {
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.which === 13) {
                                var canvas = Canvases.Preview,
                                    layer = canvas.getSelectedLayer();
                                if (layer !== false) {
                                    var modalOpen = Modals.getOpen().length > 0;
                                    if (modalOpen === false) {
                                        var drawing = layer.getDrawing();
                                        if (drawing.toString() === 'TextDrawing') {
                                            if (layer.getCotton().isEditing === false) {

                                                // This is to allow for toolbar
                                                // input changes via enter key
                                                var $target = $(event.target);
                                                if (
                                                    $target.tag() !== 'input'
                                                    || (
                                                        $target.tag() === 'input'
                                                        && $target.attr('type') !== 'text'
                                                    )
                                                ) {
                                                    event.preventDefault();
                                                    var cotton = layer.getCotton();
                                                    layer.select();
                                                    canvas.render();
                                                    // canvas.getCotton().setActiveObject(cotton);
                                                    cotton.enterEditing();
                                                    cotton.selectAll();
                                                }
                                            }
                                        } else {
                                            if (drawing.toString() === 'BackgroundRectangleDrawing') {

                                                // This is to allow for toolbar
                                                // input changes via enter key
                                                var $target = $(event.target);
                                                if (
                                                    $target.tag() !== 'input'
                                                    || (
                                                        $target.tag() === 'input'
                                                        && $target.attr('type') !== 'text'
                                                    )
                                                ) {
                                                    event.preventDefault();
                                                    var layer = canvas.addTextLayer(),
                                                        drawing = layer.getDrawing();
                                                    layer.setChangeOperationType('added');
                                                    drawing.once({
                                                        'draw': function(event) {
                                                            this.select();
                                                            drawing.animate();
                                                        }
                                                    });
                                                    drawing.draw();
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.escape
                 * 
                 * Allows for escape-key blurring of layer. Requires the
                 * following:
                 * - Escape key pressed (code: 27)
                 * - Layer selected
                 * - Layer not in editing mode (incase text)
                 * - Target element when key pressed down is not an <input>
                 *   element,
                 *   or it's got a type of "range" or "checkbox"
                 * - Dropdown menu for fonts not open (since escape key here is
                 *   more important from a UX perspective).
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.escape': function() {
                    App.getElement().on({
                        'keydown': function(event) {
                            if (event.which === 27) {
                                var canvas = Canvases.Preview,
                                    layer = canvas.getSelectedLayer();
                                if (layer !== false) {
                                    var drawing = layer.getDrawing(),
                                        cotton = layer.getCotton(),
                                        $target = $(event.target);
                                    if (drawing.toString() === 'TextDrawing') {
                                        if (cotton.isEditing === false) {
                                            if (
                                                (
                                                    $target.tag() !== 'input'
                                                    || $target.attr('type') === 'range'
                                                    || $target.attr('type') === 'checkbox'
                                                )
                                                /**
                                                 * This is to prevent a bug that
                                                 * comes up when leaving the
                                                 * GoogleFonts modal. Leaving it
                                                 * causes focus to be made on
                                                 * the search input of the
                                                 * active editor tab, which is
                                                 * naturally an input tag. So we
                                                 * check for that here.
                                                 * 
                                                 * @see     https://i.imgur.com/bZn6Gm1.png
                                                 */
                                                || (
                                                    $target.hasClass('search') === true
                                                )
                                            ) {
                                                if (Toolbars.getVisibleToolbar().colorPickerVisible() === false) {
                                                    if (
                                                        Toolbars.getToolbar('text').getFontsDropdown().getElement().hasClass('open') === false
                                                    ) {
                                                        event.preventDefault();
                                                        canvas.deselectSelectedLayer();
                                                    }
                                                }
                                            }
                                        }
                                        /**
                                         * This is a fix to a fabric bug,
                                         * whereby if the user started
                                         * editing a text drawing,
                                         * highlighted some text, but during
                                         * that highlight process their
                                         * mouse left the canvas, clicking
                                         * the escape key woud not do
                                         * anything. I believe the issue
                                         * exists because fabric is
                                         * listening for events in the
                                         * canvas, which can't be accessed
                                         * in this case because the event is
                                         * happening elsewhere (the html
                                         * element outside of the canvas).
                                         * So to deal with this, I just
                                         * ensure the layer exits editing
                                         * mode.
                                         */
                                        else {
                                            cotton.exitEditing();
                                            drawing.select();
                                            // canvas.getCotton().setActiveObject(cotton);
                                        }
                                    } else {

                                        /**
                                         * Prevents escaping when, for
                                         * example, the user is changing the
                                         * color of a vector, and tries to
                                         * blur focus from the color picker.
                                         */
                                        if (
                                            (
                                                $target.tag() !== 'input'
                                                || $target.attr('type') === 'range'
                                            )
                                            && (
                                                Toolbars.getVisibleToolbar().colorPickerVisible() === false
                                            )
                                        ) {
                                        // if ($target.tag() !== 'input') {
                                            event.preventDefault();
                                            canvas.deselectSelectedLayer();
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                /**
                 * key.tab
                 * 
                 * Allows for tabbing and shift-tabbing between layers.
                 * 
                 * @access  protected
                 * @return  void
                 */
                'key.tab': function() {
                    var _this = this;
                    App.getElement().on({
                        'keydown': function(event) {
                            _this._handleTabEvent(event);
                        }
                    });
                }
            };
        },

        /**
         * _fabricGuides
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _fabricGuides: {},

        /**
         * _facebookAdGrid
         * 
         * @access  protected
         * @var     Object (default: [])
         */
        // _facebookAdGrid: [],

        /**
         * _htmlGuides
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _htmlGuides: {},

        /**
         * _max
         * 
         * Object that has the maximum size of the canvas defined. There are
         * three possible hashes. <absolute> defines the maximum across browser
         * resolutions, <viewport> defines the maximum values according to the
         * space within the canvas container (after instantiation). Defined
         * defines what should be actually used during canvas drawing/resizing.
         * 
         * This will be defined by:
         * - Math.min(absolute.height, viewport.height)
         * - Math.min(absolute.width, viewport.width)
         * 
         * @access  protected
         * @var     Object
         */
        _max: {
            absolute: {
                // height: 600,
                // width: 600
                height: 900,
                width: 900
            },
            defined: {
                height: false,
                width: false
            },
            viewport: {
                height: false,
                width: false
            }
        },

        /**
         * _positionMap
         * 
         * Tracks the position of background images, within the context of a
         * Frame, so that if a user sets a position in, for example, a Pinterest
         * Frame, switches to a Facebook one, sets the background image position
         * relative to that Frame, and then switches back, it remembers where
         * the background image was (manully, purposefully) set for the
         * Pinterest one.
         * 
         * Without this, it can feel disjointed when you position your
         * background image, switch to a frame and think "Ahh, I don't want this
         * one", switch back, and now your background image isn't set to where
         * it was before.
         * 
         * An exception here is if the user loads the app, sees a background
         * image in a specific place, switches to a different Frame before
         * adjusting the position of the background image at all, adjusts the
         * background image in that new Frame, and then switches back to the
         * first one, the background image will be adjusted relative to the
         * positioning data for the second Frame. This is because this hash
         * won't contain any data on the initial Frame, since the user didn't
         * interact with it.
         * 
         * I could update this to ensure this data is present as soon as an
         * image is set as a background image on a Frame, but not sure if that's
         * needed.
         * 
         * Frame positioning works in such a way that it'll always try to
         * best-guess the position of a background image relative to a frame
         * since the position coordinates (left/top) are relative numbers.
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _positionMap: {},

        /**
         * _previouslySelectedLayer
         * 
         * Tracks the previously selected layer, for usage with font preview
         * closing.
         * 
         * @access  protected
         * @var     false|Layer (default: false)
         */
        _previouslySelectedLayer: false,

        /**
         * _selectedLayer
         * 
         * @access  protected
         * @var     Layer (default: false)
         */
        _selectedLayer: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'PreviewCanvasView')
         */
        _string: 'PreviewCanvasView',

        /**
         * init
         * 
         * @see     http://alvarotrigo.com/blog/firing-resize-event-only-once-when-resizing-is-finished/
         * @note    Order here is very important
         * @todo    Don't run a refresh if the canvas size hasn't actually
         *          changed. Waste of resources.
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupCotton();
            window.Canvases.Preview = this;
            this._setupFabricGuides();
            // this._setupHtmlGuides();
            this._setMaximumsDimensions();
            this._setupAuth();
            this._setupEvents();
            // this._listenForLockedChange();
        },

        /**
         * _handleTabEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @return  void
         */
        _handleTabEvent: function(event) {
            if (this._validTabEvent(event) === true) {
                var layer = Canvases.Preview.getSelectedLayer();
                event.preventDefault();
                if (event.shiftKey === true) {
                    layer.goto.previous.apply(layer);
                } else {
                    layer.goto.next.apply(layer);
                }
            }
        },

        /**
         *_listenForLockedChange
         * 
         * @access  protected
         * @return  void
         */
       // _listenForLockedChange: function() {
       //      Stencil.account().draft().on({
       //          'change/settings.locked': function(event, value) {
       //              var $lock = App.getStage().getContent().find('div.sandbox a.lock');
       //              $lock.addClass('hidden');
       //              if (value.toInt() === 1) {
       //                  $lock.removeClass('hidden');
       //              }
       //          }
       //      });
       //  },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            var unlockLayers = function() {
                var lockedLayers = Stencil.account().draft().getImageDocument().getLockedLayers();
                if (lockedLayers.length > 0) {
                    jQuery.each(lockedLayers, function(index, layer) {
                        layer.setProperty('locked', false);
                    });
                }
                ChangeHistory.syncLockedOperations();
            };
            User.once({
                'login': function(event, user) {
                    if (
                        User.admin() === true
                        || User.editor() === true
                        || Account.upgraded() === true
                    ) {
                        unlockLayers();
                    }
                }
            });
            Account.once({
                'upgrade': unlockLayers
            });
        },

        /**
         *_setupEvents
         * 
         * @access  protected
         * @return  void
         */
        _setupEvents: function() {
            var _this = this;
            this._events = this._events();
            jQuery.each(
                this._events,
                function(type, event) {
                    event.apply(_this);
                }
            );
        },

        /**
         * _setupCotton
         * 
         * @access  protected
         * @return  void
         */
        _setupCotton: function() {
            this._super();
            this._element.parent().addClass('preview-canvas-container');
        },

        /**
         * _setupFabricGuides
         * 
         * @access  protected
         * @return  void
         */
        _setupFabricGuides: function() {
            var options = {
                    visible: false,
                    strokeDashArray: [5, 5],
                    // stroke: '#aaa',
                    stroke: ColorUtils.getBlack('rgba', 0.65),
                    selectable: false,
                    strokeWidth: 1
                },
                horizontal = [
                    new fabric.Line([0, 0, 0, 0], options),
                    new fabric.Line([0, 0, 0, 0], options)
                ],
                vertical = [
                    new fabric.Line([0, 0, 0, 0], options),
                    new fabric.Line([0, 0, 0, 0], options)
                ];
            this._cotton.add(horizontal[0]);
            this._cotton.add(horizontal[1]);
            this._cotton.add(vertical[0]);
            this._cotton.add(vertical[1]);

            // Backgrounds
            options.stroke = ColorUtils.getWhite('rgba', 0.65);
            options.strokeDashArray = false;
            var backdrop = [
                new fabric.Line([0, 0, 0, 0], options),
                new fabric.Line([0, 0, 0, 0], options)
            ];
            horizontal[0].backdrop = backdrop[0];
            horizontal[1].backdrop = backdrop[1];
            this._cotton.add(backdrop[0]);
            this._cotton.add(backdrop[1]);
            backdrop = [
                new fabric.Line([0, 0, 0, 0], options),
                new fabric.Line([0, 0, 0, 0], options)
            ];
            vertical[0].backdrop = backdrop[0];
            vertical[1].backdrop = backdrop[1];
            this._cotton.add(backdrop[0]);
            this._cotton.add(backdrop[1]);

            // 
            this._fabricGuides.vertical = vertical;
            this._fabricGuides.horizontal = horizontal;

            // 
            this._cotton.on({
                'mouse:move': function(options) {
                    vertical[0].set('visible', false);
                    vertical[1].set('visible', false);
                    vertical[0].backdrop.set('visible', false);
                    vertical[1].backdrop.set('visible', false);
                    horizontal[0].set('visible', false);
                    horizontal[1].set('visible', false);
                    horizontal[0].backdrop.set('visible', false);
                    horizontal[1].backdrop.set('visible', false);
                }
            });
        },

        /**
         * _setupHtmlGuides
         * 
         * @access  protected
         * @return  void
         */
        _setupHtmlGuides: function() {
            var $app = App.getElement();
            this._cotton.on({
                'object:moving': function(options) {
                    var $guides = $app.find('div.guides');
                    $guides.find('div.guide').addClass('hidden');
                }
            });
        },

        /**
         * _setMaximumsDimensions
         * 
         * This method sets the maximum possible width and height that a canvas
         * can be set to. Values are set to be the lowest between the viewport
         * (set to a maximum of 70% of available space) and an absolute defined
         * Stencil-wide.
         * 
         * @access  protected
         * @return  void
         */
        _setMaximumsDimensions: function() {
            var $content = App.find('section.stage > div.inner > div.content'),
                $outer = $content.find('> div.outer'),
                height,
                width;
            $outer.addClass('hidden');
            height = $content.height();
            width = $content.width();
            $outer.removeClass('hidden');
            this._max.viewport = {
                // height: Math.floor(height * 0.7),
                height: Math.floor(height * 0.75),
                // width: Math.floor(width * 0.7)
                width: Math.floor(width * 0.85)
            };
            this._max.defined.height = Math.min(
                this._max.absolute.height,
                this._max.viewport.height
            );
            this._max.defined.width = Math.min(
                this._max.absolute.width,
                this._max.viewport.width
            );
        },

        /**
         * _resizeCanvas
         * 
         * @access  protected
         * @return  void
         */
        _resizeCanvas: function() {

            // Get maximum dimension allowed
            var max = this._max.defined,
                ratio = Frame.getRatio(),
                width, height;

            // Square: just set to the lowest of the max width/height
            if (ratio === 1) {
                width = height = Math.min(max.height, max.width);
            } else {

                // Wide rectangle
                var scale;
                if (ratio > 1) {

                    // Frame width is smaller than max allowed
                    if (Frame.get('width').toInt() < max.width) {
                        width = Frame.get('width').toInt();
                        height = Frame.get('height').toInt();

                        // Frame height is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                    // Frame width is larger than max allowed
                    else {
                        width = max.width;
                        scale = Frame.get('width').toInt() / width;
                        height = Frame.get('height').toInt() / scale;

                        // Converted/relative height is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                }
                // Tall rectangle
                else {

                    // Frame height is smaller than max allowed
                    if (Frame.get('height').toInt() < max.height) {
                        width = Frame.get('width').toInt();
                        height = Frame.get('height').toInt();

                        // Frame width is larger than max allowed
                        if (height > max.height) {
                            height = max.height;
                            scale = Frame.get('height').toInt() / height;
                            width = Frame.get('width').toInt() / scale;
                        }
                    }
                    // Frame height is larger than max allowed
                    else {
                        height = max.height;
                        scale = Frame.get('height').toInt() / height;
                        width = Frame.get('width').toInt() / scale;

                        // Converted/relative widht is larger than max allowed
                        if (width > max.width) {
                            width = max.width;
                            scale = Frame.get('width').toInt() / width;
                            height = Frame.get('height').toInt() / scale;
                        }
                    }
                }
            }

            // Resize to maximum allowed
            this._cotton.resizeTo(width.ceil(), height.ceil());
        },

        /**
         * _validTabEvent
         * 
         * @note    Checking for a modal open, since in a modal, tabbing
         *          ought to toggle between inputs; not any possibly
         *          selected layer. Use case for this:
         *          https://i.imgur.com/oO3imXE.png
         * @note    It looks like keyCode may not always be available; when I
         *          used toInt on it, I got a report via Sentry within
         *          30-minutes that keyCode may be undefined. So don't use that
         *          method.
         * @access  protected
         * @param   jQuery event
         * @return  Boolean
         */
        _validTabEvent: function(event) {
            if (event.which !== 9) {
                return false;
            }
            var layer = Canvases.Preview.getSelectedLayer();
            if (layer === false) {
                return false;
            }
            var modalsOpen = Modals.getOpen();
            if (modalsOpen.length > 0) {
                return false;
            }
            var $target = $(event.target);
            if ($target.parents('.toolbar').length > 0) {
                var $inputs = Toolbars.getVisibleToolbar().find('input[type="text"]');
                if ($inputs.length > 1) {
                    if (event.shiftKey === false) {
                        var $last = $inputs.last();
                        if ($target.is($last) === false) {
                            return false;
                        }
                    } else {
                        var $first = $inputs.first();
                        if ($target.is($first) === false) {
                            return false;
                        }
                    }
                }
            }
            return true;
        },

        /**
         * addTextLayer
         * 
         * @access  public
         * @param   Object options
         * @return  TextLayer
         */
        addTextLayer: function(options) {
            options = options || {};
            var properties = {
                    locked: false,
                    styles: {
                        align: options.align || 'center',
                        angle: 0,
                        // backdropColor: '#00ff00',
                        backdropColor: false,
                        backdropPaddingFactor: Config.default('backdropPaddingFactor'),
                        backdropStretch: 'slim',
                        bold: false,
                        fontFamily: options.fontFamily || Stencil.account().getDefaultFontFamily(),
                        fontSize: options.fontSize || 50,
                        italic: false,
                        left: options.left || 50,
                        lineHeight: 1.1,
                        shadowStrength: 0,
                        strokeColor: false,
                        strokeWidthDividingFactor: Config.default('strokeWidthDividingFactor'),
                        // textColor: 'rgba(69, 69, 69, 1)',// #454545
                        textColor: ColorUtils.getBlack('rgba'),// #000000
                        top: options.top || 50,
                        underline: false,
                        width: options.width || 30
                    },
                    // text: 'I repeat. We are out of Bort license plates!',
                    text: options.text || 'Text',
                    type: 'text'
                },
                textLayers = this._image.getImageDocument().getTextLayers(),
                layer;
            properties.styles.order = this._image.getImageDocument().getOrderedLayers(false).length;

            // Inheritance
            if (textLayers.length > 0) {
                var index = textLayers.length - 1;
                if (options.align === undefined) {
                    properties.styles.align = textLayers[index].getStyle('align');
                }
                properties.styles.bold = textLayers[index].getStyle('bold');
                if (options.align === undefined) {
                    properties.styles.fontFamily = textLayers[index].getStyle('fontFamily');
                }
                if (options.fontSize === undefined) {
                    properties.styles.fontSize = textLayers[index].getStyle('fontSize');
                }
                properties.styles.italic = textLayers[index].getStyle('italic');
                properties.styles.lineHeight = textLayers[index].getStyle('lineHeight');
                properties.styles.textColor = textLayers[index].getStyle('textColor');
            }

            // Create and run overhead
            layer = new TextLayer(
                properties,
                this._image.getImageDocument()
            );
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            // layer.getDrawing().draw();
            return layer;
        },

        /**
         * addForegroundBitmapImageLayer
         * 
         * @access  public
         * @param   Object options
         * @return  ForegroundBitmapImageLayer
         */
        addForegroundBitmapImageLayer: function(options) {
            options = options || {};
            var properties = {
                    filters: [],
                    image: options.image,
                    locked: options.locked === undefined ? false : options.locked,
                    styles: {
                        angle: 0,
                        flipX: false,
                        flipY: false,
                        left: options.left || 50,
                        stretchX: 1,
                        stretchY: 1,
                        top: options.top || 50,
                        width: 30
                    },
                    type: 'image'
                },
                layer;
            properties.styles.order = this._image.getImageDocument().getOrderedLayers(false).length;
            layer = new ForegroundBitmapImageLayer(
                properties,
                this._image.getImageDocument()
            );
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            return layer;
        },

        /**
         * addVectorImageLayer
         * 
         * Sets the color of the added vector to either the default, or else if
         * a vector has already been drawn to the canvas, grabs that color
         * (which makes a large assumption).
         * 
         * @access  public
         * @param   Object options
         * @param   Boolean color
         * @return  VectorImageLayer
         */
        addVectorImageLayer: function(options, color) {
            options = options || {};
            var properties = {
                    color: color === true,
                    filters: [],
                    image: options.image,
                    locked: options.locked === undefined ? false : options.locked,
                    styles: {
                        angle: 0,
                        // fillColor: ColorUtils.getBlack('rgba'),
                        // fillColor: ColorUtils.getBlack('rgba', 0),
                        // fillColor: 'rgba(255, 0, 0, 1)',
                        flipX: false,
                        flipY: false,
                        left: options.left || 50,
                        stretchX: 1,
                        stretchY: 1,
                        top: options.top || 50,
                        width: 15
                    },
                    type: 'image',
                    vector: true
                },
                layer;
            if (color === false) {
                properties.styles.fillColor = ColorUtils.getBlack('rgba');
            } else {
                properties.styles.opacity = 1;
            }
            properties.styles.order = this._image.getImageDocument().getOrderedLayers(false).length;

            // Inheritance
            if (color === false) {
                var bWVectorImageLayers = this._image.getImageDocument().getBwVectorImageLayers();
                if (bWVectorImageLayers.length > 0) {
                    var index = bWVectorImageLayers.length - 1;
                    properties.styles.fillColor = bWVectorImageLayers[index].getStyle('fillColor');
                }
            }

            // Overhead
            if (color === false) {
                layer = new VectorImageLayer(
                    properties,
                    this._image.getImageDocument()
                );
            } else {
                layer = new ColorVectorImageLayer(
                    properties,
                    this._image.getImageDocument()
                );
            }
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            return layer;
        },

        /**
         * addWatermarkBitmapImageLayer
         * 
         * @access  public
         * @param   Object properties
         * @return  WatermarkBitmapImageLayer
         */
        addWatermarkBitmapImageLayer: function(properties) {
            properties.locked = false;
            properties.styles.order = this._image.getImageDocument().getOrderedLayers().length;
            layer = new WatermarkBitmapImageLayer(
                properties,
                this._image.getImageDocument()
            );
            this._image.getImageDocument().addLayer(layer);
            this._image.getImageDocument().reorderWatermarks();
            return layer;
        },

        /**
         * addWindowResizeListener
         * 
         * @access  public
         * @return  void
         */
        addWindowResizeListener: function() {
            var delay = Stencil.getResizeDelay('canvas'),
                callback = _.debounce(
                    this.resize.proxy(this),
                    delay
                );
            $(window).on({
                'resize': callback
            });
        },

        /**
         * addWindowOrientationChangeListener
         * 
         * Listener for orientation change needed to happen, because at times on
         * Adam's iPad, the resize function would not be triggered when he
         * changed his orientation. So to be safe, I trigger a resize on
         * orientation change as well.
         * 
         * Not sure if this will cause a problem since resize might be called
         * twice (especially since the debounce reference is different). Might
         * want to look into this, or else use a common debounce reference.
         * 
         * @todo    Look into the note above on possibly multiple calls to
         *          resize.
         * @access  public
         * @return  void
         */
        addWindowOrientationChangeListener: function() {
            var delay = Stencil.getResizeDelay('canvas'),
                callback = _.debounce(
                    this.resize.proxy(this),
                    delay
                );
            $(window).on({
                'orientationchange': callback
            });
        },

        /**
         * clear
         * 
         * Filter here is made against the position being greater than
         * or equal to two. This is because the first two layers are the
         * BackgroundRectangleLayer and BackgroundBitmapImageLayer.
         * 
         * Note that I need to perform a set + save against the sourceImageId
         * property, rather than a push, because a push does a checks
         * 
         * @access  public
         * @param   Boolean prompt
         * @param   undefined|String promptType
         * @return  void
         */
        clear: function(prompt, promptType) {

            /**
             * callback
             * 
             * @access  private
             * @param   Boolean clearWatermarks
             * @return  void
             */
            var callback = function(clearWatermarks) {
                var layers = this._image.getImageDocument().getOrderedLayers(
                    clearWatermarks === true
                );
                jQuery.each(layers, function(index, layer) {
                    layer.triggerHandler('delete');
                    if (layer.toString() === 'WatermarkBitmapImageLayer') {
                        layer.getWatermark().push('settings.active', 0);
                    }
                });
                this.resetBackgroundRectangleLayer();
                this.clearBackgroundImageLayer();
                this.render();
                var draft = Stencil.account().draft();
                draft.removeSourceImage();
                // if (Account.draftIsLocked() === true) {
                //     draft.set({
                //         'settings.locked': 0
                //     });
                //     draft.save(['settings.locked']);
                // }
            };

            /**
             * 
             */
            if (prompt === true) {
                var _this = this;
                if (promptType === 'unsaved') {
                    this.unsavedChangesClearCanvasConfirm().on({
                        'yes': function(event) {
                            ChangeHistory.setOperationType('image // newImage:created');
                            callback.apply(_this, [this.clearWatermarks()]);
                        }
                    });
                } else {
                    this.clearCanvasConfirm().on({
                        'yes': function(event) {
                            ChangeHistory.setOperationType('image // cleared');
                            callback.apply(_this, [this.clearWatermarks()]);
                        }
                    });
                }
            } else {
                ChangeHistory.setOperationType('image // newImage:created');
                callback.apply(this, [false]);
            }
        },

        /**
         * clearCanvasConfirm
         * 
         * @access  public
         * @return  ConfirmModal
         */
        clearCanvasConfirm: function() {
            var h1 = 'Clearing will remove all images and text.',
                h2 = 'Are you sure?',
                modal = Modals.showClearCanvasConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function(event) {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        },

        /**
         * clearBackgroundImageLayer
         * 
         * @access  public
         * @return  void
         */
        clearBackgroundImageLayer: function() {
            var layer = this.getBackgroundBitmapImageLayer();
            layer.clearFilters();
            if (layer.getProperty('image') !== false) {
                layer.setImage(false);
            }
        },

        /**
         * deselectSelectedLayer
         * 
         * @access  public
         * @return  void
         */
        deselectSelectedLayer: function() {
            var layer = this.getSelectedLayer();
            this._cotton.discardActiveObject();
            this.setSelectedLayer(false);
            Toolbars.hide();
            if (layer !== false) {
                var drawing = layer.getDrawing();
                drawing.bb.hide.apply(drawing);
            }
        },

        /**
         * draw
         * 
         * @access  public
         * @param   Boolean showBusyModal This variable was introduced to offer
         *          up the option of not showing the busy modal when the image
         *          being redrawn was being done so through a redo / undo action
         * @return  void
         */
        draw: function(showBusyModal) {
            var start = new Date();
            this.set({drawing: true});
            if (showBusyModal === true) {
                this.getBusy().show();
            }
            this._image.getImageDocument().mergeWatermarks();
            this._image.getImageDocument().setupLayers();
            this._image.getImageDocument().sortLayers();
            this.once({
                'draw': function(event) {
                    this.render();
                },
                'render': function(event) {
                    this.set({drawing: false});
                    if (showBusyModal === true) {
                        var busy = this.getBusy();
                        busy.hide.minDelay(start, 500, busy);
                    }
                }
            });
            this.drawLayers();
        },

        /**
         * getActiveBackgroundLayer
         * 
         * Returns the active background layer. Note that the active background
         * may not actually be selected. For example, the user could have a
         * text layer selected (eg. the TextToolbar is open), but calling this
         * method will return the BackgroundRectangleLayer if no image is set
         * as the background, or else the BackgroundBitmapImageLayer.
         * 
         * @access  public
         * @return  BackgroundBitmapImageLayer|BackgroundRectangleLayer
         */
        getActiveBackgroundLayer: function() {
            var backgroundBitmapImageLayer = this.getBackgroundBitmapImageLayer();
            if (backgroundBitmapImageLayer.getProperty('image') !== false) {
                return backgroundBitmapImageLayer;
            }
            return this.getBackgroundRectangleLayer();
        },

        /**
         * getBackgroundRectangleLayer
         * 
         * @access  public
         * @return  BackgroundRectangleLayer
         */
        getBackgroundRectangleLayer: function() {
            return this._image.getImageDocument().getBackgroundRectangleLayer();
        },

        /**
         * getBusy
         * 
         * @access  public
         * @return  BusyModalView
         */
        getBusy: function() {
            if (this._busy === false) {
                var $busy = DataUtils.render('BusyModal');
                this._busy = new BusyModalView($busy);
                this._element.parent('.canvas-container').append($busy);
            }
            return this._busy;
        },

        /**
         * getFabricGuides
         * 
         * @access  public
         * @return  Object
         */
        getFabricGuides: function() {
            return this._fabricGuides;
        },

        /**
         * getForegroundBitmapImageLayers
         * 
         * @access  public
         * @return  Array
         */
        getForegroundBitmapImageLayers: function() {
            return this._image.getImageDocument().getForegroundBitmapImageLayers();
        },

        /**
         * getHtmlGuides
         * 
         * @access  public
         * @return  Object
         */
        getHtmlGuides: function() {
            var $app = App.getElement(),
                $guides = $app.find('div.guides');
            return $guides.find('div.guide');
        },

        /**
         * getImageDocument
         * 
         * @access  public
         * @return  ImageDocument
         */
        // getImageDocument: function() {
        //     return this._image.getImageDocument();
        // },

        /**
         * getPreviouslySelectedLayer
         * 
         * @access  public
         * @return  false|Layer
         */
        getPreviouslySelectedLayer: function() {
            return this._previouslySelectedLayer;
        },

        /**
         * getSelectedLayer
         * 
         * @access  public
         * @return  false|Layer
         */
        getSelectedLayer: function() {
            return this._selectedLayer;
        },

        /**
         * getWatermarkLayers
         * 
         * @access  public
         * @return  Array
         */
        getWatermarkLayers: function() {
            return this._image.getImageDocument().getWatermarkLayers();
        },

        /**
         * refreshLayers
         * 
         * @note    A <drawn> check is made against the drawing to prevent trying
         *          to, for example, resize a vector image that hasn't yet been
         *          fully loaded. An example of when this might happen:
         *          You load the app, and while it's loading, resize your window.
         *          Since one of the vectors may have yet been drawn, it doesn't
         *          make sense to refresh it. If that happens, I wait for the
         *          drawn event on the layer before trying to refresh it again.
         * @access  public
         * @return  void
         */
        refreshLayers: function() {
            this._resizeCanvas();
            var _this = this,
                drawing,
                layer,
                layers = this._image.getImageDocument().getLayers(true),
                length = layers.length,
                next = function(index) {
                    layer = layers[index];
                    drawing = layer.getDrawing();
                    if (drawing.drawn() === true) {
                        drawing.once({
                            'refresh': function(event) {
                                if (index !== length - 1) {
                                    next(index + 1);
                                } else {
                                    _this.triggerHandler('refresh');
                                }
                            }
                        });
                        drawing.refresh();
                    } else {
                        drawing.once({
                            'draw': function(event) {
                                next(index);
                            }
                        });
                    }
                };
            next(0);
        },

        /**
         * resetBackgroundRectangleLayer
         * 
         * @access  public
         * @return  void
         */
        resetBackgroundRectangleLayer: function() {
            var layer = this.getBackgroundRectangleLayer();
            layer.triggerHandler('reset/backgroundColor');
        },

        // /**
        //  * setBackgroundBitmapImage
        //  * 
        //  * @access  public
        //  * @param   String resource
        //  * @return  BackgroundBitmapImageLayer
        //  */
        // setBackgroundBitmapImage: function(resource) {
        //     options = options || {};
        //     var properties = {
        //             background: true,
        //             resource: options.resource,
        //             styles: {
        //                 left: options.left || 50,
        //                 top: options.top || 50,
        //                 position: 1,
        //                 visible: true
        //             },
        //             type: 'image'
        //         },
        //         layer;
        //     layer = new BackgroundBitmapImageLayer(properties, this._image.getImageDocument());
        //     this._image.getImageDocument().addLayer(layer);
        //     this._image.getImageDocument().reorderWatermarks();
        //     return layer;
        // },

        /**
         * resize
         * 
         * @access  public
         * @return  void
         */
        resize: function() {
            this._setMaximumsDimensions();
            this.deselectSelectedLayer();
            this.once({
                'refresh': function(event) {
                    this.render();
                }
            });
            this.refreshLayers();
        },

        /**
         * restoreFrameSpecificPosition
         * 
         * @access  public
         * @return  void
         */
        restoreFrameSpecificPosition: function() {
            var layer = this.getBackgroundBitmapImageLayer(),
                image = layer.getProperty('image'),
                key = Frame.get('key'),
                position;
            if (image !== false) {
                position = {
                    left: layer.getStyle('left'),
                    top: layer.getStyle('top')
                };
                if (typeof this._positionMap[image] !== 'undefined') {
                    if (typeof this._positionMap[image][key] !== 'undefined') {
                        position = this._positionMap[image][key];
                        layer.setStyles(position);
                        layer.triggerHandler('position/restored');
                    } else {
                        layer.setStyles(position);
                    }
                } else {
                    layer.setStyles(position);
                }
            }
        },

        /**
         * setSelectedLayer
         * 
         * Sets the passed in Layer as the the selected one in the canvas, which
         * is then used to determine which layer should be affected when events
         * happen (for example, key-nudging).
         * 
         * It's worth noting that I'm keeping track of the previously selected
         * layer, as it's being used the TextToolbar view. In that case, it's
         * used to determine which layer should have it's font-family reinstated
         * if the font dropdown is shown, and then the user clicks elsewhere on
         * the canvas (or on another layer).
         * 
         * @access  public
         * @param   false|Layer layer
         * @return  void
         */
        setSelectedLayer: function(layer) {
            this._previouslySelectedLayer = this._selectedLayer;
            this._selectedLayer = layer;
        },

        /**
         * trackBackgroundImageLayerPosition
         * 
         * @access  public
         * @return  void
         */
        trackBackgroundImageLayerPosition: function() {
            var layer = this.getBackgroundBitmapImageLayer(),
                image = layer.getProperty('image'),
                key = Frame.get('key');
            if (typeof this._positionMap[image] === 'undefined') {
                this._positionMap[image] = {};
            }
            if (typeof this._positionMap[image][key] === 'undefined') {
                this._positionMap[image][key] = {};
            }
            this._positionMap[image][key].left = layer.getStyle('left');
            this._positionMap[image][key].top = layer.getStyle('top');
        },

        /**
         * unsavedChangesClearCanvasConfirm
         * 
         * @access  public
         * @return  ClearCanvasConfirmModalView
         */
        unsavedChangesClearCanvasConfirm: function() {
            // var h1 = 'You have unsaved changes.<br />Creating a new image will remove all images and text.',
            var h1 = 'You have unsaved changes.',
                h2 = 'Are you sure you\'d like to proceed?',
                modal = Modals.showClearCanvasConfirm({
                    h1: h1,
                    h2: h2
                });
            modal.on({
                'yes no': function(event) {
                    this.triggerHandler('leave');
                }
            });
            return modal;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ChangeHistoryPopoverView
     * 
     * @events  hide
     *          show
     *          toggle
     * @extends View
     */
    window.ChangeHistoryPopoverView = View.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _changeHistoryPopoverList
         * 
         * @access  protected
         * @var     undefined|ChangeHistoryPopoverListView (default: undefined)
         */
        _changeHistoryPopoverList: undefined,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChangeHistoryPopoverView')
         */
        _string: 'ChangeHistoryPopoverView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._addHideListeners();
            this._addWindowResizeListener();
            this._drawChangeHistoryPopoverList();
            this._setupScrollbars();
            this.on({
                'hide': function(event) {
                    this.hide();
                },
                'show': function(event) {
                    this.show();
                },
                'toggle': function(event) {
                    this.toggle();
                }
            });
        },

        /**
         * _addHideListeners
         * 
         * @access  protected
         * @return  void
         */
        _addHideListeners: function() {
            var autoHidePopover = Config.default('changeHistory').autoHidePopover;
            if (autoHidePopover === true) {
                this.on({
                    'show': function(event) {
                        var _this = this,
                            $app = App.getElement(),
                            hide = {
                                'body/keydown/escape': function(event) {
                                    if (event.which === 27) {
                                        _this.triggerHandler('hide');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                },
                                'body/mousedown': function(event) {
                                    var closable = function() {
                                        var $target = $(event.target);
                                        if ($target.parents('div.changeHistoryPopover').length > 0) {
                                            return false;
                                        }
                                        if ($target.hasClass('changeHistoryPopover') === true) {
                                            return false;
                                        }
                                        if ($target.parents('div.sandbox').length > 0) {
                                            return false;
                                        }
                                        return true;
                                    };
                                    if (closable() === true) {
                                        _this.triggerHandler('hide');
                                        $app.unbind('mousedown', hide['body/mousedown']);
                                        $app.unbind('keydown', hide['body/keydown/escape']);
                                    }
                                }
                            };
                        $app.on({
                            'mousedown': hide['body/mousedown'],
                            'keydown': hide['body/keydown/escape']
                        });
                    }
                });
            }
        },

        /**
         * _addWindowResizeListener
         * 
         * @access  protected
         * @return  void
         */
        _addWindowResizeListener: function() {
            if (UserAgent.supports.css.scrollbars() === false) {
                var delay = Stencil.getResizeDelay('canvas'),
                    callback = _.debounce(
                        // console.log.proxy(console, ['test']),
                        this.refresh.proxy(this),
                        delay
                    );
                $(window).on({
                    'resize': callback
                });
            }
        },

        /**
         * _drawChangeHistoryPopoverList
         * 
         * @access  protected
         * @return  void
         */
        _drawChangeHistoryPopoverList: function() {
            var $element = DataUtils.render('ChangeHistoryPopoverList', {
                changeHistory: ChangeHistory.history.all()
            });
            this._element.find('div.content').append($element);
            this._changeHistoryPopoverList = new ChangeHistoryPopoverListView(
                $element
            );
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _refreshScrollbar
         * 
         * @access  protected
         * @return  void
         */
        _refreshScrollbar: function() {
            if (UserAgent.supports.css.scrollbars() === false) {
                this._$scrollbar.data('jsp').reinitialise();
            }
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbars: function() {
            if (UserAgent.supports.css.scrollbars() === false) {
                var $content = this.find('div.content'),
                    $caret = $content.find('.stencil-caret');
                this._makeScrollable($content);
                $content.addClass('dark');
                $content.append($caret);
            }
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._element.addClass('hidden');
            App.find('[lookup="changeHistory"]').removeClass('active');
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        refresh: function() {
            // this._changeHistoryPopoverList.refresh();
            this._changeHistoryPopoverList.reRender();
            this._refreshScrollbar();
            this.scrollToActive();
        },

        /**
         * scrollToActive
         * 
         * @see     http://stackoverflow.com/questions/2905867/how-to-scroll-to-specific-item-using-jquery
         * @access  public
         * @return  void
         */
        scrollToActive: function() {
            var list = this._changeHistoryPopoverList,
                $parent = list.getElement().parent(),
                $active = list.find('.active').parent();
            if (UserAgent.supports.css.scrollbars() === false) {
                this._$scrollbar.data('jsp').scrollToY(0, false);
                this._$scrollbar.data('jsp').scrollToY(
                    $active.position().top - 4,
                    false
                );
            } else {
                var topPosition = $active.offset().top - $parent.offset().top +
                        $parent.scrollTop();
                $parent.scrollTop(topPosition);
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._element.removeClass('hidden');
            this.scrollToActive();
            // this._changeHistoryPopoverList.scrollToActive();
            App.find('[lookup="changeHistory"]').addClass('active');
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            if (this._element.hasClass('hidden') === true) {
                this.triggerHandler('show');
            } else {
                this.triggerHandler('hide');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ChangeHistoryPopoverListView
     * 
     * @extends View
     */
    window.ChangeHistoryPopoverListView = View.extend({

        /**
         * _lastRenderHash
         * 
         * @access  protected
         * @var     String (default: '')
         */
        _lastRenderHash: '',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ChangeHistoryPopoverListView')
         */
        _string: 'ChangeHistoryPopoverListView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this.on({
                'redo': function(event, $anchor) {
                    var stepsForward = $anchor.attr('steps');
                    ChangeHistory.initiate.redo(stepsForward);
                },
                'undo': function(event, $anchor) {
                    var stepsBack = $anchor.attr('steps');
                    ChangeHistory.initiate.undo(stepsBack);
                }
            });
        },

        /**
         * _hasChangedSinceLastRender
         * 
         * Determines whether or not anything in the change history (redo and
         * undo) is different, by checking against a previously stored hash.
         * If something is different, it naturally returns true, which at the
         * moment is used for refreshing the list.
         * 
         * @access  protected
         * @return  Boolean
         */
        _hasChangedSinceLastRender: function() {
            var history = ChangeHistory.history.all(),
                hash = StringUtils.getHash(
                    JSON.stringify(history)
                );
            if (hash === this._lastRenderHash) {
                return false;
            }
            this._lastRenderHash = hash;
            return true;
        },

        /**
         * refresh
         * 
         * @access  public
         * @return  void
         */
        // refresh: function() {
        //     if (this._hasChangedSinceLastRender() === true) {
        //         this.rerender();
        //         // this.scrollToActive();
        //     }
        // },

        /**
         * reRender
         * 
         * @access  public
         * @return  void
         */
        reRender: function() {
            if (this._hasChangedSinceLastRender() === true) {
                var $element = DataUtils.render('ChangeHistoryPopoverList', {
                    changeHistory: ChangeHistory.history.all()
                });
                this._element.replaceWith($element);
                this._element = $element;
                this._setupListeners();
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageContentView
     * 
     * @events  toggle/changeHistory
     *          toggle/framer
     *          toggle/grid
     *          clear
     * @extends View
     */
    window.StageContentView = View.extend({

        /**
         * _canvases
         * 
         * @access  protected
         * @var     Object
         */
        _canvases: {

            /**
             * ghost
             * 
             * @access  protected
             * @var     null|GhostCanvasView (default: null)
             */
            ghost: null,

            /**
             * preview
             * 
             * @access  protected
             * @var     null|PreviewCanvasView (default: null)
             */
            preview: null
        },

        /**
         * _changeHistoryPopover
         * 
         * @access  protected
         * @var     null|ChangeHistoryPopoverView (default: null)
         */
        _changeHistoryPopover: null,

        /**
         * _eyeDropper
         * 
         * @access  protected
         * @var     null|EyeDropperView (default: null)
         */
        _eyeDropper: null,

        /**
         * _framer
         * 
         * @access  protected
         * @var     null|FramerView (default: null)
         */
        _framer: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                contextmenu: {

                    /**
                     * (anonymous)
                     * 
                     * Prevents right-click on the canvas.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $canvas
                     * @return  void
                     */
                    'canvas': function(event, $canvas) {
                        event.preventDefault();
                    }
                },
                dragenter: {
                    '> div.outer > div.inner > div.sandbox > section.messages:not(.hidden) div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = DataUtils.getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {
                            $outline.parents('div.tbl').addClass('active');
                        }
                    }
                },
                dragleave: {
                    '> div.outer > div.inner > div.sandbox > section.messages:not(.hidden) div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = DataUtils.getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {
                            $outline.parents('div.tbl').removeClass('active');
                        }
                    }
                },
                dragover: {
                    '> div.outer > div.inner > div.sandbox > section.messages:not(.hidden) div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                },
                drop: {
                    '> div.outer > div.inner > div.sandbox div.tbl div.outline': function(event, $outline) {
                        event.preventDefault();
                        event.stopPropagation();
                        var dataTransfer = event.originalEvent.dataTransfer,
                            decoded = DataUtils.getBypassedDataTransferObject(dataTransfer);
                        if (decoded !== false) {

                            // 
                            var type = decoded.type,
                                accessor = decoded.accessor;
                            if (accessor.indexOf(':') !== -1) {
                                accessor = accessor.replaceAll({
                                    'algoliaquote': 'AlgoliaQuote',
                                    'icons8': 'Icons8',
                                    'pexels': 'Pexels',
                                    'pixabay': 'Pixabay',
                                    'thenounproject': 'TheNounProject',
                                    'vectorsearch': 'VectorSearch',
                                    'unsplash': 'Unsplash'
                                });
                            }
                            accessor = Stencil.getAccessor(accessor);
                            this.find('section.messages > div.message:not(.hidden) .active').removeClass('active');
                            var options = {
                                x: event.originalEvent.layerX,
                                y: event.originalEvent.layerY
                            };
                            if ($outline.parents('.tbl').attr('destination') !== undefined) {
                                options.destination = $outline.parents('.tbl').attr('destination');
                                options.autoSelect = true;
                            }
                            accessor.select.apply(
                                accessor,
                                ['drop', decoded.locked, options]
                            );

                            // 
                            if (
                                decoded.type === 'photo'
                                || decoded.type === 'graphic'
                                || decoded.type === 'upload'
                            ) {
                                var start = new Date(),
                                    busy = Canvases.Preview.getBusy();
                                Canvases.Preview.once({
                                    'render': function(event) {
                                        var busy = this.getBusy();
                                        // busy.hide.minDelay(start, 500, busy);
                                        busy.hide.minDelay(start, 0, busy);
                                    }
                                });
                                busy.show();
                            }

                            /**
                             * There's a weird bug that I ran into while
                             * building change history. When an asset, resource
                             * or upload is dropped on the canvas, sometimes
                             * (about 1 in 5), the mouseup event does not fire.
                             * I tried for a number of hours to figure out why,
                             * to noavail. So I'm manully firing here.
                             * 
                             * It should not cause any issues, since even if the
                             * mouseup event does fire correctly, the change
                             * history operation will have already been tracked,
                             * and won't be inserted into the array again.
                             */
                            App.triggerHandler('changeHistory/track');
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageContentView')
         */
        _string: 'StageContentView',

        /**
         * _toolbars
         * 
         * @access  protected
         * @var     Object
         */
        _toolbars: {
            backgroundBitmapImage: null,
            backgroundRectangle: null,
            foregroundBitmapImage: null,
            text: null,
            vectorImage: null,
            watermarkBitmapImage: null
        },

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._drawFramer();
            window.Canvases = {};
            this._setupGhostCanvas();
            this._setupPreviewCanvas();
            this._setupEyeDropper();
            this._drawToolbars();
            this._setupChangeHistoryPopover();
            this._setupTooltips();
            this._setupButterBar();
            this._setupFacebookAdGrid();
            this._setupBackgroundHandles();
            this.on({
                'interaction/block': function(event, $element) {
                    this.interaction.block.apply(this);
                },
                'toggle/changeHistory': function(event, $element) {
                    $element.blur();
                    this.getChangeHistoryPopover().triggerHandler('toggle');
                },
                'toggle/framer': function(event, $element) {
                    $element.blur();
                    this._framer.toggle();
                },
                'toggle/grid': function(event, $element) {
                    $element.blur();
                    this.find('div.butter.bar [lookup="toggle/grid"]').toggleClass('hidden');
                    this.find('div.ui.actions [lookup="toggle/grid"]').toggleClass('active');
                    this.find('div.sandbox div.grid').toggleClass('hidden');
                },
                'addText': function(event, $element) {
                    $element.blur();
                    this.addText();
                },
                'clear': function(event, $element) {
                    $element.blur();
                    App.tooltips.hide();
                    Canvases.Preview.clear(true);
                },
                'createNewImage': function(event, $element) {
                    $element.blur();
                    App.tooltips.hide();
                    var canvasHasbeenChanged = Footer.validate.changedCanvas.apply(Footer).valid;
                    if (canvasHasbeenChanged === true) {
                        Canvases.Preview.clear(true, 'unsaved');
                    } else {
                        Canvases.Preview.clear(false);
                    }
                },
                'redo': function(event, $element) {
                    $element && $element.blur();
                    ChangeHistory.initiate.redo(1);
                },
                'undo': function(event, $element) {
                    $element && $element.blur();
                    ChangeHistory.initiate.undo(1);
                }
            });
        },

        /**
         * _drawFramer
         * 
         * @access  protected
         * @return  void
         */
        _drawFramer: function() {
            var $framer = DataUtils.render('Framer');
            this._element.find('div.reframer').append($framer);
            this._framer = new FramerView($framer, this);
        },

        /**
         * _drawToolbars
         * 
         * @access  protected
         * @return  void
         */
        _drawToolbars: function() {
            var $toolbars = this._element.find('> .outer > div.inner div.toolbars'),
                view = new ToolbarsView($toolbars, this);
            window.Toolbars = view;
        },

        /**
         * _setupBackgroundHandles
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundHandles: function() {
            var $handles = this.find('div.handles');
            this.find('.preview-canvas-container').append($handles);
        },

        /**
         * _setupButterBar
         * 
         * @access  protected
         * @return  void
         */
        _setupButterBar: function() {
            var $bar = this.find('div.butter.bar');
            this.find('.sandbox').parent().append($bar);
            // this.find('.preview-canvas-container').append($bar);
        },

        /**
         * _setupChangeHistoryPopover
         * 
         * @access  protected
         * @return  void
         */
        _setupChangeHistoryPopover: function() {
            var $element = this.find('.changeHistoryPopover'),
                view = new ChangeHistoryPopoverView($element);
            this._changeHistoryPopover = view;
        },

        /**
         * _setupEyeDropper
         * 
         * @access  protected
         * @return  void
         */
        _setupEyeDropper: function() {
            var $element = this.find('div.eyedropper'),
                view = new EyeDropperView($element, this);
            this._eyeDropper = view;
        },

        /**
         * _setupFacebookAdGrid
         * 
         * @access  protected
         * @return  void
         */
        _setupFacebookAdGrid: function() {
            var $grid = this.find('div.inner > div.grid');
            this.find('.preview-canvas-container').append($grid);
        },

        /**
         * _setupGhostCanvas
         * 
         * @access  protected
         * @return  void
         */
        _setupGhostCanvas: function() {
            var $ghost = this.find('canvas#ghost'),
                ghost = new GhostCanvasView($ghost);
            this._canvases.ghost = ghost;
        },

        /**
         * _setupPreviewCanvas
         * 
         * @access  protected
         * @return  void
         */
        _setupPreviewCanvas: function() {
            var $preview = this.find('canvas#preview'),
                preview = new PreviewCanvasView($preview);
            this._canvases.preview = preview;
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            var $actions = this.find('div.ui.actions');
            this._element.tooltip({
                html: true,
                selector: [
                    'a.icon[trigger="import"][tooltip]',
                    'div.butter.bar [tooltip]',
                    '[lookup="undo"]',
                    '[lookup="changeHistory"]',
                    '[lookup="redo"]',
                    'div.ui.actions [tooltip]'
                ].join(','),
                container: App.getElement(),
                placement: function() {
                    var placement = this.$element.attr('placement');
                    if (placement === undefined) {
                        placement = 'bottom';
                    }
                    if (placement === 'smart') {
                        var offset = $actions.offset(),
                            widths = {
                                body: App.getElement().width()
                            };
                        // if ((widths.body - offset.left) >= 142) {
                        if ((widths.body - offset.left) >= 153) {
                            return 'right';
                        }
                        return 'bottom';
                    }
                    return placement;
                }
            });
        },

        /**
         * addText
         * 
         * @access  public
         * @return  void
         */
        addText: function() {
            var canvas = Canvases.Preview,
                layer = canvas.addTextLayer(),
                drawing = layer.getDrawing();
            layer.setChangeOperationType('added');
            drawing.once({
                'draw': function(event) {
                    this.select();
                    drawing.animate();
                }
            });
            drawing.draw();
        },

        /**
         * drawPreviewCanvas
         * 
         * @access  public
         * @return  void
         */
        drawPreviewCanvas: function() {
            var draft = Stencil.account().draft(),
                document = draft.json(),
                preview = this._canvases.preview,
                imageDocument = new ImageDocument(document, draft, preview);
            draft.loadDependentFonts();
            draft.setImageDocument(imageDocument);
            preview.setImage(draft);
            preview.once({
                'render': preview.addWindowResizeListener
            });
            preview.once({
                'render': preview.addWindowOrientationChangeListener
            });
            preview.once({
                'render': function(event) {
                    var sourceImage = draft.getSourceImage();
                    if (sourceImage !== undefined) {
                        if (sourceImage.owned() === true) {
                            Footer.setLastSavedImage(sourceImage);
                        }
                    }
                }
            });
            preview.once({
                'render': function(event) {
                    var callback = Footer.reset.proxy(Footer);
                    // var callback = function() {
                    //     Footer.reset();//.proxy(Footer);
                    //     console.log('t');
                    // };
                    // var callback = Footer.reset.proxy(Footer);
                    this._cotton.on({
                        'after:render': _.throttle(callback, 75)
                        // 'after:render': _.throttle(callback, 75),
                        // 'applyFilters/complete': function() {
                        //     console.log('w00t');
                        // }
                    });
                    Footer.reset();
                }
            });
            preview.draw(true);
            draft.markConfigurationAsSaved();
        },

        /**
         * getChangeHistoryPopover
         * 
         * @access  public
         * @return  ChangeHistoryPopoverView
         */
        getChangeHistoryPopover: function() {
            return this._changeHistoryPopover;
        },

        /**
         * getEyeDropper
         * 
         * @access  public
         * @return  EyeDropperView
         */
        getEyeDropper: function() {
            return this._eyeDropper;
        },

        /**
         * getFramer
         * 
         * @access  public
         * @return  FramerView
         */
        getFramer: function() {
            return this._framer;
        },

        /**
         * getMessage
         * 
         * @access  public
         * @param   String type
         * @return  jQuery
         */
        getMessage: function(type) {
            var selector = 'section.messages div.message[type="' + (type) + '"]';
            return this.find(selector);
        },

        /**
         * getMessages
         * 
         * @access  public
         * @return  jQuery
         */
        getMessages: function() {
            return this.find('section.messages div.message');
        },

        /**
         * handles
         * 
         * @access  public
         * @var     Object
         */
        handles: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                this.find('div.handles').addClass('hidden');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                this.find('div.handles').removeClass('hidden');
            }
        },

        /**
         * interaction
         * 
         * @access  public
         * @var     Object
         */
        interaction: {

            /**
             * block
             * 
             * @access  public
             * @return  void
             */
            block: function() {
                var busy = Canvases.Preview.getBusy(),
                    $element = busy.getElement(),
                    msg = Stencil.getMessage('interaction.block');
                if ($element.hasClass('hidden') === true) {
                    $element.addClass('light');
                    busy.show(msg);
                }
            },

            /**
             * unblock
             * 
             * @access  public
             * @return  void
             */
            unblock: function() {
                var busy = Canvases.Preview.getBusy();
                busy.hide();
                busy.getElement().removeClass('light');
            }
        },

        /**
         * refreshChangeHistoryElements
         * 
         * This method is pretty simple: it disables the redo and undo CTAs,
         * and then checks the length of the redo and undo history stacks. In
         * the case of the redo history stack, I enable the redo CTA if there
         * are any entries.
         * 
         * The undo history stack is different, because there will *always* be
         * at least one entry: the original image state. So in that case, I
         * check if there's greater than 1 entry, and if so, enable the CTA.
         * 
         * @access  public
         * @return  void
         */
        refreshChangeHistoryElements: function() {
            var $redo = this.find('a.redo'),
                $undo = this.find('a.undo'),
                history = ChangeHistory.history.all();
            $redo.disable();
            $undo.disable();
            if (history.redo.length > 0) {
                $redo.enable();
            }
            if (history.undo.length > 1) {
                $undo.enable();
            }
        },

        /**
         * updateReframer
         * 
         * @access  public
         * @return  void
         */
        updateReframer: function() {
            var $reframer = this.find('.reframer'),
                $anchor = $reframer.find('a').first(),
                $middot = $reframer.find('span.middot').first(),
                $label = $anchor.find('div.label'),
                $width = $anchor.find('span.width'),
                $height = $anchor.find('span.height');
            $label.text(Frame.get('label'));
            $width.text(Frame.get('width'));
            $height.text(Frame.get('height'));
            $middot.removeClass('hidden');
            if (Frame.get('label').trim() === '') {
                $middot.addClass('hidden');
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * EyeDropperView
     * 
     * @extends View
     * @fires   select
     *          disable
     *          enable
     */
    window.EyeDropperView = View.extend({

        /**
         * _enabled
         * 
         * @access  protected
         * @var     false (default: false)
         */
        _enabled: false,

        /**
         * _imageData
         * 
         * @access  protected
         * @var     null|Object (default: null)
         */
        _imageData: null,

        /**
         * _stageContent
         * 
         * @access  protected
         * @var     null|StageContentView (default: null)
         */
        _stageContent: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'EyeDropperView')
         */
        _string: 'EyeDropperView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   StageContentView stageContent
         * @return  void
         */
        init: function(element, stageContent) {
            this._super(element);
            this._stageContent = stageContent;
            this._addMessageListeners();
            this._addColorActionListeners();
        },

        /**
         * _addClickListener
         * 
         * @access  protected
         * @return  void
         */
        _addClickListener: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'click': function(event) {
                    _this._triggerEvent(event, 'select');
                }
            });
        },

        /**
         * _addColorActionListeners
         * 
         * @access  protected
         * @return  void
         */
        _addColorActionListeners: function() {
            this._addMouseMoveMouseDownListener();
            this._addMouseMoveMetaKeyListener();
            this._addClickListener();
        },

        /**
         * _addMessageListeners
         * 
         * @access  protected
         * @return  void
         */
        _addMessageListeners: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'mousedown': function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                },
                'mouseenter': function(event) {
                    _this._element.removeClass('hidden');
                },
                'mouseleave': function(event) {
                    _this._element.addClass('hidden');
                },
                'mousemove': function(event) {
                    var position = {
                            x: event.offsetX,
                            y: event.offsetY
                        },
                        dimensions = {
                            width: _this._element.css('width').toInt(),
                            height: _this._element.css('height').toInt()
                        },
                        rgbaColorStr = _this._getColorAtPosition(position),
                        hex = ColorUtils.convert(rgbaColorStr, 'hex');
                    _this._element.find('.tooltip-inner').text(hex);
                    _this._element.css({
                        'background-color': rgbaColorStr,
                        'left': (position.x - dimensions.width / 2) + 'px',
                        'top': (position.y - dimensions.height / 2) + 'px'
                    });
                }
            });
        },

        /**
         * _addMouseMoveMetaKeyListener
         * 
         * @access  protected
         * @return  void
         */
        _addMouseMoveMetaKeyListener: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'mousemove': function(event) {
                    if (event.metaKey === true) {
                        _this._triggerEvent(event, 'preview');
                        var position = {
                                x: event.offsetX,
                                y: event.offsetY
                            },
                            rgbaColorStr = _this._getColorAtPosition(position);
                        _this.triggerHandler('preview', [rgbaColorStr]);
                    }
                }
            });
        },

        /**
         * _addMouseMoveMouseDownListener
         * 
         * @see     https://i.imgur.com/WkNKzs3.png
         * @access  protected
         * @return  void
         */
        _addMouseMoveMouseDownListener: function() {
            var _this = this,
                stageContent = this._stageContent,
                $message = stageContent.getMessage('color');
            $message.on({
                'mousemove': function(event) {
                    if (event.which !== undefined) {
                        if (event.which.toInt() === 1) {
                            _this._triggerEvent(event, 'preview');
                        }
                    }
                }
            });
        },

        /**
         * _getColorAtPosition
         * 
         * @see     https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
         * @see     https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData
         * @access  protected
         * @param   Object position
         * @return  String
         */
        _getColorAtPosition: function(position) {
            var dpr = window.devicePixelRatio.round(3),
                x = position.x * dpr,
                y = position.y * dpr,
                position = ((y * (this._imageData.width * 4)) + (x * 4)),
                rgba = [
                    this._imageData.data[position + 0],
                    this._imageData.data[position + 1],
                    this._imageData.data[position + 2],
                    this._imageData.data[position + 3]
                ],
                rgbaColorStr = 'rgba(' + rgba.toString() + ')';
            return rgbaColorStr;
        },

        /**
         * _loadImageData
         * 
         * @access  protected
         * @return  void
         */
        _loadImageData: function() {
            var dpr = window.devicePixelRatio.round(3),
                cotton = Canvases.Preview.getCotton(),
                width = cotton.width * dpr,
                height = cotton.height * dpr;
            this._imageData = cotton.getContext().getImageData(
                0,
                0,
                width,
                height
            );
        },

        /**
         * _triggerEvent
         * 
         * @access  protected
         * @param   jQuery event
         * @param   String action
         * @return  void
         */
        _triggerEvent: function(event, action) {
            var eventType = action,
                position = {
                    x: event.offsetX,
                    y: event.offsetY
                },
                rgbaColorStr = this._getColorAtPosition(position);
            this.triggerHandler(eventType, [rgbaColorStr]);
        },

        /**
         * disable
         * 
         * @access  public
         * @return  void
         */
        disable: function() {
            this.triggerHandler('disable');
            if (this._enabled === true) {
                this.unbind('preview');
                this.unbind('select');
                this._enabled = false;
                Stencil.set('ignoreMouseDownLayerBlur', false);
                var previewCanvas = Canvases.Preview,
                    cotton = Canvases.Preview.getCotton(),
                    $message = this._stageContent.getMessage('color'),
                    $messages = this._stageContent.find('section.messages');
                $message.addClass('hidden');
                $messages.addClass('mirage');
                this._element.addClass('hidden');
                var selectedLayer = previewCanvas.getSelectedLayer();
                if (selectedLayer !== false) {
                    var selectedDrawing = selectedLayer.getDrawing();
                    selectedDrawing.bb.show.apply(selectedDrawing);
                }
            }
        },

        /**
         * enable
         * 
         * @access  public
         * @return  void
         */
        enable: function() {
            this.triggerHandler('enable');
            if (this._enabled === false) {
                this._enabled = true;
                Stencil.set('ignoreMouseDownLayerBlur', true);
                this._loadImageData();
                var previewCanvas = Canvases.Preview,
                    cotton = previewCanvas.getCotton(),
                    $message = this._stageContent.getMessage('color'),
                    $messages = this._stageContent.find('section.messages'),
                    selectedDrawing = previewCanvas.getSelectedLayer().getDrawing();
                $message.removeClass('hidden');
                $messages.removeClass('mirage');
                selectedDrawing.bb.hide.apply(selectedDrawing);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageFooterView
     * 
     * @events  download
     *          save
     *          template
     *          menu/save/close
     *          menu/save/open
     * @extends View
     */
    window.StageFooterView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                mouseenter: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    '[lookup="previewAndShare"]': function(event, $anchor) {
                        App.preloadShareModalStaticAssets();
                    }
                }
            });
        },

        /**
         * _lastSavedImage
         * 
         * Reference to the last saved ImageAccessor object (used by downloading
         * and sharing methods).
         * 
         * @access  protected
         * @var     false|ImageAccessor (default: false)
         */
        _lastSavedImage: false,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageFooterView')
         */
        _string: 'StageFooterView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            window.Footer = this;
            this._setupSecondarySaveMenu();
            this._setupAuth();
            this._setupDownload();
            this._setupPreviewAndShare();
            this._setupSave();
            this._setupSaveAsTemplate();
            this._setupTooltips();
            Scripts.load('aws');
        },

        /**
         * _closeOnboardModal
         * 
         * @access  protected
         * @return  void
         */
        _closeOnboardModal: function() {
            var onboard = Modals.get('Onboard');
            if (onboard !== false) {
                onboard.triggerHandler('leave');
            }
        },

        /**
         * _setupAuth
         * 
         * @access  protected
         * @return  void
         */
        _setupAuth: function() {
            User.once({
                'login': function(event, user) {
                    Footer.reset();
                }
            });
            Account.once({
                'upgrade': function(event, account) {
                    Footer.reset();
                }
            });
        },

        /**
         * _setupDownload
         * 
         * @access  protected
         * @return  void
         */
        _setupDownload: function() {
            this.on({
                'download': function(event) {
                    var check = this.validate.download.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {
                        var draft = Stencil.account().draft(),
                            key = draft.get('key');
                        if (draft.isVerifoneFrame() === true) {
                            check = this.validate.changedCanvas.apply(this);
                            if (check.valid === true) {
                                Stencil.account().draft().share();
                                this.save('share', false);
                            } else {
                                this._lastSavedImage.share();
                            }
                        } else {
                            Modals.showDownload(key, false);
                        }
                    }
                }
            });
        },

        /**
         * _setupPreviewAndShare
         * 
         * @todo    Look into whether an image needs to actually be saved when
         *          the P+S button is clicked. Might make more sense to only
         *          save the image once they try to get interact with it via the
         *          share modal? More complicated, since there are non-OAuth
         *          based interaction methods (eg. Buffer, Pinterest, SMS), but
         *          it's much more efficient, in that no image gets saved to the
         *          DB or S3 if they just want to see what it looks like. It thus
         *          also saves browser-memory.
         * @access  protected
         * @return  void
         */
        _setupPreviewAndShare: function() {
            this.on({
                'previewAndShare': function(event) {
                    this._closeOnboardModal();
                    var check = this.validate.previewAndShare.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {
                        check = this.validate.changedCanvas.apply(this);
                        if (check.valid === true) {
                            Stencil.account().draft().share();
                            // var msg = Stencil.getMessage('image.saving');
                            // App.getBusy().show(msg);
                            this.save('share', false);
                        } else {
                            this._lastSavedImage.share();
                        }
                    }
                }
            });
        },

        /**
         * _setupSave
         * 
         * @note    I set the account's monthlySavedImages and totalSavedImages
         *          right away (and delay the syncing to the db) because I want
         *          the UI to change immediately (eg.
         *          https://i.imgur.com/M5fueDd.png), but I don't want the
         *          account record to be patched until _after_ a new shadow draft
         *          has been created. This is to prevent a possible
         *          race-condition when the AccountAccessor is patched before
         *          the new shadow draft has been created. This can happen if the
         *          server is lagging. Specifically, the draft ImageAccessor is
         *          updated, a new shadow draft ImageAccessor is created, but
         *          before that completes, the existing AccountAccessor is
         *          updated. If the AccountAccessor is patched before the new
         *          shadow draft ImageAccessor has been created, this line of
         *          code will fire, which will result in two draft records in the
         *          db for the account: https://i.imgur.com/1hyuGwa.png
         *          Here's the result: https://i.imgur.com/pKApJAK.png
         *          Tough one to crack..
         * @access  protected
         * @return  void
         */
        _setupSave: function() {
            this.on({
                'save': function(event) {
                    var check = this.validate.save.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {

                        /**
                         * Account quota saving / syncing
                         * 
                         */
                        var account = Stencil.account();
                        account.set({
                            monthlySavedImages: account.get('monthlySavedImages').toInt() + 1,
                            totalSavedImages: account.get('totalSavedImages').toInt() + 1
                        });
                        account.once({
                            'draft/create': function(event, draft) {
                                this.syncRefillData(function(changed) {
                                    if (changed === true) {
                                        this.set({
                                            monthlySavedImages: this.get('monthlySavedImages').toInt() + 1,
                                            monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt(),
                                            totalSavedImages: this.get('totalSavedImages').toInt() + 1
                                        });
                                        Stencil.alert('account.refilled');
                                    }
                                    this.save([
                                        'monthlySavedImages',
                                        'totalSavedImages'
                                    ]);
                                });
                            }
                        });

                        // Image collection addition
                        var draft = account.draft(),
                            category = Categories.account.list('images'),
                            key = category.get('key'),
                            child = App.getEditor().getArea('images').getChild('categories').getChild(key),
                            images = child.getCollection();
                        images.add(draft, false);

                        // Save and navigate to images tab
                        // var msg = Stencil.getMessage('image.saving');
                        // App.getBusy().show(msg);
                        category.features.add.apply(category, [draft]);
                        this.save('save', false);

                        /**
                         * Scrolling + Navigation
                         * 
                         */
                        var fragmentPath = category.getPath(true);
                        if (Stencil.getRouter().current().fragment === fragmentPath) {
                            child.scrollToTop();
                        } else {
                            var routeEventKey = 'route:' + (fragmentPath);
                            Stencil.getRouter().once(
                                routeEventKey,
                                function() {
                                    child.scrollToTop();
                                }
                            );
                        }
                        Stencil.navigate(category.getPath());

                        // Image count warning
                        if (
                            User.admin() === false
                            && User.editor() === false
                        ) {
                            var remaining = account.getImagesRemaining();
                            if (remaining === 0 || remaining === 1) {
                                Stencil.navigate('/app/countdown?clean=1');
                            }
                        }

                        // Actions
                        Footer.reset();
                        // this.disable.save.apply(this);
                        // this.enable.distribution.apply(this);
                    }
                }
            });
        },

        /**
         * _setupSaveAsTemplate
         * 
         * @access  protected
         * @return  void
         */
        _setupSaveAsTemplate: function() {
            this.on({
                'saveAsTemplate': function(event) {
                    this.triggerHandler('menu/save/close');
                    var check = this.validate.saveAsTemplate.apply(this);
                    if (check.valid === false) {
                        check.callback();
                    } else {

                        /**
                         * Account quota saving / syncing
                         * 
                         */
                        var account = Stencil.account();
                        account.set({
                            monthlySavedImages: account.get('monthlySavedImages').toInt() + 1,
                            totalSavedImages: account.get('totalSavedImages').toInt() + 1
                        });
                        account.once({
                            'draft/create': function(event, draft) {
                                this.syncRefillData(function(changed) {
                                    if (changed === true) {
                                        this.set({
                                            monthlySavedImages: this.get('monthlySavedImages').toInt() + 1,
                                            monthlySentSmsMessages: this.get('monthlySentSmsMessages').toInt(),
                                            totalSavedImages: this.get('totalSavedImages').toInt() + 1
                                        });
                                        Stencil.alert('account.refilled');
                                    }
                                    this.save([
                                        'monthlySavedImages',
                                        'totalSavedImages'
                                    ]);
                                });
                            }
                        });

                        // 
                        Stencil.account().draft().template();
                        // throw new Error('s');
                        // var msg = Stencil.getMessage('image.saving');
                        // App.getBusy().show(msg);
                        this.save('template', false);
                        Track.event('Template saved');

                        /**
                         * Scrolling + Navigation
                         * 
                         */
                        var category = Categories.account.list('templates'),
                            key = category.get('key'),
                            child = App.getEditor().getArea('templates').getChild('categories').getChild(key),
                            fragmentPath = category.getPath(true);
                        if (Stencil.getRouter().current().fragment === fragmentPath) {
                            child.scrollToTop();
                        } else {
                            var routeEventKey = 'route:' + (fragmentPath);
                            Stencil.getRouter().once(
                                routeEventKey,
                                function() {
                                    child.scrollToTop();
                                }
                            );
                        }
                        Stencil.navigate(category.getPath());
                    }
                }
            });
        },

        /**
         * _setupSecondarySaveMenu
         * 
         * @access  protected
         * @return  void
         */
        _setupSecondarySaveMenu: function() {
            this.on({
                'menu/save/close': function(event) {
                    this.find('div.save').removeClass('expanded');
                },
                'menu/save/open': function(event) {
                    var _this = this;
                    this.find('div.save').addClass('expanded');
                    HelpScout.close();

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                var $target = $(event.target);
                                if ($target.parents('div.popover[button="save"]').length === 0) {
                                    _this.triggerHandler('menu/save/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (event.which === 27) {
                                    _this.triggerHandler('menu/save/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                }
            });
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._element.tooltip({
                html: true,
                selector: '[tooltip]',
                container: this._element,
                placement: 'top'
            });
        },

        /**
         * disable
         * 
         * @access  public
         * @var     Object
         */
        disable: {

            /**
             * all
             * 
             * @access  public
             * @param   undefined|Boolean quick (default: false)
             * @return  void
             */
            all: function(quick) {
                quick = DataUtils.getDefaultValue(quick, false);
                this.disable.distribution.apply(this, [quick]);
                this.disable.save.apply(this, [quick]);
            },

            /**
             * distribution
             * 
             * Disables the "Download" and "Preview & Share" buttons. Adds the
             * tooltips to them.
             * 
             * @access  public
             * @param   undefined|Boolean quick (default: false)
             * @return  void
             */
            distribution: function(quick) {
                quick = DataUtils.getDefaultValue(quick, false);
                if (quick === true) {
                    this.find('[lookup="download"]').addClass('quick');
                    this.find('[lookup="previewAndShare"]').addClass('quick');
                }
                this.find('[lookup="download"]').disable();
                this.find('[lookup="previewAndShare"]').disable();
                this.find('[lookup="download"]').tooltips(true);
                this.find('[lookup="previewAndShare"]').tooltips(true);
                if (quick === true) {
                    (function() {
                        this.find('[lookup="download"]').removeClass('quick');
                        this.find('[lookup="previewAndShare"]').removeClass('quick');
                    }).delay(150, this);
                }
            },

            /**
             * save
             * 
             * Disables the "Save" and "Save as template" buttons. Adds the
             * tooltip to the parent save button.
             * 
             * @access  public
             * @param   undefined|Boolean quick (default: false)
             * @return  void
             */
            save: function(quick) {
                quick = DataUtils.getDefaultValue(quick, false);
                if (quick === true) {
                    this.find('[lookup="save"]').addClass('quick');
                    this.find('[lookup="saveChevron"]').addClass('quick');
                }
                this.find('[lookup="save"]').disable();
                this.find('[lookup="saveChevron"]').disable();
                this.find('[lookup="saveWrapper"]').tooltips(true);
                if (quick === true) {
                    (function() {
                        this.find('[lookup="save"]').removeClass('quick');
                        this.find('[lookup="saveChevron"]').removeClass('quick');
                    }).delay(150, this);
                }
            }
        },

        /**
         * enable
         * 
         * @access  public
         * @var     Object
         */
        enable: {

            /**
             * all
             * 
             * Helper method for the other two enable methods. Enables all three
             * actions, and removes all tooltips.
             * 
             * @access  public
             * @return  void
             */
            all: function() {
                this.enable.distribution.apply(this);
                this.enable.save.apply(this);
            },

            /**
             * distribution
             * 
             * Enables the "Download" and "Preview & Share" buttons. Removes the
             * tooltips from them.
             * 
             * @access  public
             * @return  void
             */
            distribution: function() {
                this.find('[lookup="download"]').enable();
                this.find('[lookup="previewAndShare"]').enable();
                this.find('[lookup="download"]').tooltips(false);
                this.find('[lookup="previewAndShare"]').tooltips(false);
            },

            /**
             * save
             * 
             * Enables the "Save" and "Save as template" buttons. Removes the
             * tooltip from the parent save button.
             * 
             * @access  public
             * @return  void
             */
            save: function() {
                this.find('[lookup="save"]').enable();
                this.find('[lookup="saveChevron"]').enable();
                this.find('[lookup="saveWrapper"]').tooltips(false);
            }
        },

        /**
         * getLastSavedImage
         * 
         * @access  public
         * @return  false|ImageAccessor
         */
        getLastSavedImage: function() {
            return this._lastSavedImage;
        },

        /**
         * setLastSavedImage
         * 
         * @access  public
         * @param   false|ImageAccessor image
         * @return  void
         */
        setLastSavedImage: function(image) {//, disableSave) {
    // console.log('Footer.setLastSavedImage called');
    // console.log(arguments);
    // console.trace();
            this._lastSavedImage = image;
            // disableSave === true && this.disable.save.apply(this);
            // this.enable.distribution.apply(this);
        },

        /**
         * validate
         * 
         * @access  public
         * @var     Object
         */
        validate: {

            /**
             * changedCanvas
             * 
             * This validation method is intended to determine whether the draft
             * is different than the source image defined (if any). It does this
             * by first checking if a saved image is stored in the footer (which
             * would be the source image of any draft). If none is, then the
             * canvas is identified as different (this would happen for
             * brand-new guests).
             * 
             * If a saved image is defined, it then checks whether it's
             * configuration (which is the same as the draft's source image) is
             * different than the draft. If that check passes, then we return
             * true: the canvas has changed.
             * 
             * Originally, I thought I would have to check 3rd-party resources
             * to see if, for example, a Pixabay:123 resource was in fact the
             * same as a asst123 resource. The convern was that if a user clicks
             * a Pixabay photo, and then saves it right away, when the /save
             * call came back, it would swap out the new draft's image-key
             * property, and thus be seen as a different relative to the source
             * image. The reason this is no longer an issue is because the way
             * /save call listeners work, is the source image would have _it's_
             * image-key property swapped out too. So in fact, the two canvases
             * would be the same from a programmtic/json perspective.
             * 
             * Something that _could_ be done is right now, if you click a
             * Pixabay image, and save it, the resource-hash is replaced with
             * the asset key (via the /save call). But if the user then
             * continues navigating through the search results, if they make
             * their way _back_ to the initial image, it will be seen as
             * different because the asset key and resource-hash do not seem to
             * match up.
             * 
             * While this is an edge-case, it is something that could be
             * improved.
             * 
             * @todo    See note above
             * @access  public
             * @return  Object
             */
            changedCanvas: function() {
                if (this._lastSavedImage === false) {
                    return {
                        valid: true
                    };
                }
                var draft = Stencil.account().draft(),
                    configurations = {
                        draft: draft.getConfiguration(),
                        lastSavedImage: this._lastSavedImage.getConfiguration()
                    },
                    configurationStrings;
                delete configurations.draft.sourceImageId;
                delete configurations.lastSavedImage.sourceImageId;


                //     // 
                //     var imageDocuments = {
                //         draft: new ImageDocument(JSON.parse(configurations.draft.settings.json), draft),
                //         lastSavedImage: new ImageDocument(JSON.parse(configurations.lastSavedImage.settings.json), this._lastSavedImage)
                //     };
                // imageDocuments.draft.mergeWatermarks();// ?
                //     imageDocuments.draft.setupLayers();
                // imageDocuments.lastSavedImage.mergeWatermarks();// ?
                //     imageDocuments.lastSavedImage.setupLayers();

                //     configurations.draft.settings.json = JSON.stringify(imageDocuments.draft.json(false));
                //     configurations.draft.settings.watermarks = JSON.stringify(imageDocuments.draft.getWatermarkLayersJson());
                //     configurations.lastSavedImage.settings.json = JSON.stringify(imageDocuments.lastSavedImage.json(false));
                //     configurations.lastSavedImage.settings.watermarks = JSON.stringify(imageDocuments.lastSavedImage.getWatermarkLayersJson());


                configurationStrings = {
                    draft: JSON.stringify(configurations.draft),
                    lastSavedImage: JSON.stringify(configurations.lastSavedImage)
                };
                if (configurationStrings.draft !== configurationStrings.lastSavedImage) {
                    return {
                        valid: true
                    };
                }
                return {
                    valid: false
                };
            },

            /**
             * download
             * 
             * Series of validation methods to determine whether a download can
             * take place. Of particular interest is the saving-check, which
             * also checks whether the <_lastSavedImage> property is set to
             * null. This is to allow for the case whereby a user saves an image
             * first, and before updating anything about it, attempts to use the
             * Download or Preview & Share buttons. In that case, the user
             * should be allow to proceed, since those flows manage themselves
             * nicely already with respect to an image that is still being
             * uploaded.
             * 
             * The <_lastSavedImage> property is set to null only when a change
             * to the canvas is made. Otherwise, it is a reference to the
             * ImageAccessor that was last saved (and possibly still being
             * uploaded).
             * 
             * @access  public
             * @return  Object
             */
            download: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (
                    Canvases.Ghost.get('saving') === true
                    // && Canvases.Ghost.getImage() !== this._lastSavedImage
                    && this.validate.changedCanvas.apply(this).valid === true
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, mime) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (this.validate.changedCanvas.apply(this).valid === false) {
                    return {
                        valid: true
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * previewAndShare
             * 
             * Series of validation methods to determine whether a Preview &
             * Share can take place. Of particular interest is the saving-check,
             * which also checks whether the <_lastSavedImage> property is set
             * to null. This is to allow for the case whereby a user saves an
             * image first, and before updating anything about it, attempts to
             * use the Download or Preview & Share buttons. In that case, the
             * user should be allow to proceed, since those flows manage
             * themselves nicely already with respect to an image that is still
             * being uploaded.
             * 
             * The <_lastSavedImage> property is set to null only when a change
             * to the canvas is made. Otherwise, it is a reference to the
             * ImageAccessor that was last saved (and possibly still being
             * uploaded).
             * 
             * @access  public
             * @return  Object
             */
            previewAndShare: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (
                    Canvases.Ghost.get('saving') === true
                    // && Canvases.Ghost.getImage() !== this._lastSavedImage
                    && this.validate.changedCanvas.apply(this).valid === true
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, mime) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (this.validate.changedCanvas.apply(this).valid === false) {
                    return {
                        valid: true
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * save
             * 
             * @access  public
             * @return  Object
             */
            save: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (Canvases.Ghost.get('saving') === true) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, mime) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (Account.draftIsLocked() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/upgrade/pro/locked-save?clean');
                        }
                    };
                }
                if (User.exists() === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/signup?save');
                        }
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * saveAsTemplate
             * 
             * @access  public
             * @return  Object
             */
            saveAsTemplate: function() {
                if (Services.check('aws') === false) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.alert('service.aws');
                        }
                    };
                }
                if (Canvases.Ghost.get('saving') === true) {
                    return {
                        valid: false,
                        callback: function() {
                            var msg = Stencil.getMessage('image.exporting');
                            App.getBusy().show(msg);
                            Canvases.Ghost.once({
                                'export': function(event, dataURL, mime) {
                                    App.getBusy().hide();
                                }
                            });
                        }
                    };
                }
                if (
                    Account.upgraded() === false
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/upgrade/pro/templates?clean=1');
                        }
                    };
                }
                if (
                    Account.max.images() === true
                    && User.admin() === false
                    && User.editor() === false
                ) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/countdown?clean=1');
                        }
                    };
                }
                if (Account.delinquent() === true) {
                    return {
                        valid: false,
                        callback: function() {
                            Stencil.navigate('/app/delinquent?clean=1');
                        }
                    };
                }
                return {
                    valid: true
                };
            },

            /**
             * sourceImageContext
             * 
             * Checks whether the source image for the draft was saved under a
             * specific context (eg. save, template, download or share). This is
             * used to determine whether the Footer save button should be
             * enabled. For example, if save is passed in, it will ensure that
             * the source image for the account's draft image was in fact saved,
             * rather than possibly saved as a template or via a download or
             * share action.
             * 
             * @access  public
             * @param   String context
             * @return  Object
             */
            sourceImageContext: function(context) {
                if (this._lastSavedImage === false) {
                    return {
                        valid: false
                    };
                }
                var draft = Stencil.account().draft(),
                    sourceImage = draft.getSourceImage();
                if (sourceImage === undefined) {
                    return {
                        valid: false
                    };
                }
                return {
                    valid: sourceImage.get('context') === context
                };
            }
        },

        /**
         * reset
         * 
         * @access  public
         * @return  void
         */
        reset: function() {
            var changedCanvas = this.validate.changedCanvas.apply(this).valid;
            if (changedCanvas === true) {
                this.enable.save.apply(this);
                if (
                    User.admin() === false
                    && User.editor() === false
                ) {
                    if (
                        Account.guest() === true
                        || Account.free() === true
                        || Account.plan('pro') === true
                    ) {
                        this.disable.distribution.apply(this);
                    } else {
                        this.enable.distribution.apply(this);
                    }
                } else {
                    this.enable.distribution.apply(this);
                }
            } else {
                var saveContext = this.validate.sourceImageContext.apply(this, ['save']).valid;
                if (saveContext === true) {
                    this.disable.save.apply(this);
                } else {
                    this.enable.save.apply(this);
                }
                this.enable.distribution.apply(this);
                // if (User.admin() === false) {
                //     if (Account.guest() === true || Account.free() === true) {
                //         this.enable.distribution.apply(this);
                //     }
                // }
            }
        },

        /**
         * save
         * 
         * @access  public
         * @param   String context
         * @param   false|String mime
         * @param   undefined|Function callback
         * @return  void
         */
        save: function(context, mime, callback) {

            // Draft swapping
            this.time('save');
            Canvases.Ghost.set({'saving': true});
            var account = Stencil.account(),
                saving = account.draft(),
                imageDocument = saving.getImageDocument(),
                draft = account.createNewDraft(saving);
            this._lastSavedImage = saving;
            draft.setImageDocument(imageDocument);
            imageDocument.setImage(draft);
            draft.markConfigurationAsSaved();
            Canvases.Preview.setImage(draft);

            // Change history operation
            if (context !== 'download') {
                var operationType = 'image // saved';
                if (context === 'template') {
                    operationType = 'template // saved';
                }
                ChangeHistory.setOperationType(operationType);
                ChangeHistory.track(true, false);
            } else {
                ChangeHistory.syncSourceImageId(
                    saving.get('sourceImageId').toInt(),
                    saving.get('id').toInt()
                );
            }

            // Settings
            saving.setConfiguration();
            saving.set({
                'context': context,
                'draft': 0
            });

            /**
             * It's important to clear the configuration save timeout to prevent
             * the following possible race-condition:
             * 
             * If an image is really simple, and the user makes a change and
             * then quickly saves it, it's possible that the PATCH call to save
             * the image gets dispatched *after* the image has been fully
             * uploaded. If this happens, then the ImageValidator::notUploaded
             * check will fail, since the image has technically already been
             * uploaded.
             * 
             * Cancelling this call is fine, because it really is only
             * cancelling the dispatching of the PATCH call. The data itself is
             * already changed in the ImageAccessor reference, and will be
             * synced in the below .save call anyhow
             */
            saving.clearSaveConfigurationTimeout();

            // Create new image document and layers for saving image
            var document = saving.json(),
                ghost = Canvases.Ghost;
            imageDocument = new ImageDocument(document, saving, ghost);
            imageDocument.mergeWatermarks();
            imageDocument.setupLayers();
            saving.setImageDocument(imageDocument);

            // Save through the Ghost canvas
            var _this = this;
            Canvases.Ghost.setImage(saving);
            Canvases.Ghost.once({
                'export': function(event, dataURL, mime) {

                    // Image saved
                    _this.time('save');
                    Canvases.Ghost.set({'saving': false});
                    Track.event('Image pushed', {
                        label: context,
                        _label: context
                    });

                    // Promote the draft to a saved image
                    saving.set({
                        size: dataURL.length,
                        mime: mime
                    });
                    saving.save([
                        'context', 'draft', 'size', 'mime', 'width', 'height',
                        'sourceImageId', 'frame', 'settings.json',
                        'settings.watermarks'
                    ]);
                    // saving.markConfigurationAsSaved();
                    saving.once({
                        'update/context': function(event, columns) {

                            // Init and start upload
                            var model = Stencil.getModel('S3Upload');
                            saving.once({
                                'upload/error': function(event, err, responseObject) {
                                    Stencil.alert('image.upload.error');
                                    Stencil.kill();
                                    StencilBooter.log(event, err);
                                    var msg = {
                                        response: err
                                    };
                                    try {
                                        msg.raw = {
                                            code: err.code,
                                            hostname: err.hostname,
                                            message: err.message,
                                            name: err.name,
                                            region: err.region,
                                            time: err.time
                                        };
                                    } catch(exception) {}
                                    Stencil.report('image:upload/error', msg);
                                },
                                'upload/success': function(event, response, responseObject) {
                                    this.set({
                                        'uploaded': 1,
                                        'uploadedTimestamp': 1,
                                        'settings.icons': JSON.stringify(
                                            this.getTheNounProjectIcons()
                                        )
                                    });
                                    this.save([
                                        'uploaded',
                                        'uploadedTimestamp',
                                        'settings.icons'
                                    ]);
                                    if (context === 'save') {
                                        this.once({
                                            'update/uploaded': function(event) {
                                                var category = Categories.account.list('images'),
                                                    model = Stencil.getModel('Image');
                                                model.feature(
                                                    this.get('key'),
                                                    {
                                                        category: category.get('key')
                                                    }
                                                );
                                            }
                                        });
                                    }
                                    this.preload(function() {
                                        this.triggerHandler('preload');
                                    });
                                }
                            });
                            try {
                                model.uploadData(
                                    saving,
                                    saving.get('key'),
                                    dataURL
                                );

                                // Send response to callback if defined
                                callback && callback.apply(_this, [saving, dataURL]);
                            } catch (err) {
                                Stencil.alert('image.upload.exception');
                                Stencil.kill();
                            }
                        }
                    });
                },

                /**
                 * I wait for the render event, rather than the draw, to allow
                 * for filters that may take some time to be applied, to be
                 * applied. Without this listener, filters weren't coming
                 * through in the data
                 */
                'render': function(event) {
                    // var _this = this;
                    // setTimeout(function() {
                    //     _this.export(mime, true);
                    // }, 10000);
                    this.export(mime, true);
                }
            });
            Canvases.Ghost.draw();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * FramerView
     * 
     * @events  hide
     *          show
     *          toggle
     * @extends View
     */
    window.FramerView = View.extend({

        /**
         * _collection
         * 
         * @access  protected
         * @var     null|FramesCollection (default: null)
         */
        _collection: null,

        /**
         * _form
         * 
         * @access  protected
         * @var     null|AppFormView (default: null)
         */
        _form: null,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'nav a': function(event, $anchor) {
                        event.preventDefault();
                        this.section($anchor.attr('type'));
                    }
                }
            });
        },

        /**
         * _scrollbars
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _scrollbars: {},

        /**
         * _stageContent
         * 
         * @access  protected
         * @var     null|StageContentView (default: null)
         */
        _stageContent: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'FramerView')
         */
        _string: 'FramerView',

        /**
         * _views
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _views: {},

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   StageContentView stageContent
         * @return  void
         */
        init: function(element, stageContent) {
            this._super(element);
            this._stageContent = stageContent;
            if (UserAgent.supports.css.scrollbars() === false) {
                this._setupScrollbars();
            }

            // Collection
            this._collection = Stencil.account().collection('frames');
            var _this = this;
            this._collection.on({
                'add': function(event, frame, position) {
                    _this._drawFrame(frame, position);
                },
                'empty': function(event) {
                    _this.find('.frame').remove();
                },
                'update': function(event) {
                    _this.showHideCustomEmptyState();
                    _this.refreshScrollbars();
                }
            });

            // UI
            this.on({
                // 'frame': this.frame,
                'hide': this.hide,
                'show': this.show,
                'toggle': this.toggle,
            });
            this._draw();
            this.showHideCustomEmptyState();
            this.section('posts');
            this._setupForm();
        },

        /**
         * _draw
         * 
         * @access  protected
         * @return  void
         */
        _draw: function() {
            var _this = this;
            this._collection.each(function(index, frame) {
                _this._drawFrame(frame, index);
            });
        },

        /**
         * _drawCustomFrame
         * 
         * @access  protected
         * @param   FrameAccessor frame
         * @param   Number position
         * @return  void
         */
        _drawCustomFrame: function(frame, position) {
            var $frames = this.find('section[type="custom"] div.frames'),
                $frame = DataUtils.render('CustomFrame', {
                    frame: frame
                });
            if (position === 0) {
                $frames.prepend($frame);
            } else {
                $frames.append($frame);
            }
            new CustomFrameView($frame, this, frame);
        },

        /**
         * _drawDefaultFrame
         * 
         * @access  protected
         * @param   FrameAccessor frame
         * @param   Number position
         * @return  void
         */
        _drawDefaultFrame: function(frame, position) {
            var type = frame.get('type').plural(),
                $frames = this.find('section[type="' + (type) + '"] div.frames'),
                $frame = DataUtils.render('Frame', {
                    frame: frame
                });
            if (position === 0) {
                $frames.prepend($frame);
            } else {
                $frames.append($frame);
            }
            new FrameView($frame, this, frame);
        },

        /**
         * _drawFrame
         * 
         * @access  protected
         * @param   FrameAccessor frame
         * @param   Number position
         * @return  void
         */
        _drawFrame: function(frame, position) {
            if (frame.get('type') === 'custom') {
                this._drawCustomFrame(frame, position);
            } else {
                this._drawDefaultFrame(frame, position);
            }
        },

        /**
         * _makeScrollable
         * 
         * @see     http://jquery-custom-scrollbar.rocketmind.pl/
         * @access  protected
         * @param   jQuery $element
         * @param   String section
         * @return  void
         */
        _makeScrollable: function($element, section) {
            this._scrollbars[section] = $element;
            this._scrollbars[section].jScrollPane({
                animateScroll: true,
                animateDuration: 200,
                verticalDragMinHeight: 40
            });
        },

        /**
         * _setupForm
         * 
         * @access  protected
         * @return  void
         */
        _setupForm: function() {
            var clean = function() {
                this.clearErrors.delay(2500, this);
            };
            this._form = new AppFormView(this.find('form'));
            this._form.on({
                'returned/failed': clean,
                'returned/shit': clean
            });
            var _this = this;
            this._form.on({
                'returned/succeeded': function(event, response) {
                    Track.event('Custom frame created');
                    this.find('input[type="text"]').val('');
                    var collection = _this._collection;
                    collection.map(response.data.object, false);
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @access  protected
         * @return  void
         */
        _setupScrollbars: function() {
            var $posts = this.find('section.posts');
            this._makeScrollable($posts.find('.content'), 'posts');
            var $ads = this.find('section.ads');
            this._makeScrollable($ads.find('.content'), 'ads');
            var $headers = this.find('section.headers');
            this._makeScrollable($headers.find('.content'), 'headers');
            var $custom = this.find('section.custom');
            this._makeScrollable($custom.find('.content'), 'custom');
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            this._element.addClass('hidden');
            this.refreshScrollbars();
        },

        /**
         * getContent
         * 
         * @access  public
         * @return  StageContentView
         */
        getContent: function() {
            return this._stageContent;
        },

        /**
         * refreshScrollbars
         * 
         * @access  public
         * @return  void
         */
        refreshScrollbars: function() {
            if (UserAgent.supports.css.scrollbars() === false) {
                this._scrollbars.posts.data('jsp').reinitialise();
                this._scrollbars.ads.data('jsp').reinitialise();
                this._scrollbars.headers.data('jsp').reinitialise();
                this._scrollbars.custom.data('jsp').reinitialise();
            }
        },

        /**
         * section
         * 
         * @access  public
         * @param   String section
         * @return  void
         */
        section: function(section) {
            var $nav = this.find('nav'),
                $content = this.find('> div.content > div.content');
            $nav.find('a').removeClass('active');
            $nav.find('a[type=' + (section) + ']').addClass('active');
            $content.find('> section').addClass('hidden');
            $content.find('> section.' + (section)).removeClass('hidden');
            this.refreshScrollbars();
            if (section === 'custom') {
                if (
                    UserAgent.is.tablet() === false 
                    && UserAgent.is.ie() === false
                ) {
                    $content.find('> section.' + (section)).focusable().focus();
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._element.removeClass('hidden');
            this.refreshScrollbars();
        },

        /**
         * showHideCustomEmptyState
         * 
         * Shows or hides the appropriate section depending on whether the
         * collection is empty.
         * 
         * @access  public
         * @return  void
         */
        showHideCustomEmptyState: function() {
            var $section = this.find('section.custom');
            $section.find('.frames').removeClass('hidden');
            $section.find('.messaging,.empty').addClass('hidden');
            if (this._collection.custom().length === 0) {
                $section.find('.frames').addClass('hidden');
                $section.find('.messaging,.empty').removeClass('hidden');
            }
        },

        /**
         * toggle
         * 
         * @access  public
         * @return  void
         */
        toggle: function() {
            this._element.toggleClass('hidden');
            if (this._element.hasClass('hidden') === false) {
                var _this = this,
                    $app = App.getElement(),
                    hide = {
                        'body/mousedown': function(event) {
                            var $target = $(event.target),
                                outsideFramer = $target.parents('div.framer').length === 0;
                            if (outsideFramer === true) {
                                var outsideConfirmModal = $target.parents('div.modal.confirm').length === 0;
                                if (outsideConfirmModal === true) {
                                    _this.hide();
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        },
                        'body/keydown/escape': function(event) {
                            if (event.which === 27) {
                                var confirmModalShowing = App.find('div.modal.confirm').length !== 0;
                                if (confirmModalShowing === false) {
                                    _this.hide();
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        }
                    };
                $app.on({
                    'mousedown': hide['body/mousedown'],
                    'keydown': hide['body/keydown/escape']
                });
            }
            this.refreshScrollbars();
        },

        /**
         * updateSelected
         * 
         * @access  public
         * @return  void
         */
        updateSelected: function() {

            // Reset
            this.find('div.active').removeClass('active');
            this.find('a.button.tiny').removeClass('done');
            this.find('a.button.tiny').enable();

            // Current
            var $frame = this.find('[lookup="' + (Frame.get('key')) + '"]');
            $frame.addClass('active');
            $frame.find('a.button').addClass('done');
            $frame.find('a.button').disable();

            // Section
            var type = Frame.get('type'),
                sections = {
                    custom: 'custom',
                    post: 'posts',
                    ad: 'ads',
                    header: 'headers'
                },
                section = sections[type];
            section !== undefined && this.section(section);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageHeaderView
     * 
     * @events  menu/close
     *          menu/open
     * @extends View
     */
    window.StageHeaderView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $anchor
                     * @return  void
                     */
                    'div.popover div.content > a': function(event, $anchor) {
                        this.triggerHandler('menu/close');
                    },

                    /**
                     * (anonymous)
                     * 
                     * @note    I needed to add a 0 millisecond delay to get the
                     *          event triggering at the end of the call-stack.
                     *          This is because I believe Headway is cancelling
                     *          out right away. Namely, it opens the menu, and
                     *          then hide's it immediately.
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $div
                     * @return  void
                     */
                    'div.notifications': function(event, $div) {
                        var $target = $(event.target);
                        if ($target.hasClass('icon') === true) {
                            (function() {
                                $div.find('#HW_badge_cont').trigger('click');
                            }).delay(0);
                        }
                    }
                }
            });
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageHeaderView')
         */
        _string: 'StageHeaderView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._setupHeadway();
            this.on({
                'menu/close': function(event) {
                    this.find('div.text').removeClass('expanded');
                },
                'menu/open': function(event) {
                    var _this = this;
                    this.find('div.text').addClass('expanded');

                    // Escape key and body click hiding
                    var $app = App.getElement(),
                        hide = {
                            'body/mousedown': function(event) {
                                var $target = $(event.target);
                                if ($target.parents('div.popover').length === 0) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            },
                            'body/keydown/escape': function(event) {
                                if (event.which === 27) {
                                    _this.triggerHandler('menu/close');
                                    $app.unbind('mousedown', hide['body/mousedown']);
                                    $app.unbind('keydown', hide['body/keydown/escape']);
                                }
                            }
                        };
                    $app.on({
                        'mousedown': hide['body/mousedown'],
                        'keydown': hide['body/keydown/escape']
                    });
                    // var escape = function(event) {
                    //     if (event.which === 27) {
                    //         _this.triggerHandler('menu/close');
                    //         App.getElement().unbind('keydown', escape);
                    //     }
                    // };
                    // App.getElement().on({
                    //     'keydown': escape
                    // });
                    // App.getElement().one({
                    //     'mousedown': function(event) {
                    //         _this.triggerHandler('menu/close');
                    //         App.getElement().unbind('keydown', escape);
                    //     }
                    // });
                },
                'logout': function(event) {
                    // App.getBusy().show();
                    User.logout();//.delay(1000);
                    // User.logout.delay(1000);
                }
            });
            var _this = this;
            Stencil.account().on({
                'change': function(event) {
                    var remaining = this.getImagesRemaining(),
                        $count = _this.find('div.count');
                    $count.text(remaining);
                    $count.attr('class', 'count');
                    if (remaining <= 0) {
                        $count.addClass('red');
                    } else if (remaining < 4) {
                        $count.addClass('orange');
                    }

                    // Date
                    var $date = _this.find('div.date'),
                        $strong = $date.find('strong'),
                        refillDate = this.getRefillDate();
                    $strong.text(refillDate);
                }
            });
            User.once({
                'login': this.render.proxy(this),
                'signup': this.render.proxy(this)
            });
            Account.once({
                'upgrade': this.render.proxy(this)
            });
        },

        /**
         * _setupHeadway
         * 
         * @access  protected
         * @return  void
         */
        _setupHeadway: function() {
            if (Services.check('headway') === true) {
                App.getElement().on({
                    'keydown': function(event) {
                        if (event.which === 27) {
                            if ($(this).find('#HW_badge_cont').length > 0) {
                                if ('Headway.hide'.validMethod() === true) {
                                    Headway.hide();
                                }
                            }
                        }
                    },
                    'mousedown': function(event) {
                        if ($(this).find('#HW_badge_cont').length > 0) {
                            if ('Headway.hide'.validMethod() === true) {
                                Headway.hide();
                            }
                        }
                    }
                });
            }
        },

        /**
         * render
         * 
         * @access  public
         * @return  void
         */
        render: function() {
            if (Services.check('headway') === true) {
                if ('Headway.init'.validMethod() === true) {
                    Headway.init();
                }
            }
            var $header = DataUtils.render('StageHeader', {
                account: Stencil.account()
            });
            this._element.replaceWith($header);
            this._element = $header;
            this._setupListeners();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * StageView
     * 
     * @extends View
     */
    window.StageView = View.extend({

        /**
         * _content
         * 
         * @access  protected
         * @var     null|StageContentView (default: null)
         */
        _content: null,

        /**
         * _footer
         * 
         * @access  protected
         * @var     null|StageFooterView (default: null)
         */
        _footer: null,

        /**
         * _header
         * 
         * @access  protected
         * @var     null|StageHeaderView (default: null)
         */
        _header: null,

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'StageView')
         */
        _string: 'StageView',

        /**
         * init
         * 
         * @note    Purposelly ordered the drawing so that the content is drawn
         *          last, to ensure that the height is properly calculated for
         *          the canvas.
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            this._super(element);
            this._drawHeader();
            this._drawFooter();
            this._drawContent();
            this._setupHide();
            // this.find('> div.spinner').addClass('invisible');
        },

        /**
         * _drawContent
         * 
         * @access  protected
         * @return  void
         */
        _drawContent: function() {
            var $content = DataUtils.render('StageContent');
            this.find('> div.inner > footer').before($content);
            this._content = new StageContentView($content);
        },

        /**
         * _drawFooter
         * 
         * @access  protected
         * @return  void
         */
        _drawFooter: function() {
            var $footer = DataUtils.render('StageFooter');
            this.find('> div.inner').append($footer);
            this._footer = new StageFooterView($footer);
        },

        /**
         * _drawHeader
         * 
         * @access  protected
         * @return  void
         */
        _drawHeader: function() {
            var $header = DataUtils.render('StageHeader', {
                account: Stencil.account()
            });
            this.find('> div.inner').append($header);
            this._header = new StageHeaderView($header);
        },

        /**
         * _setupHide
         * 
         * @access  protected
         * @return  void
         */
        _setupHide: function() {
            this.on({
                'hide': App.hide.proxy(App)
            });
        },

        /**
         * fontsDropzoneVisible
         * 
         * @access  public
         * @return  Boolean
         */
        fontsDropzoneVisible: function() {
            return this.find('.fontsDropdown .prompt.visible').filter(':visible').length === 1;
        },

        /**
         * getContent
         * 
         * @access  public
         * @return  StageContentView
         */
        getContent: function() {
            return this._content;
        },

        /**
         * getFooter
         * 
         * @access  public
         * @return  StageFooterView
         */
        getFooter: function() {
            return this._footer;
        },

        /**
         * getHeader
         * 
         * @access  public
         * @return  StageHeaderView
         */
        getHeader: function() {
            return this._header;
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('View', function() {

    /**
     * ToolbarView
     * 
     * @fires   show
     *          hide
     * @extends View
     */
    window.ToolbarView = View.extend({

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        // _listeners: function() {
        //     return jQuery.extend(true, {}, this._super(), {
        //         mouseover: {
        //             'input[type="range"]': function(event, $range) {
        //                 $range.addClass('active');
        //             }
        //         }
        //     });
        // },

        /**
         *_colorPickers
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _colorPickers: {},

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ToolbarView')
         */
        _string: 'ToolbarView',

        /**
         * _toolbars
         * 
         * @access  protected
         * @var     null|ToolbarsView (default: null)
         */
        _toolbars: null,

        /**
         * _visible
         * 
         * @access  protected
         * @var     Boolean (default: false)
         */
        _visible: false,

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._colorPickers = {};
            this._toolbars = toolbars;
            this._super(element);
            this.on({
                'change/order/back': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('change/order', [false]);
                    this.order.auto.apply(this);
                },
                'change/order/forward': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('change/order', [true]);
                    this.order.auto.apply(this);
                },
                'clone': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('clone');
                },
                'delete': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer();
                    layer.triggerHandler('delete');
                },
                'flip/x': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        flip = layer.getStyle('flipX') === false;
                    if (layer.getStyle('flipX') === undefined) {
                        flip = true;
                    }
                    layer.triggerHandler('flip/x', [flip]);
                },
                'flip/y': function(event, $anchor) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        flip = layer.getStyle('flipY') === false;
                    if (layer.getStyle('flipY') === undefined) {
                        flip = true;
                    }
                    layer.triggerHandler('flip/y', [flip]);
                }
            });
        },

        /**
         * _positionTooltip
         * 
         * @access  protected
         * @param   jQuery $range
         * @return  void
         */
        _positionTooltip: function($range) {
            var $tooltip = $range.siblings('.tooltip');
            if ($tooltip.length > 0) {
                var value = $range.val().toFloat(),
                    uiValue = value;
                if ($range.attr('data-ui-value') !== undefined) {
                    uiValue = $range.attr('data-ui-value');
                }
                $tooltip.find('.tooltip-inner').text(uiValue);
                var max = $range.attr('max').toFloat(),
                    min = $range.attr('min').toFloat(),
                    paddingLeft = $range.parent().css('padding-left').toFloat(),
                    rangeWidth = $range.css('width').toFloat(),
                    tooltipWidth = $tooltip.css('width').toFloat(),
                    thumbWidth = 16,
                    left = 0;
                left = left + paddingLeft;
                left = left - (tooltipWidth / 2);
                left = left + (thumbWidth / 2);
                left = left + (rangeWidth - thumbWidth) * ((value - min) / (max - min));
                $tooltip.css({
                    left: left.round(0) + ('px')
                });
            }
        },

        /**
         * _drawColorPicker
         * 
         * @access  protected
         * @param   jQuery $input
         * @param   Object options
         * @return  ColorPickerView
         */
        _drawColorPicker: function($input, options) {
            var $colorPicker = DataUtils.render('ColorPicker'),
                colorPicker = new ColorPickerView(
                    $colorPicker,
                    $input,
                    this,
                    options
                );
            return colorPicker;
        },

        /**
         * _getSelectedLayer
         * 
         * @access  protected
         * @return  false|Layer
         */
        _getSelectedLayer: function() {
            var layer = Canvases.Preview.getSelectedLayer();
            return layer;
        },

        /**
         * _setupStrengthSlider
         * 
         * @access  protected
         * @param   String type
         * @return  void
         */
        _setupStrengthSlider: function(type) {
            var _this = this,
                label = (type) + 'Strength',
                selector = 'input[type="range"][name="' + (label) + '"]',
                $range = this.find(selector),
                listener = function(event) {
                    var layer = Canvases.Preview.getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        layer.triggerHandler('change/' + (label), [value]);

                        // Ensure anchor is / isn't showing (where appropriate)
                        _this.clearAllAnchor.reset.apply(_this);
                    }
                },
                filterResampleDelay = Stencil.getFilterResampleDelay();
            if (UserAgent.is.ie() === true) {
                $range.on({
                    'change': _.debounce(listener, filterResampleDelay)
                });
                $range.on({
                    'change': function(event) {
                        _this._positionTooltip($range);
                    }
                });
            } else {
                $range.on({
                    'input': _.debounce(listener, filterResampleDelay)
                });
                $range.on({
                    'input': function(event) {
                        _this._positionTooltip($range);
                    }
                });
            }

            // Change history
            $range.on({
                'mouseup': function(event) {
                    (function() {
                        App.triggerHandler('changeHistory/track');
                    }).delay(filterResampleDelay);
                }
            });
        },

        /**
         * _setupTooltip
         * 
         * @access  protected
         * @param   String name
         * @return  void
         */
        _setupTooltip: function(name) {
            var $range = this.find('input[name="' + (name) + '"]');
            $range.after('' +
                '<div class="tooltip bottom" lookup="tooltip/' + (name) + '">' +
                    '<div class="tooltip-arrow"></div>' +
                    '<div class="tooltip-inner">#</div>' +
            '</div>');
        },

        /**
         * colorPickerVisible
         * 
         * @access  public
         * @return  Boolean
         */
        colorPickerVisible: function() {
            var index;
            for (index in this._colorPickers) {
                if (this._colorPickers[index].visible() === true) {
                    return true;
                }
            }
            return false;
        },

        /**
         * getToolbars
         * 
         * @access  public
         * @return  null|ToolbarsView
         */
        getToolbars: function() {
            return this._toolbars;
        },

        /**
         * hide
         * 
         * @access  public
         * @return  void
         */
        hide: function() {
            if (this._visible === true) {
                this._visible = false;
                this._element.addClass('hidden');
                this.triggerHandler('hide');
                Toolbars.setVisibleToolbar(false);
            }
        },

        /**
         * order
         * 
         * @access  public
         * @var     Object
         */
        order: {

            /**
             * auto
             * 
             * Enables/disables the ordering UI options by checking the selected
             * layer's position within the other layers.
             * 
             * @access  public
             * @return  void
             */
            auto: function() {
                var layer = Canvases.Preview.getSelectedLayer();
                this.order.enable.apply(this);
                if (layer.front() === true) {
                    this.order.disable.apply(this, ['forward']);
                }
                if (layer.back() === true) {
                    this.order.disable.apply(this, ['back']);
                }
            },

            /**
             * disable
             * 
             * @access  public
             * @param   String direction
             * @return  void
             */
            disable: function(direction) {
                var selector = 'a[direction="' + (direction) + '"]';
                this.find(selector).disable();
            },

            /**
             * enable
             * 
             * @access  public
             * @return  void
             */
            enable: function() {
                this.find('div.tool.layer').find('a').enable();
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            if (this._visible === false) {
                this._visible = true;
                this._element.removeClass('hidden');
                this.triggerHandler('show');
                Toolbars.setVisibleToolbar(this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageToolbarView', function() {

    /**
     * BackgroundBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.BackgroundBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundBitmapImageToolbarView')
         */
        _string: 'BackgroundBitmapImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupBackgroundClear();
            this._setupBackgroundUpload();
            this._listenForConversion();
        },

        /**
         * _listenForConversion
         * 
         * @note    See ForegroundBitmapImageToolbarView for an important note on
         *          this method.
         * @access  protected
         * @return  void
         */
        _listenForConversion: function() {
            this.on({
                'convert/foreground': function(event) {
                    var canvas = Canvases.Preview,
                        selectedLayer = canvas.getSelectedLayer(),
                        key = selectedLayer.getProperty('image'),
                        locked = selectedLayer.getProperty('locked'),
                        accessor = Stencil.getAccessor(key),
                        start = new Date(),
                        busy = canvas.getBusy();
                    if (accessor === false) {
                        if (key.match(/^asst/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Asset', {
                                key: key
                            });
                        } else if (key.match(/^upld/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Upload', {
                                key: key
                            });
                        } else {
                            accessor = Stencil.setAccessor(key, 'Resource', {
                                key: key
                            });
                        }
                    }
                    Toolbars.hide();
                    ChangeHistory.clearOperationType();
                    selectedLayer.setChangeOperationType('convert:foreground');
                    canvas.clearBackgroundImageLayer();
                    var layer = accessor.addForegroundBitmapImageLayer(locked, {
                        animate: false,
                        autoSelect: false
                    });
                    layer.getDrawing().once({
                        'draw': function(event) {
                            busy.hide.minDelay(start, 300, busy);
                            this.select.minDelay(start, 300, this);
                        }
                    });
                    busy.show();
                },
                'crop': function(event) {
                    var canvas = Canvases.Preview,
                        selectedLayer = canvas.getSelectedLayer();
                    Modals.showCropper(selectedLayer);
                }
            });
        },

        /**
         * _setupBackgroundClear
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundClear: function() {
            this.on({
                'clear': function(event, $anchor) {
                    var canvas = Canvases.Preview;
                    canvas.getSelectedLayer().setChangeOperationType('deleted');
                    canvas.clearBackgroundImageLayer();
                    canvas.render();
                    canvas.getBackgroundRectangleLayer().select();
                }
            });
        },

        /**
         * _setupBackgroundUpload
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundUpload: function() {
            this.on({
                'upload': function(event, $anchor) {
                    var uploads = App.getEditor().getArea('uploads'),
                        dropzone = uploads.getDropzone();
                    dropzone.unbind('start');
                    dropzone.once({
                        'start': function(event) {
                            Stencil.navigate('/app/uploads');
                            Toolbars.hide();
                        }
                    });
                    dropzone.find('input[type="file"]').trigger('click');
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super.apply(this, Array.prototype.slice.apply(arguments));
            var content = App.getStage().getContent();
            content.handles.show.apply(content);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * BackgroundRectangleToolbarView
     * 
     * @extends ToolbarView
     */
    window.BackgroundRectangleToolbarView = ToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * backgroundColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'backgroundColor': function(rgbaColorStr) {
                this._colorPickers.backgroundColor.setColor(
                    rgbaColorStr,
                    false
                );
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BackgroundRectangleToolbarView')
         */
        _string: 'BackgroundRectangleToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupBackgroundColor();
            this._setupUpload();
            this.on({
                'clear/backgroundColor': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.backgroundColor.clear.apply(this);
                    layer.triggerHandler('clear/backgroundColor');
                }
            });
        },

        /**
         * backgroundColor
         * 
         * @access  protected
         * @var     Object
         */
        backgroundColor: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $backgroundColor = this.find('[name="backgroundColor"]');
                this._colorPickers.backgroundColor.clearMinicolors();
                // this._colorPickers.backgroundColor.setColor(
                //     ColorUtils.getWhite('rgba', 0),
                //     true
                // );
            }
        },

        /**
         * _setupBackgroundColor
         * 
         * @access  protected
         * @return  void
         */
        _setupBackgroundColor: function() {
            var _this = this,
                $input = this.find('[name="backgroundColor"]'),
                colorPicker = this._drawColorPicker($input);
            this._colorPickers.backgroundColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/backgroundColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr, false]);
                    // _this.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupUpload
         * 
         * @access  protected
         * @return  void
         */
        _setupUpload: function() {
            this.on({
                'upload': function(event, $anchor) {
                    var uploads = App.getEditor().getArea('uploads'),
                        dropzone = uploads.getDropzone();
                    dropzone.unbind('start');
                    dropzone.once({
                        'start': function(event) {
                            Stencil.navigate('/app/uploads');
                            Toolbars.hide();
                        }
                    });
                    dropzone.find('input[type="file"]').trigger('click');
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var layer = this._getSelectedLayer();
            this._super();
            this.order.auto.apply(this);
            var backgroundColor = layer.getStyle('backgroundColor');
            if (ColorUtils.addSpaces(backgroundColor) === ColorUtils.getBlack('rgba', 0)) {
                this.backgroundColor.clear.apply(this);
            } else {
                this._set.backgroundColor.apply(
                    this,
                    [backgroundColor]
                );
            }
            var content = App.getStage().getContent();
            content.handles.show.apply(content);
            this._colorPickers.backgroundColor.removeLastChange();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * BitmapImageToolbarView
     * 
     * @extends ToolbarView
     */
    window.BitmapImageToolbarView = ToolbarView.extend({

        /**
         * _$scrollbar
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _$scrollbar: null,

        /**
         * _colorOverlayColorPickerOpenDirection
         * 
         * @access  protected
         * @var     String (default: 'up')
         */
        _colorOverlayColorPickerOpenDirection: 'up',

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * blurStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'blurStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="blurStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * colorOverlay
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'colorOverlay': function(rgbaColorStr) {
                this._colorPickers.colorOverlay.setColor(rgbaColorStr, false);
            },

            /**
             * colorOverlayStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'colorOverlayStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="colorOverlayStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * darkenStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'darkenStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="darkenStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * lightenStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'lightenStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="lightenStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            },

            /**
             * opacityStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'opacityStrength': function(strength) {
                var $range = this.find(
                    'input[type="range"][name="opacityStrength"]'
                );
                $range.val(strength);
                this._positionTooltip($range);
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'BitmapImageToolbarView')
         */
        _string: 'BitmapImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupColorOverlay();
            this._setupStrengthSlider('blur');
            this._setupStrengthSlider('colorOverlay');
            this._setupStrengthSlider('darken');
            this._setupStrengthSlider('lighten');
            this._setupStrengthSlider('opacity');
            this._setupTooltips();
            this._listenForPresetFilterEvents();
            if (UserAgent.supports.css.scrollbars() === false) {
                this._setupScrollbars();
            }

            // Color Overlay
            this.on({

                /**
                 * (anonymous)
                 * 
                 * @note    I need to use the show method (instead of the reset
                 *          method) here, because BitmapImage layers debounce
                 *          before adding a filter object to the filters-array.
                 *          This can be seen in the BitmapImage.js layer class.
                 */
                'change/colorOverlay': function(event) {
                    this.colorOverlay.show.apply(this);
                    this.clearAllAnchor.show.apply(this);
                },
                'clear/all': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    layer.clearFilters();
                    Toolbars.hide();
                    this.show({
                        focusOnActiveFilter: false
                    });
                    layer.setChangeOperationType('filter:allCleared');
                },
                'clear/colorOverlay': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.colorOverlay.clear.apply(this);
                    this._set.colorOverlayStrength.apply(this, [0]);
                    layer.triggerHandler('clear/colorOverlay');
                    this.clearAllAnchor.reset.apply(this);
                }
            });

            // Firefox scrollbar init
            this.once({
                'show': function(event) {
                    this._refreshScrollbar();
                }
            });
        },

        /**
         * _focusOnActiveFilter
         * 
         * Focuses on the active filter (always one, since No Filter is an
         * option). Takes into consideration custom scrollbars, and when that's
         * the case, nulls the left margin calculation, since it's not used
         * with custom scrollbars.
         * 
         * Also note that it's important that the offset calculation occurs
         * after the scrollLeft offset reset (to value: 0), since not doing so
         * messes up things (not sure why at the moment).
         * 
         * @access  protected
         * @return  void
         */
        _focusOnActiveFilter: function() {
            var $content = this.find('div.tool.filters div.content'),
                $ul = $content.find('ul'),
                $li = $ul.find('li.active'),
                $thumb = $li.find('div.thumb');
            if ($li.length > 0) {
                if (UserAgent.supports.css.scrollbars() === false) {
                    this._$scrollbar.data('jsp').scrollToX(0, false);
                    var offset = $li.position().left
                        - (
                            $ul.width() - $thumb.width()
                        ) / 2;
                    this._$scrollbar.data('jsp').scrollToX(offset, false);
                } else {
                    $content.animate({
                        scrollLeft: 0
                    }, 0);
                    var offset = $li.position().left
                        - $content.css('margin-left').toInt()
                        - (
                            $ul.width() - $thumb.width()
                        ) / 2;
                    $content.animate({
                        scrollLeft: offset
                    }, 0);
                }
            }
        },

        /**
         * _listenForPresetFilterEvents
         * 
         * @note    I am adding an empty properties object when triggering a
         *          filter addition to ensure a consistent JSON makeup of filter
         *          objects. If I don't do this, Footer.js's changedCanvas method
         *          will fail, because the signature of a filter will sometimes
         *          include a properties object (because of the _normalizeFilters
         *          method in BitmapImage layers), and sometimes now.
         * @access  protected
         * @return  void
         */
        _listenForPresetFilterEvents: function() {
            this.on({
                'setFilter': function(event, $element) {
                    if ($element.hasClass('active') === false) {
                        var filter = $element.attr('filter'),
                            layer = this._getSelectedLayer(),
                            filters = layer.getProperty('filters');

                        // 
                        var blacklist = ['blur', 'colorOverlay', 'darken', 'lighten', 'opacity'];
                        for (var i = filters.length - 1; i >= 0; i--) {
                            if (ArrayUtils.contains(filters[i].type, blacklist) === false) {
                                // layer.set({'renderFilters': true});
                                layer.triggerHandler('filter/remove', [filters[i]]);
                            }
                        }
// StencilBooter.log(filters[i], obj);
//                             if (filters[i].type === obj.type) {
//                                 filters.splice(i, 1);
//                             }
//                         }
//                         var cotton = this.getCotton(),
//                             filters = cotton.filters || [];
//                         for (var i = filters.length - 1; i >= 0; i--) {
//                         jQuery.each(filters, function(index, obj) {
//                             if (ArrayUtils.contains(obj.type, blacklist) === false) {
//                                 layer.triggerHandler('filter/remove', [obj]);
//                             }
//                         });

                        // Add filter and refresh the UI
                        layer.set({'renderFilters': true});
                        if (filter !== 'noFilter') {
                            layer.triggerHandler('filter/add', [{
                                type: filter,
                                properties: {}
                            }]);
                            layer.setChangeOperationType('filter:preset:set');
                        } else {
                            Canvases.Preview.render();
                            layer.setChangeOperationType('filter:preset:cleared');
                        }

                        // Ensure anchor is / isn't showing (where appropriate)
                        this.clearAllAnchor.reset.apply(this);

                        // UI in toolbar
                        var $filters = this.find('li[filter]'),
                            $filter = this.find('li[filter="' + (filter) + '"]'),
                            cotton = layer.getDrawing().getCotton(),
                            callback = function() {
                                $filters.enable();
                                cotton.off('applyFilters/complete', callback);
                                $filter.removeClass('loading');
                                $filter.addClass('active');
                            };
                        $filters.disable();
                        $filters.removeClass('active');
                        $filters.removeClass('loading');
                        if (filter === 'noFilter') {
                            callback();
                        } else {
                            $filter.addClass('loading');
                            cotton.on({
                                'applyFilters/complete': callback
                            });
                        }
                    }
                }
            });
        },

        /**
         * _makeScrollable
         * 
         * @access  protected
         * @param   jQuery $element
         * @return  void
         */
        _makeScrollable: function($element) {
            this._$scrollbar = $element;
            this._$scrollbar.jScrollPane({
                animateScroll: true,
                animateDuration: 200
            });
        },

        /**
         * _refreshScrollbar
         * 
         * @note    The jsp check is done after discovering a number of bugs in
         *          Sentry. The bugs were related to the
         *          WatermarkBitmapImageToolbarView. It seems that since the
         *          .filters element is hidden, the below reinitialise call would
         *          fail.
         * @access  protected
         * @return  void
         */
        _refreshScrollbar: function() {
            if (this._$scrollbar !== null) {
                var jsp = this._$scrollbar.data('jsp');
                if (jsp !== undefined) {
                    jsp.reinitialise();
                }
            }
        },

        /**
         * _setupColorOverlay
         * 
         * @access  protected
         * @return  void
         */
        _setupColorOverlay: function() {
            var _this = this,
                openDirection = this._colorOverlayColorPickerOpenDirection,
                $input = this.find('[name="colorOverlay"]'),
                colorPicker = this._drawColorPicker($input, {
                    openDirection: openDirection,
                    showOpacitySlider: false

                });
            this._colorPickers.colorOverlay = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/colorOverlay',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(
                        type,
                        [rgbaColorStr]
                    );
                    _this.triggerHandler(type, [rgbaColorStr]);
                },
                'show': function(event) {
                    var layer = _this._getSelectedLayer(),
                        callback = function(event) {
                            var filter = this.getFilter('colorOverlay'),
                                strength = filter.properties.strength;
                            _this._set.colorOverlayStrength.apply(_this, [strength]);
                        };
                    layer.once({
                        'filter/add': callback
                    });
                    this.once({
                        'hide': function(event) {
                            layer.unbind('filter/add', callback);
                        }
                    })
                }
            });
        },

        /**
         * _setupScrollbars
         * 
         * @see     https://jsfiddle.net/8bnp7c39/8/
         * @access  public
         * @return  void
         */
        _setupScrollbars: function() {
            var $filters = this.find('div.tool.filters');
            if ($filters.length > 0) {
                this._makeScrollable($filters.find('.content'));
            }
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._setupTooltip('blurStrength');
            this._setupTooltip('opacityStrength');
            this._setupTooltip('lightenStrength');
            this._setupTooltip('darkenStrength');
            this._setupTooltip('colorOverlayStrength');
        },

        /**
         * colorOverlay
         * 
         * @access  public
         * @var     Object
         */
        colorOverlay: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $lookup = this.find('[lookup="clear/colorOverlay"]');
                $lookup.addClass('hidden');
                this._colorPickers.colorOverlay.clearMinicolors();
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the stroke
             * color input (when a value is defined).
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $outline = this.find('[name="colorOverlay"]'),
                    $clear = $outline.closest('div.column').find('a');
                $clear.addClass('hidden');
                if ($outline.val() !== '') {
                    $clear.removeClass('hidden');
                }
            }
        },

        /**
         * clearAllAnchor
         * 
         * @access  public
         * @var     Object
         */
        clearAllAnchor: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.addClass('hidden');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.removeClass('hidden');
            },

            /**
             * reset
             * 
             * @access  public
             * @return  void
             */
            reset: function() {
                var layer = this._getSelectedLayer(),
                    filters = layer.getProperty('filters');
                this.clearAllAnchor.hide.apply(this);
                if (filters.length > 0) {
                    this.clearAllAnchor.show.apply(this);
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @param   undefined|Object options (default: {})
         * @return  void
         */
        show: function(options) {
            options = DataUtils.getDefaultValue(options, {});
            var layer = this._getSelectedLayer();
            this._super();

            // Active preset filter
            var filters = layer.getProperty('filters');
            this.find('[filter]').removeClass('active');
            this.find('[filter="noFilter"]').addClass('active');
            this.clearAllAnchor.reset.apply(this);
            if (filters.length > 0) {
                var index, type;
                for (index in filters) {
                    type = filters[index].type
                    if (this.find('[filter="' + (type) + '"]').length > 0) {
                        this.find('[filter]').removeClass('active');
                        this.find('[filter="' + (type) + '"]').addClass('active');
                        break;
                    }
                }
            }

            // Whether to auto scroll to the active filter
            if (
                options.focusOnActiveFilter === undefined ||
                options.focusOnActiveFilter === true
            ) {
                this._focusOnActiveFilter();
            }

            // Color Overlay
            // if (layer.getStyle('colorOverlay') !== false) {
            //     this._set.colorOverlay.apply(
            //         this,
            //         [layer.getStyle('colorOverlay')]
            //     );
            //     this.colorOverlay.show.apply(this);
            // } else {
            //     this.colorOverlay.clear.apply(this);
            // }

            // 
            this._colorPickers.colorOverlay.removeLastChange();

            /**
             * Secondary filters
             * 
             */

            // Blur
            var filter = layer.getFilter('blur'),
                strength = filter === false ? 0 : filter.properties.strength;
            this._set.blurStrength.apply(this, [strength]);

            // Opacity
            filter = layer.getFilter('opacity');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.opacityStrength.apply(this, [strength]);

            // Lighten
            filter = layer.getFilter('lighten');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.lightenStrength.apply(this, [strength]);

            // Darken
            filter = layer.getFilter('darken');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.darkenStrength.apply(this, [strength]);

            // Color Overlay (strength)
            filter = layer.getFilter('colorOverlay');
            strength = filter === false ? 0 : filter.properties.strength;
            this._set.colorOverlayStrength.apply(this, [strength]);

            // Color Overlay (color)
            filter = layer.getFilter('colorOverlay');
            if (filter !== false) {
                this._set.colorOverlay.apply(this, [filter.properties.color]);
                this.colorOverlay.show.apply(this);
            } else {
                this.colorOverlay.clear.apply(this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * ColorVectorImageToolbarView
     * 
     * @extends ToolbarView
     */
    window.ColorVectorImageToolbarView = ToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * opacityStrength
             * 
             * @access  protected
             * @param   String strength
             * @return  void
             */
            'opacityStrength': function(strength) {
                var $range = this.find(
                        'input[type="range"][name="opacityStrength"]'
                    ),
                    rangeValue = 100 - (strength * 100).round(0);
                $range.val(rangeValue);
                this._positionTooltip($range);
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ColorVectorImageToolbarView')
         */
        _string: 'ColorVectorImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupStrengthSlider('opacity');
            this._setupTooltips();
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._setupTooltip('opacityStrength');
        },

        /**
         * clearAllAnchor
         * 
         * @access  public
         * @var     Object
         */
        clearAllAnchor: {

            /**
             * hide
             * 
             * @access  public
             * @return  void
             */
            hide: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.addClass('hidden');
            },

            /**
             * show
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $anchor = this.find('[lookup="clear/all"]');
                $anchor.removeClass('hidden');
            },

            /**
             * reset
             * 
             * @access  public
             * @return  void
             */
            reset: function() {
                var layer = this._getSelectedLayer(),
                    filters = layer.getProperty('filters');
                this.clearAllAnchor.hide.apply(this);
                if (filters.length > 0) {
                    this.clearAllAnchor.show.apply(this);
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var layer = this._getSelectedLayer();
            this._super();
            this.order.auto.apply(this);
            this._set.opacityStrength.apply(this, [layer.getStyle('opacity')]);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageToolbarView', function() {

    /**
     * ForegroundBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.ForegroundBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'ForegroundBitmapImageToolbarView')
         */
        _string: 'ForegroundBitmapImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._listenForConversion();
        },

        /**
         * _listenForConversion
         * 
         * @note    It's important that the ChangeHistory.clearOperationType()
         *          call be made, because otherwise, the ChangeHistory would
         *          register the layer being deleted as just that: a deletion.
         *          And what we want is for it to be registered as a conversion.
         *          Here is what the change history looks like when removed (the
         *          first screen shot), and when it's added back in (as it should
         *          be; second screenshot):
         *          https://i.imgur.com/X9jOkWz.png
         *          https://i.imgur.com/AgueWry.png
         * @access  protected
         * @return  void
         */
        _listenForConversion: function() {
            this.on({
                'convert/background': function(event) {
                    var canvas = Canvases.Preview,
                        selectedLayer = canvas.getSelectedLayer(),
                        key = selectedLayer.getProperty('image'),
                        locked = selectedLayer.getProperty('locked'),
                        accessor = Stencil.getAccessor(key),
                        start = new Date(),
                        busy = canvas.getBusy();
                    if (accessor === false) {
                        if (key.match(/^asst/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Asset', {
                                key: key
                            });
                        } else if (key.match(/^upld/) !== null) {
                            accessor = Stencil.setAccessor(key, 'Upload', {
                                key: key
                            });
                        } else {
                            accessor = Stencil.setAccessor(key, 'Resource', {
                                key: key
                            });
                        }
                    }
                    Toolbars.hide();
                    canvas.clearBackgroundImageLayer();
                    selectedLayer.triggerHandler('delete');
                    ChangeHistory.clearOperationType();
                    selectedLayer.setChangeOperationType('convert:background');
                    var layer = accessor.setBackgroundBitmapImageLayer(locked, {
                        autoSelect: false
                    });
                    layer.getDrawing().once({
                        'refresh': function(event) {
                            busy.hide.minDelay(start, 300, busy);
                            this.select.minDelay(start, 300, this);
                        }
                    });
                    busy.show();
                },
                'crop': function(event) {
                    var canvas = Canvases.Preview,
                        selectedLayer = canvas.getSelectedLayer();
                    Modals.showCropper(selectedLayer);
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super.apply(this, Array.prototype.slice.apply(arguments));
            this.order.auto.apply(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * TextToolbarView
     * 
     * @fires   change/backdropColor
     *          change/fontFamily
     *          change/strokeColor
     * @extends ToolbarView
     */
    window.TextToolbarView = ToolbarView.extend({

        /**
         * _font
         * 
         * The font that is currently set (used in conjunction with font
         * previewing).
         * 
         * @access  protected
         * @var     false|Object (default: false)
         */
        _font: false,

        /**
         * _fontsDropdown
         * 
         * @access  protected
         * @var     false|FontsDropdownView (default: false)
         */
        _fontsDropdown: false,

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return jQuery.extend(true, {}, this._super(), {
                change: {

                    /**
                     * (anonymous)
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $checkbox
                     * @return  void
                     */
                    'input#backdropStretch': function(event, $checkbox) {
                        var checked = $checkbox.prop('checked'),
                            backdropStretch = checked === true
                                ? 'full'
                                : 'slim';
                        this.triggerHandler(
                            'change/backdropStretch',
                            [backdropStretch]
                        );
                    }
                }
            });
        },

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * align
             * 
             * @access  protected
             * @param   String position
             * @return  void
             */
            'align': function(position) {
                this.find('[name^="align"]').removeClass('active');
                this.find('[name="align[' + (position) + ']"]').addClass(
                    'active'
                );
            },

            /**
             * backdropColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'backdropColor': function(rgbaColorStr) {
                this._colorPickers.backdropColor.setColor(rgbaColorStr, false);
            },

            /**
             * backdropStretch
             * 
             * @access  protected
             * @param   String backdropStretch
             * @return  void
             */
            'backdropStretch': function(backdropStretch) {
                var $backdropStretch = this.find('[id="backdropStretch"]');
                $backdropStretch.prop('checked', backdropStretch === 'full');
            },

            /**
             * bold
             * 
             * @access  protected
             * @param   Boolean on
             * @return  void
             */
            'bold': function(on) {
                var $bold = this.find('[name="bold"]');
                $bold.removeClass('active');
                if (on === true) {
                    $bold.addClass('active');
                }
            },

            /**
             * fontFamily
             * 
             * @note    <select> call below triggers dropdown <select>
                        handler, which triggers <change/fontFamily> handler
             * @access  protected
             * @param   String font
             * @return  void
             */
            'fontFamily': function(font) {
                var font = Stencil.account().collection('fonts').findByFamilyName(font);
                this._fontsDropdown.selectFont(font);
            },

            /**
             * fontSize
             * 
             * @access  protected
             * @param   String size
             * @return  void
             */
            'fontSize': function(size) {
                var $range = this.find('input[type="range"][name="fontSize"]');
                if (Config.default('skewFontSizeValues') === true) {
                    var uiValue = size;
                    size = this._getFontSizeStepValue(size);
                    $range.attr('data-ui-value', uiValue);
                }
                $range.val(size);
                this._positionTooltip($range);
            },

            /**
             * italic
             * 
             * @access  protected
             * @param   Boolean on
             * @return  void
             */
            'italic': function(on) {
                var $italic = this.find('[name="italic"]');
                $italic.removeClass('active');
                if (on === true) {
                    $italic.addClass('active');
                }
            },

            /**
             * lineHeight
             * 
             * @access  protected
             * @param   String height
             * @return  void
             */
            'lineHeight': function(height) {
                var $range = this.find(
                    'input[type="range"][name="lineHeight"]'
                );
                $range.val(height);
                this._positionTooltip($range);
            },

            /**
             * position
             * 
             * @access  protected
             * @param   Number position
             * @return  void
             */
            // 'position': function(position) {
            //     StencilBooter.log('positioning');
            // },

            /**
             * shadowStrength
             * 
             * @note    undefined check here is to prevent possible issues with
             *          text layers created previously that do not have a
             *          shadowStrength property defined
             * @access  protected
             * @param   String height
             * @return  void
             */
            'shadowStrength': function(value) {
                var $range = this.find(
                    'input[type="range"][name="shadowStrength"]'
                );
                value = value === undefined ? 0 : value;
                $range.val(value);
                this._positionTooltip($range);
            },

            /**
             * strokeColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'strokeColor': function(rgbaColorStr) {
                this._colorPickers.strokeColor.setColor(rgbaColorStr, false);
            },

            /**
             * textColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'textColor': function(rgbaColorStr) {
                this._colorPickers.textColor.setColor(rgbaColorStr, false);
            },

            /**
             * underline
             * 
             * @access  protected
             * @param   Boolean on
             * @return  void
             */
            'underline': function(on) {
                var $underline = this.find('[name="underline"]');
                $underline.removeClass('active');
                if (on === true) {
                    $underline.addClass('active');
                }
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'TextToolbarView')
         */
        _string: 'TextToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._drawFontsDropdown();
            this._setupBackdropColor();
            this._setupShadowStrength();
            this._setupFontSize();
            this._setupLineHeight();
            this._setupStrokeColor();
            this._setupTextColor();
            this._setupTooltips();
            // this._setupListeners();

            // Outline + Backdrop
            this.on({

                /**
                 * (anonymous)
                 * 
                 * Enables/disables parts of the UI based on what styles of the
                 * font are available.
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'change/fontFamily': function(event, font) {
                    font.loadFull();
                    this.toggleBoldAction();
                    this.toggleItalicAction();
                },
                'change/backdropColor': function(event) {
                    this.backdropColor.show.apply(this);
                },
                'change/strokeColor': function(event) {
                    this.strokeColor.show.apply(this);
                }
            });

            // Events
            this.on({
                'clear/backdropColor': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.backdropColor.clear.apply(this);
                    layer.triggerHandler('clear/backdropColor');
                },
                'clear/strokeColor': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    this.strokeColor.clear.apply(this);
                    layer.triggerHandler('clear/strokeColor');
                },
                'set/align/center': function(event) {
                    var layer = this._getSelectedLayer();
                    this._set.align.apply(this, ['center']);
                    layer.triggerHandler('change/align', ['center']);
                },
                'set/align/left': function(event) {
                    var layer = this._getSelectedLayer();
                    this._set.align.apply(this, ['left']);
                    layer.triggerHandler('change/align', ['left']);
                },
                'set/align/right': function(event) {
                    var layer = this._getSelectedLayer();
                    this._set.align.apply(this, ['right']);
                    layer.triggerHandler('change/align', ['right']);
                },
                'change/backdropStretch': function(event, type) {
                    var layer = this._getSelectedLayer();
                    layer.triggerHandler('change/backdropStretch', [type]);
                },
                'toggle/bold': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.bold.apply(this, [!on]);
                    layer.triggerHandler('change/bold', [!on]);
                },
                'toggle/italic': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.italic.apply(this, [!on]);
                    layer.triggerHandler('change/italic', [!on]);
                },
                'toggle/underline': function(event, $anchor) {
                    var layer = this._getSelectedLayer(),
                        on = $anchor.hasClass('active');
                    this._set.underline.apply(this, [!on]);
                    layer.triggerHandler('change/underline', [!on]);
                }
            });
        },

        /**
         * _drawFontsDropdown
         * 
         * @access  protected
         * @return  void
         */
        _drawFontsDropdown: function() {

            // Draw and create view
            var fontsCollection = Stencil.account().collection('fonts'),
                $fontsDropdown = DataUtils.render('FontsDropdown', {
                    fontsCollection: fontsCollection
                });
            this._element.find('div.tool.font').append($fontsDropdown);
            this._fontsDropdown = new FontsDropdownView(
                $fontsDropdown,
                fontsCollection
            );

            // Events
            var _this = this;
            this._fontsDropdown.on({

                /**
                 * Note that the order here is very important. Some listeners
                 * on the TextToolbarView's change/fontFamily-event lookup the
                 * selected-layer's font. So to ensure the value it receives is
                 * up-to-date, I need to trigger the layer's
                 * change/fontFamily-event first.
                 */

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'select': function(event, font) {
                    _this._getSelectedLayer().triggerHandler(
                        'change/fontFamily',
                        [font]
                    );
                    _this.triggerHandler('change/fontFamily', [font]);
                },

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'hover': function(event, font) {
                    _this._getSelectedLayer().getDrawing().triggerHandler(
                        'preview/fontFamily',
                        [font]
                    );
                },

                /**
                 * (anonymous)
                 * 
                 * @access  private
                 * @param   Object event
                 * @param   FontAccessor font
                 * @return  void
                 */
                'open': function(event) {
                    this.once({
                        'hover': function(event, font) {
                            var layer = _this._getSelectedLayer();
                            layer.triggerHandler('revert/bold');
                            layer.triggerHandler('revert/italic');
                            _this._set.bold.apply(_this, [false]);
                            _this._set.italic.apply(_this, [false]);
                        }
                    });
                },
                /**
                 * (anonymous)
                 * 
                 * This one is a bit more complicated. It's written to
                 * accommodate two cases:
                 * 1) Users focus on a text layer, choose the font dropdown,
                 *    highlight a font, and then click out of the toolbar. In
                 *    that case, the layer becomes the previously selected one
                 *    (since the event that discards it fires first).
                 * 2) Users focus on a text layer, choose the font dropdown,
                 *    highlight a font, and then click escape key to get out of
                 *    it. In that case, the layer is still selected, and
                 *    therefore should be accessed through that to have the font
                 *    revert.
                 * 
                 * @note    Always check selected before previous, otherwise
                 *          it might change the wrong text layer.
                 * @access  private
                 * @param   Object event
                 * @return  void
                 */
                'close': function(event) {
                    var font = this.getSelectedFont(),
                        selectedLayer = _this._getSelectedLayer(),
                        previouslySelectedLayer = Canvases.Preview.getPreviouslySelectedLayer();
                    if (selectedLayer !== false) {
                        selectedLayer.triggerHandler(
                            'change/fontFamily',
                            [font]
                        );
                    } else if (previouslySelectedLayer !== false) {
                        previouslySelectedLayer.triggerHandler(
                            'change/fontFamily',
                            [font]
                        );
                    }
                    // else if (selected !== false) {
                    //     selected.triggerHandler('change/fontFamily', [font]);
                    // }
                }
            });
        },

        /**
         * _getFontSizeSkewedValue
         * 
         * @see     http://www.xuru.org/rt/PR.asp
         * @see     https://local.getstencil.com/test/polynomial
         * @access  protected
         * @param   Number value
         * @return  Number
         */
        _getFontSizeSkewedValue: function(value) {
            value = value.toInt();
            if (value <= 100) {
                return value;
            }
            if (value <= 200) {
                return 2 * value - 101;// incremement by 2
            }
            if (value <= 225) {
                return 4 * value - 503;// incrememnt by 4
            }
            return 400;
        },

        /**
         * _getFontSizeStepValue
         * 
         * Returns the step number (used in the range input) based on the font
         * size value. I'm rounding here, because since we no longer have every
         * font size value represented as a possible step in the range input,
         * it's possible the calculations below result in a non-whole number,
         * which wouldn't make sense when setting the value of the input. It
         * would likely cause issues with the tooltips that are shown.
         * 
         * @access  protected
         * @param   Number value
         * @return  Number
         */
        _getFontSizeStepValue: function(value) {
            value = value.toInt();
            if (value <= 100) {
                return value;
            }
            if (value <= 301) {
                return ((value + 101) / 2).round(0);
            }
            if (value <= 397) {
                return ((value + 503) / 4).round(0);
            }
            return 226;
        },

        /**
         * _setupBackdropColor
         * 
         * @access  protected
         * @return  void
         */
        _setupBackdropColor: function() {
            var _this = this,
                $input = this.find('[name="backdropColor"]'),
                colorPicker = this._drawColorPicker($input, {
                    openDirection: 'up'
                });
            this._colorPickers.backdropColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/backdropColor',
                        layer = _this._getSelectedLayer();
// console.log(rgbaColorStr);
                    layer.triggerHandler(type, [rgbaColorStr]);
                    _this.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupFontSize
         * 
         * @see     http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access  protected
         * @return  void
         */
        _setupFontSize: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="fontSize"]'),
                listener = function(event) {
                    // var tooltip = $range.data('bs.tooltip');
                    // var size = _this._sizes.min + this.getStep()[0] - 1,
                    //     type = 'change/fontSize';
                    var layer = _this._getSelectedLayer(),
                        value = $(this).val();
                    if (Config.default('skewFontSizeValues') === true) {
                        value = _this._getFontSizeSkewedValue(value);
                        $range.attr('data-ui-value', value);
                    }
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/fontSize', [value]);
                    }
                };
            if (UserAgent.is.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupLineHeight
         * 
         * @see     http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access  protected
         * @return  void
         */
        _setupLineHeight: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="lineHeight"]'),
                listener = function(event) {
                    var layer = _this._getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/lineHeight', [value]);
                    }
                };
            if (UserAgent.is.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupShadowStrength
         * 
         * @see     http://www.hongkiat.com/blog/html5-range-slider-style/
         * @access  protected
         * @return  void
         */
        _setupShadowStrength: function() {
            var _this = this,
                $range = this.find('input[type="range"][name="shadowStrength"]'),
                listener = function(event) {
                    var layer = _this._getSelectedLayer(),
                        value = $(this).val();
                    if (layer !== false) {
                        _this._positionTooltip($range);
                        layer.triggerHandler('change/shadowStrength', [value]);
                    }
                };
            if (UserAgent.is.ie() === true) {
                $range.on({
                    'change': listener
                });
            } else {
                $range.on({
                    'input': listener
                });
            }
        },

        /**
         * _setupTooltips
         * 
         * @access  protected
         * @return  void
         */
        _setupTooltips: function() {
            this._setupTooltip('fontSize');
            this._setupTooltip('lineHeight');
            this._setupTooltip('shadowStrength');
        },

        /**
         * _setupStrokeColor
         * 
         * @access  protected
         * @return  void
         */
        _setupStrokeColor: function() {
            var _this = this,
                $input = this.find('[name="strokeColor"]'),
                colorPicker = this._drawColorPicker($input, {
                    openDirection: 'up'
                });
            this._colorPickers.strokeColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/strokeColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr]);
                    _this.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupTextColor
         * 
         * @access  protected
         * @return  void
         */
        _setupTextColor: function() {
            var _this = this,
                $input = this.find('[name="textColor"]'),
                colorPicker = this._drawColorPicker($input, {
                    fallbackColor: ColorUtils.getBlack(),
                    openDirection: 'up'
                });
            this._colorPickers.textColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/textColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * _setupListeners
         * 
         * @access  protected
         * @return  void
         */
        // _setupListeners: function() {
        //     var events = [
        //         'change/align',
        //         'change/backdropColor',
        //         'change/bold',
        //         'change/fontFamily',
        //         'change/fontSize',
        //         'change/italic',
        //         'change/strokeColor',
        //         'change/textColor',
        //         'change/underline',
        //         'preview/fontFamily'
        //     ];
        //     this.on(events.join(' '), function(event, value) {
        //         var layer = this._getSelectedLayer();
        //         if (layer !== false) {
        //             layer.triggerHandler(event.type, [value]);
        //         }
        //     });
        // },

        /**
         * bold
         * 
         * @access  protected
         * @var     Object
         */
        bold: {

            /**
             * disable
             * 
             * @access  public
             * @return  void
             */
            disable: function() {
                this.find('[name="bold"]').disable();
            },

            /**
             * enable
             * 
             * @access  public
             * @return  void
             */
            enable: function() {
                this.find('[name="bold"]').enable();
            }
        },

        /**
         * backdropColor
         * 
         * @access  protected
         * @var     Object
         */
        backdropColor: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $backdropStretch = this.find('[lookup="backdropStretch"]'),
                    $clear = this.find('[lookup="clear/backdropColor"]');
                $backdropStretch.addClass('hidden');
                $clear.addClass('hidden');
                this.getElement().removeClass('backdropExpanded');
                this._colorPickers.backdropColor.clearMinicolors();
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the backdrop
             * color input (when a value is defined).
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $backdropColor = this.find('[name="backdropColor"]'),
                    $column = $backdropColor.closest('div.column'),
                    $clear = $column.find('a'),
                    $type = $column.find('div.type');
                $clear.addClass('hidden');
                $type.addClass('hidden');
                if ($backdropColor.val() !== '') {
                    $clear.removeClass('hidden');
                    this.getElement().addClass('backdropExpanded');
                    $type.removeClass('hidden');
                }
            }
        },

        /**
         * getFontsDropdown
         * 
         * @access  public
         * @return  FontsDropdownView
         */
        getFontsDropdown: function() {
            return this._fontsDropdown;
        },

        /**
         * italic
         * 
         * @access  protected
         * @var     Object
         */
        italic: {

            /**
             * disable
             * 
             * @access  public
             * @return  void
             */
            disable: function() {
                this.find('[name="italic"]').disable();
            },

            /**
             * enable
             * 
             * @access  public
             * @return  void
             */
            enable: function() {
                this.find('[name="italic"]').enable();
            }
        },

        /**
         * strokeColor
         * 
         * @access  protected
         * @var     Object
         */
        strokeColor: {

            /**
             * clear
             * 
             * @access  public
             * @return  void
             */
            clear: function() {
                var $lookup = this.find('[lookup="clear/strokeColor"]');
                $lookup.addClass('hidden');
                this._colorPickers.strokeColor.clearMinicolors();
            },

            /**
             * show
             * 
             * Bad name; this method shows the related elements for the stroke
             * color input (when a value is defined).
             * 
             * @access  public
             * @return  void
             */
            show: function() {
                var $outline = this.find('[name="strokeColor"]'),
                    $clear = $outline.closest('div.column').find('a');
                $clear.addClass('hidden');
                if ($outline.val() !== '') {
                    $clear.removeClass('hidden');
                }
            }
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var layer = this._getSelectedLayer();
            this._super();
            this._set.fontFamily.apply(this, [layer.getStyle('fontFamily')]);
            this._set.align.apply(this, [layer.getStyle('align')]);
            if (layer.getStyle('backdropColor') !== false) {
                this._set.backdropColor.apply(
                    this,
                    [layer.getStyle('backdropColor')]
                );
                this._set.backdropStretch.apply(
                    this,
                    [layer.getStyle('backdropStretch')]
                );
                this.backdropColor.show.apply(this);
            } else {
                this.backdropColor.clear.apply(this);
                this._set.backdropStretch.apply(
                    this,
                    ['slim']
                );
            }
            this._set.bold.apply(this, [layer.getStyle('bold')]);
            this.toggleBoldAction();
            this._set.italic.apply(this, [layer.getStyle('italic')]);
            this.toggleItalicAction();
            // this._set.order.apply(this, [layer.getStyle('order')]);
            this._set.fontSize.apply(this, [layer.getStyle('fontSize')]);
            this._set.lineHeight.apply(this, [layer.getStyle('lineHeight')]);
            this._set.shadowStrength.apply(this, [layer.getStyle('shadowStrength')]);
            this.order.auto.apply(this);
            this._set.underline.apply(this, [layer.getStyle('underline')]);
            this._set.textColor.apply(this, [layer.getStyle('textColor')]);
            if (layer.getStyle('strokeColor') !== false) {
                this._set.strokeColor.apply(
                    this,
                    [layer.getStyle('strokeColor')]
                );
                this.strokeColor.show.apply(this);
            } else {
                this.strokeColor.clear.apply(this);
            }

            // 
            this._colorPickers.backdropColor.removeLastChange();
            this._colorPickers.strokeColor.removeLastChange();
            this._colorPickers.textColor.removeLastChange();
        },

        /**
         * toggleBoldAction
         * 
         * This method is used to determine whether or not the bold-button
         * should be clickable.
         * 
         * @access  public
         * @return  void
         */
        toggleBoldAction: function() {
            var layer = this._getSelectedLayer(),
                fontFamily = layer.getStyle('fontFamily'),
                font = Stencil.account().collection('fonts').findByFamilyName(fontFamily);
            if (font.get('bold').toInt() === 1) {
                this.bold.enable.apply(this);
            } else {
                this.bold.disable.apply(this);
            }
        },

        /**
         * toggleItalicAction
         * 
         * This method is used to determine whether or not the italic-button
         * should be clickable.
         * 
         * @access  public
         * @return  void
         */
        toggleItalicAction: function() {
            var layer = this._getSelectedLayer(),
                fontFamily = layer.getStyle('fontFamily'),
                font = Stencil.account().collection('fonts').findByFamilyName(fontFamily);
            if (
                UserAgent.supports.canvas.italic() === true
                || font.get('italic').toInt() === 1
            ) {
                this.italic.enable.apply(this);
            } else {
                this.italic.disable.apply(this);
            }
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('ToolbarView', function() {

    /**
     * VectorImageToolbarView
     * 
     * @extends ToolbarView
     */
    window.VectorImageToolbarView = ToolbarView.extend({

        /**
         * _set
         * 
         * Setters that update the UI of the toolbar only. Does not (and should
         * not) touch any underlying model logic.
         * 
         * @access  protected
         * @var     Object
         */
        _set: {

            /**
             * fillColor
             * 
             * @access  protected
             * @param   String rgbaColorStr
             * @return  void
             */
            'fillColor': function(rgbaColorStr) {
                this._colorPickers.fillColor.setColor(rgbaColorStr, false);
            }
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'VectorImageToolbarView')
         */
        _string: 'VectorImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
            this._setupFillColor();
        },

        /**
         * _setupFillColor
         * 
         * @access  protected
         * @return  void
         */
        _setupFillColor: function() {
            var _this = this,
                $input = this.find('[name="fillColor"]'),
                colorPicker = this._drawColorPicker($input, {
                    fallbackColor: ColorUtils.getBlack()
                });
            this._colorPickers.fillColor = colorPicker;
            colorPicker.on({
                'change': function(event, rgbaColorStr) {
                    var type = 'change/fillColor',
                        layer = _this._getSelectedLayer();
                    layer.triggerHandler(type, [rgbaColorStr]);
                }
            });
        },

        /**
         * show
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            var layer = this._getSelectedLayer();
            this._super();
            this.order.auto.apply(this);
            this._set.fillColor.apply(this, [layer.getStyle('fillColor')]);
            this._colorPickers.fillColor.removeLastChange();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('BitmapImageToolbarView', function() {

    /**
     * WatermarkBitmapImageToolbarView
     * 
     * @extends BitmapImageToolbarView
     */
    window.WatermarkBitmapImageToolbarView = BitmapImageToolbarView.extend({

        /**
         * _colorOverlayColorPickerOpenDirection
         * 
         * @access  protected
         * @var     String (default: 'down')
         */
        _colorOverlayColorPickerOpenDirection: 'down',

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'WatermarkBitmapImageToolbarView')
         */
        _string: 'WatermarkBitmapImageToolbarView',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @param   ToolbarsView toolbars
         * @return  void
         */
        init: function(element, toolbars) {
            this._super(element, toolbars);
        },

        /**
         * show
         * 
         * Removing the previously set delete listener to ensure that a weird
         * race-condition does not happen whereby the layer is deleted, and then
         * can no longer (efficiently) be accessed. Cleaner to have the delete
         * listener all here.
         * 
         * @access  public
         * @return  void
         */
        show: function() {
            this._super.apply(this, Array.prototype.slice.apply(arguments));
            this.unbind('delete');
            this.on({
                'delete': function(event, $anchor) {
                    var layer = this._getSelectedLayer();
                    layer.triggerHandler('delete');
                    layer.getWatermark().set({
                        'settings.active': 0
                    });
                    layer.getWatermark().save(['settings.active']);
                }
            });
            this.order.auto.apply(this);
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Base', function() {

    /**
     * View
     * 
     * @extends Base
     */
    window.View = Base.extend({

        /**
         * _busy
         * 
         * @access  protected
         * @var     false|BusyModalView (default: false)
         */
        _busy: false,

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'view')
         */
        _classType: 'view',

        /**
         * _element
         * 
         * @access  protected
         * @var     null|jQuery (default: null)
         */
        _element: null,

        /**
         * _events
         * 
         * @access  protected
         * @var     Object (default: {})
         */
        _events: {},

        /**
         * _listeners
         * 
         * @access  protected
         * @var     Function
         */
        _listeners: function() {
            return {
                click: {

                    /**
                     * (anonymous)
                     * 
                     * @note    Without the <stopPropagation> call below, multiple views
                     *          will catch the event since events are bound as live
                     *          events. This is needed to say "only count it once"
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger]:not([disabled])': function(event, $element) {
                        event.preventDefault();
                        event.stopPropagation();
                        var trigger = $element.attr('trigger');
                        this.triggerHandler(trigger, [$element, event]);
                    },

                    /**
                     * (anonymous)
                     * 
                     * Prevents disabled click events from default actions and going
                     * up the chain.
                     * 
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[click][trigger][disabled]': function(event, $element) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                },
                focus: {

                    /**
                     * (anonymous)
                     * 
                     * Firefox bug where you can focus on a readonly element
                     * 
                     * @note    Without the <stopPropagation> call below, multiple views
                     *          will catch the event since events are bound as live
                     *          events. This is needed to say "only count it once"
                     * @see     http://stackoverflow.com/questions/7917592/html-cursor-showing-in-readonly-input-text
                     * @access  private
                     * @param   jQuery event
                     * @param   jQuery $element
                     * @return  void
                     */
                    '[readonly]': function(event, $element) {
                        event.stopPropagation();
                        $element.blur();
                    }
                }
            };
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'View')
         */
        _string: 'View',

        /**
         * init
         * 
         * @access  public
         * @param   jQuery element
         * @return  void
         */
        init: function(element) {
            if (element.length > 1) {
                var msg = 'Invalid view instantiation';
                throw new Error(msg);
            }
            this._element = element;
            this._super();
            this._setupTabindex();
            this._setupListeners();
            // this._events = this._events();
        },

        /**
         * _getModel
         * 
         * @access  protected
         * @param   String model
         * @return  Model
         */
        _getModel: function(model) {
            return Stencil.getModel(model);
        },

        /**
         * _setupListeners
         * 
         * @note    Passes event and jQuery reference to current target
         * @access  protected
         * @return  void
         */
        _setupListeners: function() {
            var _this = this,
                listeners = this._listeners();
            // if (this._listeners.constructor === Function.constructor) {
            // this._listeners = this._listeners();
            // }
            jQuery.each(
                listeners,
                function(type, listener) {
                    jQuery.each(
                        listener,
                        function(selector, callback) {
                            _this._element.on(
                                type,
                                selector,
                                function(event) {
                                    if (typeof callback === 'string') {
                                        callback = _this._events[callback];
                                    }
                                    callback.apply(_this, [
                                        event,
                                        $(event.currentTarget)
                                    ]);
                                }
                            );
                        }
                    );
                }
            );
        },

        /**
         * _setupTabindex
         * 
         * Sets the tabindex value for any inputs found within the view,
         * ensuring that it's never a duplicate, and always incremented
         * properly. Important to use .find call to ensure modals do not repeat
         * defining the tabindex on an input.
         * 
         * @access  protected
         * @return  void
         */
        _setupTabindex: function() {
            if (UserAgent.is.firefox() === true) {
                this.find('[tabindex]').removeAttr('tabindex');
            } else {
                var tabindex = Stencil.get('tabindex');
                if (tabindex === undefined) {
                    tabindex = 0;
                }
                var $tabs = this.find('[tabindex]'),
                    $tab;
                jQuery.each($tabs, function(index, tab) {
                    $tab = $(tab);
                    if ($tab.data('tabindexed') === undefined) {
                        tabindex++;
                        $tab.data('tabindexed', true);
                        $tab.attr('tabindex', tabindex);
                    }
                });
                Stencil.set('tabindex', tabindex);
            }
        },

        /**
         * find
         * 
         * @access  public
         * @param   String selector
         * @return  jQuery
         */
        find: function(selector) {
            return this._element.find(selector);
        },

        /**
         * getBusy
         * 
         * @access  public
         * @return  BusyModalView
         */
        getBusy: function() {
            if (this._busy === false) {
                var $busy = DataUtils.render('BusyModal');
                this._busy = new BusyModalView($busy);
                this._element.append($busy);
            }
            return this._busy;
        },

        /**
         * getElement
         * 
         * @access  public
         * @return  HTMLElement
         */
        getElement: function() {
            return this._element;
        },

        /**
         * hourglass
         * 
         * @access  public
         * @return  void
         */
        hourglass: function() {
            this._element.hourglass();
        }
    });
}));
StencilBooter.queue.push(StencilBooter.requires('Stencil', function() {

    /**
     * Router
     * 
     * @note    This class is not using /app/static/js/helpers/singleton.js
     *          because it's extending a Backbone class, not the Base class.
     * @see     http://pragmatic-backbone.com/routing-and-controllers
     * @see     http://stackoverflow.com/questions/14526752/backbone-refresh-the-same-route-path-for-twice
     * @see     https://viget.com/extend/finally-introducing-routerrouter-a-javascript-routing-library
     * @extends Backbone.Router
     */
    window.Router = Backbone.Router.extend({

        /**
         * _classType
         * 
         * @access  protected
         * @var     String (default: 'router')
         */
        _classType: 'router',

        /**
         * _history
         * 
         * Array of paths made during the UX
         * 
         * @var     Array
         * @access  protected
         */
        _history: [],

        /**
         * _previous
         * 
         * Records the last non-modal path
         * 
         * @var     String
         * @access  protected
         */
        _previous: false,

        /**
         * _redirects
         * 
         * @var     Object
         * @access  public
         */
        _redirects: {
            'app/backgrounds/colors':               'app/icons',
            'app/backgrounds/search/(.*)':          'app/photos/search/$1',
            'app/backgrounds/stars':                'app/photos/favorites',
            'app/backgrounds/uploads':              'app/uploads',

            // Safari likes to add a trailing slash...
            'app/icons/':                           'app/icons',
            'app/templates/':                       'app/templates',
            'app/quotes/':                          'app/quotes',
            'app/uploads/':                         'app/uploads',
            'app/logos/':                           'app/logos',
            'app/images/':                          'app/images',

            // 
            'app/backgrounds/(.*)':                 'app/photos/$1',
                'app/icons/stars':                      'app/icons/favorites',      // wildcard redirect not working
                'app/icons/uploads':                    'app/uploads',              // wildcard redirect not working
                'app/templates/stars':                  'app/templates/favorites',  // wildcard redirect not working
                'app/quotes/stars':                     'app/quotes/favorites',     // wildcard redirect not working
                'app/saved/stars':                      'app/saved/favorites',      // wildcard redirect not working
            'app/tutorials/(.*)':                   'app/help/$1'
        },

        /**
         * _string
         * 
         * @access  protected
         * @var     String (default: 'Router')
         */
        _string: 'Router',

        /**
         * routes
         * 
         * @var     Object
         * @access  public
         */
        routes: {
            'app/admin/images':                         Stencil.getAction('Admin',      ['images', 'results'],          'Admin: Images'),
            'app/admin/users':                          Stencil.getAction('Admin',      ['users', 'results'],           'Admin: Users'),
            'app/admin/:section':                       Stencil.getAction('Admin',      'section',                      'Admin'),
            'app/admin/users/search':                   Stencil.getAction('Admin',      ['users', 'search'],            'Admin: Users Search'),
            'app/admin/users/search/:query':            Stencil.getAction('Admin',      ['users', 'results'],           'Admin: Users Results'),
            'app/admin/users/:key':                     Stencil.getAction('Admin',      ['users', 'update'],            'Admin: Users Update'),
            'app/admin/categories/add':                 Stencil.getAction('Categories', 'add',                          'Add category modal'),
            'app/admin/coupons/add':                    Stencil.getAction('Coupons',    'add',                          'Add coupon modal'),
            'app/admin/promoSets/add':                  Stencil.getAction('PromoSets',  'add',                          'Add promo set modal'),
            'app/admin/assets/reimport':                Stencil.getAction('Admin',      'reimportAssets',               'Reimport assets'),
            'app/admin/cache/refresh':                  Stencil.getAction('Admin',      'cacheRefresh',                 'Refresh cached object'),
            'app':                                      Stencil.getAction('Photos',     'category',                     'Photos: Features'),
            'app/photos/search/:query':                 Stencil.getAction('Photos',     'search',                       'Photos: Search'),
            'app/photos/:category':                     Stencil.getAction('Photos',     'category',                     'Photos: Category'),
            'app/photos/collections/:category':         Stencil.getAction('Photos',     'collection',                   'Photos: Category'),
            'app/fonts/import':                         Stencil.getAction('App',        'googleFonts',                  'Google fonts'),
            'app/icons':                                Stencil.getAction('Graphics',   'category',                     'Graphics: Features'),
            'app/icons/search/:query':                  Stencil.getAction('Graphics',   'search',                       'Graphics: Search'),
            'app/icons/:category':                      Stencil.getAction('Graphics',   'category',                     'Graphics: Category'),
            'app/icons/collections/:category':          Stencil.getAction('Graphics',   'collection',                   'Graphics: Category'),
            'app/quotes':                               Stencil.getAction('Quotes',     'category',                     'Quotes: Features'),
            'app/quotes/search/:query':                 Stencil.getAction('Quotes',     'search',                       'Quotes: Search'),
            'app/quotes/:category':                     Stencil.getAction('Quotes',     'category',                     'Quotes: Category'),
            'app/quotes/collections/:category':         Stencil.getAction('Quotes',     'collection',                   'Quotes: Category'),
            'app/templates':                            Stencil.getAction('Templates',  'category',                     'Templates: Features'),
            'app/templates/:category':                  Stencil.getAction('Templates',  'category',                     'Templates: Category'),
            'app/templates/:key/preview':               Stencil.getAction('Templates',  'preview',                      'Templates: Preview'),
            'app/templates/collections/:category':      Stencil.getAction('Templates',  'collection',                   'Templates: Category'),
            'app/uploads':                              Stencil.getAction('Uploads',    'category',                     'Uploads: All'),
            'app/uploads/:category':                    Stencil.getAction('Uploads',    'category',                     'Uploads: Category'),
            'app/uploads/collections/:category':        Stencil.getAction('Uploads',    'collection',                   'Uploads: Category'),
            'app/logos':                                Stencil.getAction('Watermarks', 'category',                     'Watermarks'),
            'app/saved':                                Stencil.getAction('Images',     'category',                     'Images: All'),
            'app/saved/:category':                      Stencil.getAction('Images',     'category',                     'Images: Category'),
            'app/saved/collections/:category':          Stencil.getAction('Images',     'collection',                   'Images: Category'),
            'app/images/:key/confirm/mobile/:mobile':   Stencil.getAction('Images',     ['mobile', 'confirm'],          'Images: Confirm mobile'),
            'app/images/:key/sent':                     Stencil.getAction('Images',     'sent',                         'Image sent modal'),
            'app/images/:key/normalize':                Stencil.getAction('Images',     'normalize',                    'Image normalize modal'),
            'app/images/:key/share/:network':           Stencil.getAction('Images',     'share',                        'Image share modal'),
            'app/images/:key/:connection/error':        Stencil.getAction('Images',     'error',                        'Image share error modal'),
            'app/shares/:key/success':                  Stencil.getAction('Shares',     'success',                      'Image shared modal'),
            'app/delinquent':                           Stencil.getAction('Users',      'delinquent',                   'Delinquent modal'),
            'app/login':                                Stencil.getAction('Users',      'login',                        'Login modal'),
            'app/signup':                               Stencil.getAction('Users',      'signup',                       'Signup modal'),
            'app/password':                             Stencil.getAction('Users',      'password',                     'Password modal'),
            'app/promo':                                Stencil.getAction('Users',      'promo',                        'Promo modal'),
            'app/promo/:partner':                       Stencil.getAction('Users',      'promo',                        'Promo modal (partner)'),
            'app/countdown':                            Stencil.getAction('Accounts',   'countdown',                    'Countdown modal'),
            'app/upgraded/:plan':                       Stencil.getAction('Accounts',   'upgraded',                     'Upgraded modal'),
            'app/plans':                                Stencil.getAction('Accounts',   'plans',                        'Plans modal'),
            'app/browser':                              Stencil.getAction('App',        'browser',                      'Browser modal'),
            'app/legacy':                               Stencil.getAction('App',        'legacy',                       'Legacy modal'),
            'app/orientation':                          Stencil.getAction('App',        'orientation',                  'Orientation modal'),
            'app/alert/:code':                          Stencil.getAction('App',        'alert',                        'Alert modal'),
            // 'app/error/:code/:reference':               Stencil.getAction('App',        'error',                        'Error modal'),
            'app/error':                                Stencil.getAction('App',        'error',                        'Error modal'),
            'app/cookies':                              Stencil.getAction('App',        'cookies',                      'Cookies modal'),
            'app/help/:section':                        Stencil.getAction('App',        'tutorials',                    'Help'),
            'app/upgrade/:plan/:reason':                Stencil.getAction('Accounts',   'upgrade',                      'Upgrade modal'),
            'app/checkout/:plan':                       Stencil.getAction('Accounts',   'checkout',                     'Checkout modal'),
            'app/checkout/:plan/coupon':                Stencil.getAction('Coupons',    'apply',                        'Coupon apply modal'),
            'app/checkout/:plan/coupon/:code':          Stencil.getAction('Coupons',    'apply',                        'Coupon apply modal'),
            'app/settings/plan':                        Stencil.getAction('Users',      ['settings', 'plan'],           'Settings: Plan'),
            'app/settings/plan/switch/:plan':           Stencil.getAction('Accounts',   ['plan', 'switch'],             'Settings: Plan Switch'),
            'app/settings/plan/switched/:plan':         Stencil.getAction('Accounts',   ['plan', 'switched'],           'Settings: Plan Switched'),
            'app/settings/profile':                     Stencil.getAction('Users',      ['settings', 'profile'],        'Settings: Profile'),
            'app/settings/social':                      Stencil.getAction('Users',      ['settings', 'social'],         'Settings: Social'),
            'app/settings/password':                    Stencil.getAction('Users',      ['settings', 'password'],       'Settings: Password'),
            'app/settings/notifications':               Stencil.getAction('Users',      ['settings', 'notifications'],  'Settings: Notifications'),
            'app/settings/delete':                      Stencil.getAction('Users',      ['settings', 'obfuscate'],      'Settings: Obfuscate'),
            'app/settings/payment':                     Stencil.getAction('Users',      ['settings', 'payment'],        'Settings: Payment'),
            'app/settings/referral':                    Stencil.getAction('Users',      ['settings', 'referral'],       'Settings: Referral'),
            'app/settings/:network/connected':          Stencil.getAction('Accounts',   'connections',                  'Settings: Connections'),
            'app/extras':                               Stencil.getAction('App',        'extras',                       'Extras modal'),
            'app/extras/chrome/success':                Stencil.getAction('App',        'chromeSuccess',                'Chrome installed modal'),
            'app/onboard':                              Stencil.getAction('Users',      'onboard',                      'Onboarding modal'),
            'app/welcome':                              Stencil.getAction('Accounts',   'welcomeTour',                  'Welcome tour modal'),
            'app/welcome/:step':                        Stencil.getAction('Accounts',   'welcomeTour',                  'Welcome tour modal'),
            '*wildcard':                                Stencil.getAction('App',        'wildcard')
        },

        /**
         * initialize
         * 
         * Tracks the fragment the client is currently using, and triggers an
         * event against that fragment.
         * 
         * @access  public
         * @return  void
         */
        initialize: function() {
            var _this = this;
            this.on(
                'route',
                function() {
                    var fragment = Backbone.history.fragment;
                    this.trigger('route:' + (fragment));
                    _this._history.push(fragment);
                }
            );
        },

        /**
         * execute
         * 
         * @note    Prevents navigation by returning false if the Error modal is
         *          showing.
         * @access  public
         * @param   Function callback
         * @param   Array args
         * @param   String name
         * @return  false|void
         */
        execute: function(callback, args, name) {
            if (Modals.get('Error') !== false) {
                return false;
            }
            if (Modals.get('Alert') !== false) {
                var modal = Modals.get('Alert');
                if (modal.getSettings().closable === false) {
                    return false;
                }
            }
            var params = {},
                query = args.pop();
            if (query !== null) {
                params = this._getParams(query);
            }
            params.event = callback.toString();
            args.push(params);
            callback.apply(this, args);
        },

        /**
         * _getParams
         * 
         * @see     http://stackoverflow.com/questions/8486099/how-do-i-parse-a-url-query-parameters-in-javascript
         * @access  protected
         * @param   String query
         * @return  Object
         */
        _getParams: function(query) {
            var result = {};
            query.split('&').forEach(
                function(part) {
                    if(!part) {
                        return;
                    }
                    var item = part.split('='),
                        key = item[0],
                        val = decodeURIComponent(item[1] || true),
                        from = key.indexOf('[');
                    if (from === -1) {
                        result[key] = val;
                    } else {
                        var to = key.indexOf(']'),
                            index = key.substring(from + 1, to);
                        key = key.substring(0,from);
                        if(!result[key]) {
                            result[key] = [];
                        }
                        if (!index) {
                            result[key].push(val);
                        } else {
                            result[key][index] = val;
                        }
                    }
                }
            );
            return result;
        },

        /**
         * current
         * 
         * @access  protected
         * @return  Object
         */
        current: function() {
            return this.matching(Backbone.history.fragment);
        },

        /**
         * getClassType
         * 
         * @access  public
         * @return  String
         */
        getClassType: function() {
            return this._classType;
        },

        /**
         * getPrevious
         * 
         * Returns the last non-modal path
         * 
         * @access  public
         * @return  String
         */
        getPrevious: function() {
            return this._previous;
        },

        /**
         * getRedirects
         * 
         * @access  public
         * @return  Object
         */
        getRedirects: function() {
            return this._redirects;
        },

        /**
         * log
         * 
         * @access  public
         * @return  void
         */
        log: function() {
            var msg = '/' + (this.current().fragment);
            LogUtils.log.object(this, msg);
        },

        /**
         * matching
         * 
         * @see     http://stackoverflow.com/questions/7563949/backbone-js-get-current-route/16191880#16191880
         * @access  protected
         * @return  Object
         */
        matching: function(fragment) {
            var Router = this,
                routes = _.pairs(Router.routes),
                route = null,
                params = null,
                matched;
            matched = _.find(
                routes,
                function(handler) {
                    route = _.isRegExp(handler[0])
                        ? handler[0]
                        : Router._routeToRegExp(handler[0]);
                    return route.test(fragment);
                }
            );
            if (matched) {
                params = Router._extractParameters(route, fragment);
                route = matched[1];
            }
            return {
                route: route,
                fragment: fragment,
                params: params
            };
        },

        /**
         * recent
         * 
         * @access  public
         * @param   Number recent
         * @return  String
         */
        recent: function(recent) {
            var entry = this._history[this._history.length - 1 - recent];
            if (entry === undefined) {
                entry = 'app';
            }
            return entry;
        },

        /**
         * setPrevious
         * 
         * Sets the previous non-modal path.
         * 
         * @access  public
         * @param   String|false path
         * @return  void
         */
        setPrevious: function(path) {
            this._previous = path;
        },

        /**
         * toString
         * 
         * @access  public
         * @return  String
         */
        toString: function() {
            return this._string;
        }
    });
}));

/**
 * Stencil
 * 
 * @note     Global shortform accessors are:
 *           - App
 *           - Frame
 *           - Canvases.Ghost
 *           - Canvases.Preview
 *           - Toolbars
 *           - Footer
 * @todo     Move script event listening to Scripts class
 * @events   script/loaded
 *           script/facebook/loaded
 *           script/twitter/loaded
 *           script/segment/loaded
 *           script/accountDock/loaded
 *           script/twitter/loaded
 *           resource/feature/complete
 *           resource/operation/complete
 *           resource/save/complete
 * @abstract
 */
window.Stencil = (function() {

    /**
     * __app
     * 
     * @access  private
     * @var     AppView
     */
    var __app;

    /**
     * __classType
     * 
     * @access  private
     * @var     String (default: 'stencil')
     */
    var __classType = 'stencil';

    /**
     * __dead
     * 
     * Tracks whether the app has already been killed, to prevent multiple calls
     * to Stencil.kill from having any effect. This would happen if, for
     * example, requests were queued up. When the first one would timeout, any
     * subsequent ones would be aborted, which would then trigger a
     * Stencil.error, which would result in a Stencil.kill call.
     * 
     * @access  private
     * @var     Boolean (default: false)
     */
    var __dead = false;

    /**
     * __frozen
     * 
     * @access  private
     * @var     Boolean (default: false)
     */
    var __frozen = false;

    /**
     * __options
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __options = {};

    /**
     * __router
     * 
     * @access  private
     * @var     Router
     */
    var __router;

    /**
     * __addPostMessageListeners
     * 
     * Adds listeners to window to allow for Chrome extension integration.
     * 
     * @note    { check below is to ensure json is being sent. This is sometimes
     *          not the case when the user has extensions installed. They can
     *          call parent frames with string-data that will break the below
     *          parsing.
     * @todo    Add preloading for image upload, to ensure it shows up r
     *          away when the tab is shown?
     * @access  private
     * @return  void
     */
    var __addPostMessageListeners = function() {
        $(window).on({
            'message': function(event) {
                var original = event.originalEvent;
                if (original.data[0] === '{') {
                    var data = JSON.parse(original.data);
    // StencilBooter.log(data);
                    if (data.action === 'message.app.hide') {
                        App.hide();
                    } else if (data.action === 'message.app.show') {
                        App.show();
                    } else if (data.action === 'message.app.params.store') {
                        Stencil.set('messageParams', data.params);
                        if (data.params.image !== false) {
                            Stencil.importUrl(
                                data.params.image,
                                data.params.selection
                            );
                        } else {
                            if (
                                data.params.selection !== false
                                && data.params.selection !== undefined
                            ) {
                                __launch(function() {
                                    msg = Stencil.getMessage('image.import.almost');
                                    App.getBusy().show(msg);
                                    var canvas = Canvases.Preview;
                                    canvas.once({
                                        'render': function(event) {
                                            canvas.clear(false);
                                            canvas.getBusy().hide();
                                            App.getBusy().hide();
                                            var layer = canvas.addTextLayer({
                                                    text: data.params.selection.trim(),
                                                    width: 80
                                                }),
                                                drawing = layer.getDrawing();
                                            drawing.once({
                                                'draw': function(event) {
                                                    drawing.animate();
                                                }
                                            });
                                            drawing.draw();
                                        }
                                    });
                                });
                            } else {
                                __launch();
                            }
                        }
                    }
                }
            }
        });
    };

    /**
     * __adjustDefaultCanvases
     * 
     * Currently limited to changing the default font family for the app default
     * canvases, to the value stored in the AccountAccessor's settings.
     * 
     * @access  private
     * @return  void
     */
    var __adjustDefaultCanvases = function() {
        var canvases = Config.default('canvases'),
            account = Stencil.get('account'),
            guest = canvases.guest,
            user = canvases.user,
            defaultFontFamily = account.getDefaultFontFamily();
        guest.layers[2].fontFamily = defaultFontFamily;
        user.layers[2].fontFamily = defaultFontFamily;
    };

    /**
     * __alert
     * 
     * @access  private
     * @param   String msg
     * @return  void
     */
    var __alert = function(msg) {
        alert(msg);
    };

    /**
     * __askForNativeNotificationsPermission
     * 
     * @access  private
     * @param   String relativeTime
     * @return  Boolean
     */
    var __askForNativeNotificationsPermission = function(relativeTime) {
        if (Stencil.account().createdBefore(relativeTime) !== true) {
            return false;
        }
        if (UserAgent.is.chrome() !== true && UserAgent.is.firefox() !== true) {
            return false;
        }
        if (Notification === undefined || Notification === null) {
            return false;
        }
        if (Notification.permission === 'granted') {
            return false;
        }
        if (Notification.permission === 'denied') {
            return false;
        }
        Notification.requestPermission(function(permission) {
            if (permission === 'granted') {
                Stencil.account().push('settings.grantedNativeNotifications', 1);
                var notificationObject = Config.get('notifications').current;
                localStorage.setItem('stencil.nativeNotificationLastShown', notificationObject.stamp);
                // Stencil.cookies.set(
                //     'nativeNotificationLastShown',
                //     notificationObject.stamp
                // );
                return true;
            }
            return false;
        });
        return true;
    };

    /**
     * __checkForAdBlockers
     * 
     * @access  private
     * @return  void
     */
    var __checkForAdBlockers = function() {
        if (Cookies.get('adBlocker/notified') === undefined) {
            var image = new Image();
            image.onerror = function() {
                Stencil.alert('adBlocker.found');
                Stencil.cookies.set('adBlocker/notified', 1);
            };
            image.src = 'https://www.facebook.com/impression.php';
        }
    };

    /**
     * __checkForConflictingExtensions
     * 
     * @access  private
     * @return  Boolean
     */
    var __checkForConflictingExtensions = function() {
        if (__app.find('#ezLinkPreviewDIV').length > 0) {
            if (Cookies.get('conflictingExtension/ezLinkPreview') === undefined) {
                Stencil.alert('extension.conflicting.ezLinkPreview');
                Stencil.cookies.set('conflictingExtension/ezLinkPreview', 1);
                return true;
            }
        }
        if (__app.find('#ghostery-purple-box').length > 0) {
            if (Cookies.get('conflictingExtension/ghostery') === undefined) {
                Stencil.alert('extension.conflicting.ghostery');
                Stencil.cookies.set('conflictingExtension/ghostery', 1);
                return true;
            }
        }
        return false;
    };

    /**
     * __connect
     * 
     * @access  private
     * @param   Function callback
     * @return  void
     */
    var __connect = function(callback) {
        var email = 'support@getstencil.com',
            fallback = 'Something went wrong. Please email ' + (email);
        Stencil.ajax({
            signature: {file: 'Stencil', line: 138},
            url: '/connect',
            type: 'GET',
            error: function(jqXHR, textStatus, errorThrown) {
                LogUtils.log.object(Stencil, arguments, true);
                __alert('#100 - ' + (fallback));
            },
            success: function(response) {
                if (response.success === true) {
                    callback(response);
                } else {
                    LogUtils.log.object(Stencil, arguments, true);
                    __alert('#101 - ' + (fallback));
                }
            }
        });
    };

    /**
     * __drawTemplates
     * 
     * @access  private
     * @param   Array templates
     * @return  void
     */
    var __drawTemplates = function (templates) {
        for (var index in templates) {
            $('#templates').append(templates[index]);
        }
    };

    /**
     * __launch
     * 
     * @access  private
     * @param   Function callback
     * @return  void
     */
    var __launch = function (callback) {

        // Cookies not supported
        if (UserAgent.supports.cookies() === false) {
            $('div.modal.busy').addClass('hidden');
            $('div.modal.cookies').removeClass('hidden');
            throw new Error('Cookies are required for Stencil');
        }

        // Browser not supported
        if (UserAgent.valid() === false) {
            $('div.modal.busy').addClass('hidden');
            $('div.modal.browser').removeClass('hidden');
            throw new Error('Modern browser is required for Stencil');
        }

        // Router logging + init
        __router.on({
            'route': __router.log.proxy(__router)
        });
        __connect(function(response) {
            var data = response.data;

            // Set the static server path
            window.STATIC = 'https://' + (data.config.hosts.static);

            // Config
            Stencil.set('config', data.config);
            // ImagePreloadWorker.preload(Config.get('preload'));

            /**
             * Raven tracking
             * 
             * @note    It's actually important to not update the release value,
             *          even if it can be detected (for example, user hits /connect
             *          upon load with value 'abc', and then after going to their
             *          favorite photos, in that time, a new release is available).
             *          If this value was updated, it might mis-report errors that
             *          have actually been fixed in that version, but since the
             *          user hadn't yet loaded the new codebase, might not actually
             *          be fixed.
             */
            (function() {
                if ('Raven.setRelease'.validMethod() === true) {
                    var ravenReleaseString = 'local';
                    if (response.version !== false) {
                        ravenReleaseString = response.version;
                    }
                    Raven.setRelease(ravenReleaseString);
                }
                if ('Raven.setEnvironment'.validMethod() === true) {
                    Raven.setEnvironment(Config.getRole());
                }
            })();

            // Global features
            var globalFeatures = [],
                index,
                category;
            for (index in data.config.categories) {
                category = data.config.categories[index];
                globalFeatures = globalFeatures.concat(category.features);
            }
            globalFeatures = _.uniq(globalFeatures);
            Stencil.set('globalFeatures', globalFeatures);

            // Templates
            __drawTemplates(data.config.markup.templates);

            // Defaults
            Frames.store(data.config.frames);

            // S3 upload tracking
            // Stencil.set('s3.uploads', []);

            // Account
            var model = Stencil.getModel('Account'),
                account = model.setAccessor(data.account);
            Stencil.set('account', account);

            // Adjust default canvases with account's default font
            __adjustDefaultCanvases();

            // Categories
            var collection = new CategoriesCollection();
            collection.map(data.config.categories);
            Stencil.set('globalCategories', collection);

            /**
             * Wait for all the normal fonts to be have been loaded before
             * continuing.
             */
            var fontsCollection = Stencil.account().collection('fonts');
            fontsCollection.once({
                'load/all/normal': function(event) {
                    var latoFont = fontsCollection.findByFamilyName('Lato');
                    latoFont.loadFull(function() {

                        // User
                        var user = false;
                        if (data.user !== false) {
                            model = Stencil.getModel('User');
                            user = model.setAccessor(data.user);
                            user.on({
                                'change': Track.user
                            });
                            Stencil.account().on({
                                'change': Track.user
                            });
                        }
                        Stencil.set('user', user);

                        // Scripts
                        Stencil.on({
                            'script/accountDock/loaded': __setupAccountDock,
                            'script/aws/loaded': __setupAws,
                            'script/facebook/loaded': __setupFacebook,
                            'script/stripe/loaded': __setupStripe,
                            'script/tapfiliate/loaded': __setupTapfiliate
                        });

                        // Headway setup
                        if (Services.check('headway') === true) {
                            var id = data.config.headway.auth.apps.paid.id;
                            __setupHeadway(id);
                            Scripts.load('headway');
                        }
                        
                        Scripts.load('tapfiliate');

                        // Resource operations
                        __setupResourceOperationListeners();

                        // Segment booting
                        var segment = Scripts.get('segment');
                        segment = segment.replace(
                            'key',
                            data.config.segment.key
                        );
                        Scripts.set('segment', segment);
                        if (Track.enabled() === true) {
                            Scripts.load('segment');
                        }

                        // View
                        var $app = $('body.app');
                        __app = new AppPageView($app);
                        __app.setSelectedFrame();
                        Stencil.set('smartToggleWatermarks', true);
                        __app.getStage().getContent().drawPreviewCanvas();

                        // Helpscount setup
                        if (Services.check('helpScout') === true) {
                            var id = data.config.helpScout.auth.beacon.id;
                            HelpScout.init(id);
                        }

                        // Initialize change history
                        ChangeHistory.setOperationType('initial');
                        ChangeHistory.track(true, false);

                        // Start navigation
                        Backbone.history.start({
                            pushState: true
                        });

                        // Tablet orientation or legacy welcome
                        if (UserAgent.is.ipad() === true) {
                            if (UserAgent.getOrientation() === 'portrait') {
                                Stencil.navigate('/app/orientation?clean=1');
                            }
                        } else if (__store.user !== false) {
                            __store.user.showLegacyWelcome();
                        }

                        // Done
                        callback && callback();

                        // Check for ad blockers
                        if (__checkForConflictingExtensions() === false) {
                            // __checkForAdBlockers();
                        }

                        // Notification requests
                        var nativeNotifications = Config.default('nativeNotifications');
                        if (nativeNotifications === true) {
                            var relativeTime = Config.default('nativeNotificationMinRelativeTime');
                            __askForNativeNotificationsPermission(relativeTime);
                        }

                        // Check for skew issues
                        (function() {
                            Stencil.alive(function() {
                                Stencil.getModel('S3Upload').performSkewCheck();
                            });
                        }).delay(5 * 60 * 1000);

                        /**
                         * @todo    Add blocking check in above that ensures a
                         *          minimum width for non-tablet devices. Can
                         *          compare $('body').width()
                         *          and window.screen.availWidth. The latter
                         *          provides the possible width the window could
                         *          be based on their OS settings. Show a simple
                         *          modal (that can be dismissed) which suggests
                         *          they make the window as big as possible for
                         *          the best experience.
                         */

                        // Login welcome modal
                        // User.on('login', function(event) {

                        // });
                    });
                }
            });

            /**
             * Excluding the Stencil app font Lato, since I'll load that in
             * after all the normal ones have been.
             */
            fontsCollection.loadAllNormal(['Lato']);
        });
    };

    /**
     * __setupAccountDock
     * 
     * @access  private
     * @return  void
     */
    var __setupAccountDock = function() {
        if ('AccountDock.configure'.validMethod() === true) {
            AccountDock.configure({
                key: Config.get('accountDock').key
            });
        }
    };

    /**
     * __setupAws
     * 
     * @access  private
     * @return  void
     */
    var __setupAws = function() {
        if (AWS.S3.prototype.customizeRequests !== undefined) {
            AWS.S3.prototype.customizeRequests(function(request) {
                request.on('extractData', function(response){
                    // console.log('success operation: ', response.request.operation, 'requestId: ', response.requestId)
                });
                request.on('extractError', function(response){
                    // console.log('fail operation: ', response.request.operation, 'requestId: ', response.requestId)
                });
            });
        }
    };

    /**
     * __setupFacebook
     * 
     * @access  private
     * @return  void
     */
    var __setupFacebook = function() {
        if ('FB.init'.validMethod() === true) {
            FB.init({
                appId: Config.get('facebook').id,
                status: true,
                cookie: true,
                xfbml: true,
                version: 'v2.9'
            });
        }
    };

    /**
     * __setupHeadway
     * 
     * @note    tabindex logic below is to make it so that nothing in the iframe
     *          can be accessed via the tab-key.
     * @access  private
     * @param   String id
     * @return  void
     */
    var __setupHeadway = function(id) {
        window.HW_config = {
            selector: 'header div.headway',
            account: id
        };
        Stencil.once({
            'script/headway/loaded': function(event) {
                var interval = (function() {
                    if ($('#HW_frame_cont iframe').length !== 0) {
                        $('#HW_frame_cont iframe').attr('tabindex', '-1');
                        IntervalPool.clear(interval);
                    }
                }).interval(250);
            }
        });
    };

    /**
     * __setupMoment
     * 
     * @access  private
     * @return  void
     */
    var __setupMoment = function() {
        moment.locale('en', {
            calendar: {
                lastDay: '[Yday @] LT',
                sameDay: '[Today @] LT',
                nextDay: '[Tomorrow @] LT',
                // lastWeek: '[Last] ddd [@] LT',
                lastWeek: 'ddd [@] LT',
                nextWeek: 'ddd [@] LT',
                sameElse: 'L @ LT'
            }
        });
    };

    /**
     * __setupResourceOperationListeners
     * 
     * Listens for successful resource features, saves and favorites in order to
     * keep track of how many are running at any point. Currently being used to
     * throttle resource-operations to prevent overloading the server, as well
     * as queueing up too many front-end ajax calls.
     * 
     * @access  private
     * @return  void
     */
    var __setupResourceOperationListeners = function() {
        Stencil.on({
            /**
             * @param String event
             * @param AssetAccessor asset
             */
            'resource/feature/complete': function(event, asset) {
                var parallelResourceFeatures = Stencil.get('parallelResourceFeatures');
                --parallelResourceFeatures;
                Stencil.set('parallelResourceFeatures', parallelResourceFeatures);
            },
            /**
             * @param String event
             * @param String operation
             * @param AssetAccessor asset
             */
            'resource/operation/complete': function(event, operation, asset) {
                var parallelResourceOperations = Stencil.get('parallelResourceOperations');
                --parallelResourceOperations;
                Stencil.set('parallelResourceOperations', parallelResourceOperations);
            },
            /**
             * @param String event
             * @param AssetAccessor asset
             */
            'resource/save/complete': function(event, asset) {
                var parallelResourceSaves = Stencil.get('parallelResourceSaves');
                --parallelResourceSaves;
                Stencil.set('parallelResourceSaves', parallelResourceSaves);
            }
        });
    };

    /**
     * __setupStripe
     * 
     * @access  private
     * @return  void
     */
    var __setupStripe = function() {
        if ('Stripe.setPublishableKey'.validMethod() === true) {
            Stripe.setPublishableKey(
                Config.get('stripe').publishableKey
            );
        }
    };

    /**
     * __setupTapfiliate
     * 
     * @access  private
     * @return  void
     */
    var __setupTapfiliate = function() {
        if ('tap'.validMethod() === true) {
            var accountId = Config.get('tapfiliate').auth.accountId;
            tap('create', accountId);
            tap('detectClick');
        }
    };

    /**
     * __store
     * 
     * @access  private
     * @var     Object (default: {})
     */
    var __store = {};

    /**
     * __string
     * 
     * @access  private

     * @var     String (default: 'Stencil')
     */
    var __string = 'Stencil';

    // Public
    return jQuery.extend(true, {}, {
    /**
     * getClassType
     * 
     * @access  public
     * @return  String
     */
    getClassType: function() {
        return __classType;
    },

    /**
     * on
     * 
     * @access  public
     * @return  void
     */
    on: function() {
        $(this).on.apply($(this), $(arguments).toArray());
    },

    /**
     * once
     * 
     * @access  public
     * @return  void
     */
    once: function() {
        $(this).one.apply($(this), $(arguments).toArray());
    },

    /**
     * toString
     * 
     * @access  public
     * @return  String
     */
    toString: function() {
        return __string;
    },

    /**
     * triggerHandler
     * 
     * @access  public
     * @return  void
     */
    triggerHandler: function() {
        var eventType = arguments[0];
        LogUtils.log.object(this, eventType);
        $(this).triggerHandler.apply($(this), $(arguments).toArray());
    },

    /**
     * unbind
     * 
     * @access  public
     * @return  void
     */
    unbind: function() {
        $(this).unbind.apply($(this), $(arguments).toArray());
    }
}
, {

        /**
         * account
         * 
         * @access  public
         * @return  AccountAccessor
         */
        account: function() {
            return Stencil.get('account');
        },

        /**
         * active
         * 
         * Returns whether or not any remote connections are active. This
         * includes ajax calls and S3 pushes.
         * 
         * @note    The way jQuery.active works is if the server responds (with
         *          anything), or the jQuery timeout value for ajax calls is
         *          reached, jQuery.active is decremented. But if no response
         *          comes back (eg. their is a browser-security issue, or
         *          something else unforseen), the error handler for the outbound
         *          ajax call will be triggered, but jQuery.active won't be
         *          decremented. So this means that sometimes, jQuery.active
         *          could be 1. Now, <Stencil.kill> sets jQuery.active to 0 since
         *          it's known that the app is no longer live. But the issue was
         *          that when <Stencil.kill> was called from within an ajax error
         *          handler, jQuery's internal logic would fire _after_ that,
         *          which would then further decrement the jQuery.active value.
         *          This means it's possible for jQuery.active to be less than 0
         *          (currently, I think only -1). So to accommodate for this, I
         *          no longer check jQuery.active against a non-zero value, but
         *          rather a _greater than_ zero value.
         * @access  public
         * @return  Boolean
         */
        // active: function() {
        //     return jQuery.active > 0
        //     // return jQuery.active > 0
        //         || Stencil.get('s3.uploads').length !== 0;
        // },

        /**
         * ajax
         * 
         * Proxy for ajax calls. Initially created to facilitate a Safari bug
         * whereby ajax calls were being killed when a location change happens
         * (which included downloading an image). To deal with that, I am
         * checking to see if a redirect is happening, and if it is, I delay the
         * ajax call until after (by listening for the redirect/complete event).
         * 
         * That being said, it is also nice to have all the logic in one place.
         * Should result in a cleaner development experience.
         * 
         * @todo!!  Update default error handler to work independent of AppView
         *          having been intantiated. This will probably require a Logging
         *          helper class. The value of modifying things is to ensure that
         *          a logging method is always accessible regardless of whether
         *          the app view has been instantiated (eg. /import or /sign
         *          fails).
         * @access  public
         * @param   Object obj
         * @return  void
         */
        ajax: function(obj) {
            if (Stencil.get('redirecting') === true) {
                Stencil.once({
                    'redirect/complete': Stencil.ajax.proxy(Stencil, [obj])
                });
            } else {

                // Data formatting and csrf
                var data = obj.data || {},
                    csrf = DataUtils.getRandomString(16);
                if (data.constructor === Function.constructor) {
                    data = data(csrf);
                } else {
                    data = {
                        csrf: csrf,
                        data: data
                    };
                }

                // Security
                var currentUnixTimestamp = new Date().getTime() / 1000;
                data.security = {
                    time: {
                        unix: {
                            full: currentUnixTimestamp,
                            simple: Math.floor(currentUnixTimestamp)
                        }
                    },
                    version: Stencil.get('version')
                };

                // Dump the data if nothing should be passed on (eg. icons)
                if (obj.excludeDefaultData === true) {
                    data = {};
                }

                /**
                 * Timeout
                 * 
                 * Set the timeout locally here, so that when it's defined, it's
                 * exactly 5-seconds less than the server-side timeout. This is
                 * to ensure the front-end can capture the timeout before the
                 * server fails.
                 * 
                 * The reason we have to check for the config existing is
                 * because 
                 */
                var defaultTimeout = 25;
                if (Stencil.get('config') !== undefined) {
                    defaultTimeout = Stencil.get('config').runtime.timeout - 5;
                }

                // Call
                jQuery.ajax({
                    // cache: obj.cache || false,
                    cache: obj.cache === undefined ? true: obj.cache,
                    crossdomain: obj.crossdomain || false,
                    url: obj.url,
                    type: obj.type,
                    data: data,
                    error: obj.error || function(jqXHR, textStatus, errorThrown) {

                        // Segment tracking
                        Track.event('Ajax Error (Stencil)', {
                            _code: obj.signature.line,
                            _reference: obj.signature.file,
                            _data: JSON.stringify(obj.data || {}),
                            _url: obj.url,
                            _textStatus: textStatus
                        });

                        // Console logging
                        LogUtils.log.object(Stencil, 'jQuery AJAX error', true);
                        LogUtils.log.object(Stencil, obj.signature, true);
                        LogUtils.log.object(Stencil, arguments, true);

                        // Connection check
                        Stencil.alive(function() {
                            var code = obj.signature.line,
                                reference = obj.signature.file;
                            Stencil.error(code, reference);
                        });
                    },
                    success: [
                        function(response) {
                            if (Stencil.get('version') === undefined) {
                                if (typeof response === 'object') {
                                    var version = response.version;
                                    if (version !== undefined) {
                                        Stencil.set('version', version);
                                    }
                                }
                            }
                        },
                        function(response) {
                            if (typeof response === 'object') {
                                if (response.success === true) {
                                    if (obj.success !== undefined) {
                                        obj.success.apply(obj, [response]);
                                    }
                                } else {
                                    var error = Stencil.extractError(response);

                                    // Maintenace mode
                                    if (
                                        error.validator !== false
                                        && error.validator[1] === 'notInMaintenanceMode'
                                    ) {
                                        Stencil.alert('app.maintenance');
                                        Stencil.kill();
                                    }
                                    // Data integrity failure
                                    else if (
                                        error.validator !== false
                                        && error.validator[1] === 'validData'
                                    ) {
                                        Stencil.alert('security.failedDataIntegrityCheck');
                                        Stencil.kill();
                                    } 
                                    // Data integrity failure
                                    else if (
                                        error.validator !== false
                                        && error.validator[0] === 'AccountValidator'
                                        && error.validator[1] === 'sessionAccountExists'
                                    ) {
                                        Stencil.alert('account.sessionAccount.false');
                                        Stencil.kill();
                                    }
                                    // Otherwise..
                                    else {
                                        obj.success.apply(obj, [response]);
                                    }
                                }
                            } else {
                                if (obj.success !== undefined) {
                                    obj.success.apply(obj, [response]);
                                }
                            }
                        }
                    ],
                    dataType: obj.dataType || 'json',
                    timeout: obj.timeout || (defaultTimeout) * 1000
                    // timeout: obj.timeout || 10 * 1000
                });
            }
        },

        /**
         * alert
         * 
         * @access  public
         * @param   String code
         * @return  void
         */
        alert: function(code) {
            Stencil.navigate('/app/alert/' + (code) + '?clean=1');
        },

        /**
         * alive
         * 
         * Attempts to load a small image to determine if a connection to the
         * server can be made. If yes, the callback is run. Otherwise, an alert
         * is shown informing them that they need to reload the app. At the
         * moment, trying to load from imgur instead of static file on app
         * server, since if they can't reach imgur, it's almost certain their
         * connection is donw. But if they can't reach static file on app
         * server, it's possible that app server is down, instead of internet
         * connection.
         * 
         * Stencil.set call is made against alive-key to prevent Stencil.alert
         * from tracking the alert (via Segment).
         * 
         * @todo!   Tier this so connection tests are made to both a local static
         *          asset as well as one on a 3rd-party site (eg. imgur).
         * @note    Keep in mind some countries (eg. Turkey) can block certain
         *          domains (eg. imgur).
         * @access  public
         * @param   Function callback
         * @return  void
         */
        alive: function(callback) {
            // var src = 'https://i.imgur.com/GqNxmpB.png',
            var src = '/app/static/images/200.png',
                image = new Image();
            if (Config.getRole() === 'local') {
                src = 'https://getstencil.com' + (src);
            }
            image.onload = callback;
            image.src = (src) + '?' + DataUtils.getRandomString();
            image.onerror = function() {
                Track.disable();
                Stencil.set('alive', false);
                Stencil.alert('connection');
                Stencil.kill();
            };
        },

        /**
         * cookies
         * 
         * @access  public
         * @var     Object
         */
        cookies: {

            /**
             * remove
             * 
             * @access  public
             * @param   Array key
             * @return  void
             */
            remove: function(key) {
                Cookies.remove(key, {
                    path: '/',
                    domain: ''
                });
            },

            /**
             * set
             * 
             * @note    Not currently being used anywhere.
             * @access  public
             * @param   Array key
             * @param   mixed value
             * @return  void
             */
            set: function(key, value) {
                Cookies.set(key, value, {
                    domain: '',
                    expires: 365,
                    path: '/',
                    secure: true
                });
            }
        },

        /**
         * error
         * 
         * Redirects the user to an error view (via AppController). Multiple
         * error-redirects is prevented within Router.js by checking if an
         * ErrorModal is already open, or else if an AlertModal that is not
         * closable is open.
         * 
         * @access  public
         * @param   String code
         * @param   String reference
         * @return  void
         */
        error: function(code, reference) {
            var path = '/app/error' +
                '?code=' + (code) +
                '&reference=' + (reference) +
                '&clean=1';
            Stencil.navigate(path);
            Stencil.kill();
        },

        /**
         * extractError
         * 
         * Attempts to drill down into an ajax response to find a failed rule
         * error. This is used with Stencil.error for debugging purposes.
         * 
         * @access  public
         * @param   Object response
         * @return  Object
         */
        extractError: function(response) {
            if (response.failedRules) {
                if (response.failedRules[0]) {
                    if (response.failedRules[0].error) {
                        var error = response.failedRules[0].error;
                        return {
                            validator: response.failedRules[0].validator,
                            code: error.code || 'uk1',
                            reference: error.reference || 'crash1'
                        };
                    }
                }
            }
            return {
                validator: false,
                code: 'uk0',
                reference: 'crash0'
            };
        },

        /**
         * globalFeatures
         * 
         * @access  public
         * @var     Object
         */
        globalFeatures: {

            /**
             * add
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            add: function(accessor) {
                var globalFeatures = Stencil.get('globalFeatures'),
                    key = accessor.get('key');
                if (accessor.toString() === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                globalFeatures.push(key);
            },

            /**
             * remove
             * 
             * @access  public
             * @param   Accessor accessor
             * @return  void
             */
            remove: function(accessor) {
                var globalFeatures = Stencil.get('globalFeatures'),
                    key = accessor.get('key'),
                    index;
                if (accessor.toString() === 'AssetAccessor') {
                    key = accessor.get('resourceType') + ':' +
                        accessor.get('resourceId');
                }
                index = globalFeatures.indexOf(key);
                if (index !== -1) {
                    globalFeatures.splice(index, 1);
                }
            }
        },

        /**
         * get
         * 
         * @access  public
         * @param   String key
         * @return  mixed
         */
        get: function(key) {
            return __store[key];
        },

        /**
         * getAccessor
         * 
         * @access  public
         * @param   String key
         * @return  Accessor|false
         */
        getAccessor: function(key) {
            return __store.accessors && __store.accessors[key] || false;
        },

        /**
         * getAction
         * 
         * Returns a function, which proxies through to a controller and action.
         * The advantage of this approach is that since <getAction> is used
         * within Router upon page-load, I can return this reference without
         * having to wait for the appropriate controllers to be loaded into
         * memory.
         * 
         * @access  public
         * @param   String controller
         * @param   String|Array action
         * @param   String event
         * @return  Function
         */
        getAction: function(controller, action, event) {
            if (jQuery.isArray(action) === false) {
                action = [action];
            }
            var closure = function() {
                var reference = Stencil.getController(controller);
                if (action.length === 1) {
                    reference[action[0]].apply(reference, arguments);
                } else if (action.length === 2) {
                    reference[action[0]][action[1]].apply(reference, arguments);
                } else {
                    throw new Error('Invalid action length');
                }
            };
            closure.toString = function() {
                return event;
            };
            return closure;
        },

        /**
         * getCategories
         * 
         * @access  public
         * @param   String type
         * @return  Array
         */
        getCategories: function(type) {
            var categories = Config.get('categories'),
                matches = [];
            for (var index in categories) {
                if (categories[index].type === type) {
                    matches.push(categories[index]);
                }
            }
            return matches;
        },

        /**
         * getCollection
         * 
         * @access  public
         * @param   String id
         * @return  Collection
         */
        // getCollection: function(id) {
        //     return __store.collections && __store.collections[id] || false;
        // },

        /**
         * getController
         * 
         * @access  public
         * @param   String name
         * @return  Controller
         */
        getController: function(name) {
            if (__store.controllers && __store.controllers[name]) {
                return __store.controllers[name];
            }
            var reference = (name) + 'Controller';
            __store.controllers = __store.controllers || {};
            __store.controllers[name] = new window[reference]();
            return __store.controllers[name];
        },

        /**
         * getFilterResampleDelay
         * 
         * @access  public
         * @return  Number
         */
        getFilterResampleDelay: function() {
            return Config.default('filterResampleDelay').toInt();
        },

        /**
         * getMessage
         * 
         * @access  public
         * @param   String key
         * @return  String
         */
        getMessage: function(key) {
            return Config.get('messages')[key];
        },

        /**
         * getModel
         * 
         * @access  public
         * @param   String name
         * @return  Model
         */
        getModel: function(name) {
            if (__store.models && __store.models[name]) {
                return __store.models[name];
            }
            var reference = (name) + 'Model';
            __store.models = __store.models || {};
            __store.models[name] = new window[reference]();
            return __store.models[name];
        },

        /**
         * getOptions
         * 
         * @access  public
         * @return  Object
         */
        getOptions: function() {
            return __options;
        },

        /**
         * getResizeDelay
         * 
         * @access  public
         * @param   String key
         * @return  Number
         */
        getResizeDelay: function(key) {
            return Config.default('resizeDelays')[key];
        },

        /**
         * getRouter
         * 
         * @access  public
         * @return  Router
         */
        getRouter: function() {
            return __router;
        },

        /**
         * getSaveDelay
         * 
         * @access  public
         * @param   String key
         * @return  Number
         */
        getSaveDelay: function(key) {
            return Config.default('saveDelays')[key];
        },

        /**
         * init
         * 
         * @access  public
         * @param   Object options
         * @return  void
         */
        init: function(options) {

            // 
            __options = options;
            if (__options.source.external === true) {

                /**
                 * This click event is intended to capture the user clicking on
                 * body element outside of the app, which we interpret to mean
                 * "close the app". There's a bug with Chrome whereby
                 * right-clicking in the app (which shows the context menu),
                 * pressing escape, switching to a new tab, and then focusing on
                 * the original tab again triggers a <click> event against the
                 * body. I'm not sure why this happens, but to prevent the app
                 * from closing when the user focuses back on the tab, I check
                 * the coordinates of the mouse, and when it seems unlikely it
                 * was the user, I do not close it. The first screen shot below
                 * shows the event object when a user manually clicks on the
                 * body. The second shows the event when the body:click event is
                 * triggered by some unknown process:
                 * https://i.imgur.com/ulb9YzW.png
                 * https://i.imgur.com/1TFn0iV.png
                 * 
                 * @todo    Look into why this is happening; there is likely a
                 *          more elegant way of handling this.
                 */
                $('body').click(function(event) {
                    var $target = $(event.target);
                    if ($target.tag() === 'body') {
                        if (event.clientX !== 0 && event.clientY !== 0) {
                            App.hide();
                        }
                    }
                });
            }

            // Create router
            __router = new Router();
            Stencil.set('alive', true);
            __setupMoment();

            // Posting
            if (__options.source.external === true) {
                __addPostMessageListeners();
                Stencil.postMessage('message.app.opened');
            } else {
                __launch(function() {
                    if (Account.showWelcomeTour() === true) {
                        Stencil.account().push('settings.hasSeenWelcomeTour', 1);
                        Stencil.navigate('/app/welcome');
                    }
                });
            }
        },

        /**
         * import
         * 
         * Notice that in the error handler, I've created a logProxy function.
         * This is because traditionally, I access the logging method through
         * App.log, but in this case, if import fails, the App view will not
         * have yet been instantiated. So in that case, I go straight to
         * Stencil.
         * 
         * Hmm, maybe I should always be going through Stencil? The problem at
         * the time of writing is that the Stencil.log method has too many
         * parameters. So maybe a Logging js helper file should be created, and
         * all log calls are simply proxies to that?
         * 
         * @todo!   See note above about creating a Logging.js file
         * @access  public
         * @param   String url
         * @param   Function success
         * @param   Function fail
         * @return  void
         */
        import: function(url, success, fail) {
            Stencil.ajax({
                signature: {file: 'Stencil', line: 1038},
                url: '/import',
                type: 'POST',
                data: {
                    url: url
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    LogUtils.log.simple('jQuery AJAX error', true);
                    LogUtils.log.simple(arguments, true);
                    LogUtils.log.simple('s893', true);
                },
                success: function(response) {
                    if (response.success === true) {
                        success && success(response.data);
                    } else {
                        var error = Stencil.extractError(response);
                        fail && fail(error);
                    }
                }
            });
        },

        /**
         * importUrl
         * 
         * @note    This method works a bit differently because an AppView is not
         *          yet instantiated.
         * @access  public
         * @param   String url
         * @param   false|string selection
         * @return  void
         */
        importUrl: function(url, selection) {
            var msg = __options.messages['image.import.loading'];
            $('body div.busy div.copy').html(msg);
            Stencil.import(
                url,
                function(data) {
                    var model = Stencil.getModel('Upload'),
                        upload = model.setAccessor(data.object);
                    // upload.preload(function() {
                        __launch(function() {
                            msg = Stencil.getMessage('image.import.almost');
                            App.getBusy().show(msg);
                            Stencil.navigate('/app/uploads');
                            App.getBusy().show(msg);
                            var canvas = Canvases.Preview;
                            canvas.once({
                                'render': function(event) {
                                    canvas.clear(false);
                                    var layer = canvas.getBackgroundBitmapImageLayer(),
                                        drawing = layer.getDrawing();
                                    canvas.getBusy().show();
                                    drawing.once({
                                        'refresh': function(event) {
                                            canvas.getBusy().hide();
                                            App.getBusy().hide();
                                            if (selection !== false) {
                                                layer = canvas.addTextLayer({
                                                    text: selection.trim(),
                                                    width: 80
                                                });
                                                drawing = layer.getDrawing();
                                                drawing.once({
                                                    'draw': function(event) {
                                                        drawing.animate();
                                                    }
                                                });
                                                drawing.draw();
                                            }
                                        }
                                    });
                                    upload.select(
                                        'load',
                                        false,
                                        {
                                            destination: 'background'
                                        }
                                    );
                                }
                            });
                        });
                    // });
                },
                function(error) {
                    var key = 'import.failed';
                    if (error.validator !== false) {
                        if (error.validator[1] === 'validFilesize') {
                            key = 'import.failed.max.filesize';
                        }
                    }
                    __launch(function() {
                        Canvases.Preview.once({
                            'render': function(event) {
                                Stencil.alert(key);
                            }
                        });
                    });
                }
            );
        },

        /**
         * kill
         * 
         * Runs a kind of clean up when the app is no longer alive. Examples of
         * this include an alert that forces a page reload or an error.
         * 
         * @note    I set active to 0 to ensure they don't get the unbeforeunlock
         *          alert
         *          [OLD]
         * @note    I believe the way jQuery.active works is as follows:
         *          If any response comes back (eg. a 503, 500, 404),
         *          jQuery.active will be decremented. It is possible that it's
         *          not decremented when no response comes back. Notably, this
         *          happens in VectorImageDrawing instances if there is a CORS
         *          issue. The error handler for the outbound jQuery check is
         *          fired, but since no actual response comes back, jQuery does
         *          not decrement it. At least, that's what I think. So it seems
         *          like I need to decrement the jQuery.active property in cases
         *          where there might not be a response, possibly do to a
         *          cross domain or permissions issue (like, an invalid CORS
         *          request).
         *          [OLD]
         * @access  public
         * @return  void
         */
        kill: function() {
            if (__dead === false) {
                __dead = true;
                $('*').unbind();
                $('.fa-spin').removeClass('fa-spin');
                $(window).unbind('resize');
                TimeoutPool.clearAll();
                IntervalPool.clearAll();
                XHRPool.abortAll();
            }
        },

        /**
         * freeze
         * 
         * @access  public
         * @return  void
         */
        freeze: function() {
            App.getElement().addClass('disabled');
            __frozen = true;
        },

        /**
         * frozen
         * 
         * @access  public
         * @return  Boolean
         */
        frozen: function() {
            return __frozen;
        },

        /**
         * navigate
         * 
         * Either proxies the routing method if the param <clean> is found, or
         * else uses Backbone's url-routing system for the app-state.
         * 
         * @note    replace value below is designed to prevent parent window from
         *          having navigational-records added to it when the app is
         *          laoded externally (eg. Chrome Extension).
         * @access  public
         * @param   String path
         * @param   Boolean trigger
         * @param   Boolean refresh whether a navigate should be forced, even if
         *          the agent is already at that url (used in searching)
         * @return  void
         */
        navigate: function(path, trigger, refresh) {
            if (path.indexOf('clean') !== -1) {
                Backbone.history.loadUrl(path);
            } else {
                if (trigger === undefined) {
                    trigger = true;
                }
                // var routed = __router.navigate(path, trigger);
                var routed = Backbone.history.navigate(path, {
                    trigger: trigger,
                    replace: __options.source.external === true
                });
                if (!routed && refresh) {
                    Backbone.history.loadUrl(path);
                }
            }
        },

        /**
         * postMessage
         * 
         * @access  protected
         * @param   String action
         * @return  void
         */
        postMessage: function(action) {
            window.parent.postMessage(
                JSON.stringify({
                    action: action
                }),
                '*'
            );
        },

        /**
         * receiveElectronMessage
         * 
         * @access  protected
         * @param   Object msg
         * @return  void
         */
        receiveElectronMessage: function(msg) {
            if (msg.action === 'showBusyModal') {
                (function() {
                    var msg = Stencil.getMessage('image.import.electron');
                    App.getBusy().show(msg);
                }).waitForMethod('App.getBusy');
            } else if (msg.action === 'importUrls') {
                var urls = msg.urls;
                for (var index in urls) {
                    urls[index] = encodeURIComponent(urls[index]);
                }
                App.getBusy().hide();
                DataUtils.getUrlsAsBlobs(urls, function(blobs) {
                    if (blobs !== false) {
                        (function() {
                            var dropzone = App.getApplicableDropzone(false);
                            if (dropzone.availableForUpload() === true) {
                                if (dropzone.toString() === 'WatermarksDropzoneView') {
                                    Stencil.navigate('/app/logos');
                                } else {
                                    Stencil.navigate('/app/uploads');
                                }
                                dropzone.receive(blobs);
                            }
                        }).waitForMethod('App.getApplicableDropzone');
                    }
                });
            }
        },

        /**
         * report
         * 
         * @access  protected
         * @param   undefined|String subject (default: '(no subject)')
         * @param   undefined|mixed msg (default: '(no message)')
         * @return  void
         */
        report: function(subject, msg) {
            subject = DataUtils.getDefaultValue(subject, '(no subject)');
            msg = DataUtils.getDefaultValue(msg, '(no message)');
            Stencil.ajax({
                signature: {file: 'Stencil', line: 1758},
                url: '/admin/report',
                type: 'POST',
                data: {
                    msg: JSON.stringify(msg),
                    subject: subject
                }
            });
        },

        /**
         * set
         * 
         * Helper for application-wide hash map.
         * 
         * @access  public
         * @param   String key
         * @param   mixed value
         * @return  void
         */
        set: function(key, value) {
            if (key === 'user' && value !== false) {
                if ('Raven.setUserContext'.validMethod() === true) {
                    Raven.setUserContext({
                        email: value.get('email'),
                        id: value.get('id')
                    });
                }
            }
            __store[key] = value;
        },

        /**
         * setAccessor
         * 
         * @access  public
         * @param   String key
         * @param   String name
         * @param   Object data
         * @return  Accessor
         */
        setAccessor: function(key, name, data) {
            var accessor = Stencil.getAccessor(key);
            if (accessor === false) {
                var reference = (name) + 'Accessor';
                __store.accessors = __store.accessors || {};
                __store.accessors[key] = new window[reference](data);
                accessor = __store.accessors[key];
            } else {
                accessor.merge(data);
            }
            return accessor;
        },

        /**
         * setCollection
         * 
         * @access  public
         * @param   String id
         * @param   String name
         * @return  Collection
         */
        // setCollection: function(id, name) {
        //     var reference = (name) + 'Collection';
        //     __store.collections = __store.collections || {};
        //     __store.collections[id] = new window[reference]();
        //     return __store.collections[id];
        // },

        /**
         * unfreeze
         * 
         * @access  public
         * @return  void
         */
        unfreeze: function() {
            App.getElement().removeClass('disabled');
            __frozen = false;
        }
    });
})();
});
